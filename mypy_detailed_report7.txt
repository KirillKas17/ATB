infrastructure\cache\compression.py:286:1: error: Missing return statement 
[return]
    def estimate_compression_ratio(data: Any, compression_type: Compressio...
    ^
shared\config_validator.py:42:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\config_validator.py:44:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\config_validator.py:301:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\config_validator.py:307:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\sessions\session_monitor.py:24:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\messaging_copy\websocket_service.py:43:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\messaging_copy\websocket_service.py:44:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\messaging_copy\websocket_service.py:45:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\messaging_copy\event_bus.py:40:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\messaging_copy\event_bus.py:41:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\agents\market_maker\cache_service.py:9:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\agents\market_maker\cache_service.py:10:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\agents\market_maker\cache_service.py:11:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\agents\market_maker\cache_service.py:12:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\performance_monitor.py:76:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\performance_monitor.py:77:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\performance_monitor.py:78:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\performance_monitor.py:79:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\performance_monitor.py:81:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\performance_monitor.py:83:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\logging.py:107:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\logging.py:550:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\async_utils.py:31:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\async_utils.py:32:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\async_utils.py:33:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\async_utils.py:34:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\async_utils.py:239:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\async_utils.py:240:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\async_utils.py:241:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\shared\cache.py:509:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\shared\cache.py:510:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\monitoring\monitoring_tracing.py:26:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\monitoring\monitoring_tracing.py:27:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\monitoring\monitoring_alerts.py:31:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\monitoring\monitoring_alerts.py:32:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\monitoring\monitoring_alerts.py:33:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\exchange_streams\stream_aggregator.py:29:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\exchange_streams\stream_aggregator.py:30:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\exchange_streams\stream_aggregator.py:31:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\exchange_streams\stream_aggregator.py:32:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\exchange_streams\stream_aggregator.py:33:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\exchange_streams\stream_aggregator.py:34:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\exchange_streams\stream_aggregator.py:35:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\exchange_streams\stream_aggregator.py:36:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\exchange_streams\stream_aggregator.py:264:60: error:
Incompatible types in assignment (expression has type "dict[str, str]", target
has type "float | int")  [assignment]
    ...              status[source_name]["client_status"] = {"error": str(e)}
                                                            ^~~~~~~~~~~~~~~~~
infrastructure\entity_system\memory\base.py:300:62: error: Unsupported operand
types for < ("str" and "datetime")  [operator]
    ...                   if date_from and metadata["timestamp"] < date_from:
                                                                   ^~~~~~~~~
infrastructure\entity_system\memory\base.py:302:60: error: Unsupported operand
types for > ("str" and "datetime")  [operator]
                        if date_to and metadata["timestamp"] > date_to:
                                                               ^~~~~~~
infrastructure\entity_system\memory\base.py:368:23: error: Incompatible types
(expression has type "datetime", TypedDict item "timestamp" has type "str") 
[typeddict-item]
                timestamp=snapshot['timestamp'],
                          ^~~~~~~~~~~~~~~~~~~~~
infrastructure\entity_system\memory\base.py:476:27: error: Need type annotation
for "stored_checksum"  [var-annotated]
            stored_checksum = self._metadata_cache.get(snapshot_id, {})
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\entity_system\memory\base.py:491:29: error: No overload variant
of "__sub__" of "datetime" matches argument type "str"  [operator]
                    age_days = (current_time - metadata["timestamp"]).days
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\entity_system\memory\base.py:491:29: note: Possible overload variants:
infrastructure\entity_system\memory\base.py:491:29: note:     def __sub__(self, datetime, /) -> timedelta
infrastructure\entity_system\memory\base.py:491:29: note:     def __sub__(self, timedelta, /) -> datetime
infrastructure\entity_system\memory\base.py:534:46: error: "str" has no
attribute "isoformat"  [attr-defined]
                    metadata_copy["timestamp"] = metadata["timestamp"].iso...
                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\market_profiles\analysis\similarity_calculator.py:253:33: error:
TypedDict key must be a string literal; expected one of ("symbol", "timestamp",
"last_price", "volume_24h", "price_change_24h", ...)  [literal-required]
                    val1 = context1[key]
                                    ^~~
infrastructure\market_profiles\analysis\similarity_calculator.py:254:33: error:
TypedDict key must be a string literal; expected one of ("symbol", "timestamp",
"last_price", "volume_24h", "price_change_24h", ...)  [literal-required]
                    val2 = context2[key]
                                    ^~~
infrastructure\entity_system\entity_controller_impl.py:173:53: error: Argument
1 to "float" has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
    ...     self.resource_monitor.cpu_threshold = float(config.get("cpu_thres...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\entity_system\entity_controller_impl.py:174:56: error: Argument
1 to "float" has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
    ...  self.resource_monitor.memory_threshold = float(config.get("memory_th...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\entity_system\entity_controller_impl.py:175:54: error: Argument
1 to "float" has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
    ...    self.resource_monitor.disk_threshold = float(config.get("disk_thre...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\entity_system\entity_controller_impl.py:345:31: error: Item
"None" of "ExperimentRunnerImpl | None" has no attribute "stop_experiment" 
[union-attr]
                            await self.components.experiment_runner.stop_e...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\entity_system\entity_controller_impl.py:366:36: error: Item
"None" of "MemoryManagerImpl | None" has no attribute "create_snapshot" 
[union-attr]
                final_snapshot = await self.components.memory_manager.crea...
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\entity_system\entity_controller_impl.py:729:54: error: Cannot
determine type of "_last_net_io"  [has-type]
    ...                bytes_sent = net_io.bytes_sent - self._last_net_io.byt...
                                                        ^~~~~~~~~~~~~~~~~
infrastructure\entity_system\entity_controller_impl.py:730:54: error: Cannot
determine type of "_last_net_io"  [has-type]
    ...                bytes_recv = net_io.bytes_recv - self._last_net_io.byt...
                                                        ^~~~~~~~~~~~~~~~~
infrastructure\entity_system\entity_controller_impl.py:1075:20: error:
Incompatible return value type (got "dict[str, object]", expected
"Experiment | None")  [return-value]
                return experiment
                       ^~~~~~~~~~
infrastructure\entity_system\entity_controller_impl.py:1086:29: error: Item
"None" of "ExperimentRunnerImpl | None" has no attribute "run_experiment" 
[union-attr]
                results = await self.components.experiment_runner.run_expe...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\entity_system\entity_controller_impl.py:1134:21: error: Item
"None" of "dict[str, Any] | None" has no attribute "get"  [union-attr]
                    and exp.get("results", {}).get("significant", False)
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\entity_system\entity_controller_impl.py:1202:51: error: Item
"None" of "datetime | None" has no attribute "isoformat"  [union-attr]
    ...                                   "applied_at": improvement["applied_...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\entity_system\entity_controller_impl.py:1280:20: error:
Incompatible return value type (got "dict[str, object]", expected
"Improvement | None")  [return-value]
                return improvement
                       ^~~~~~~~~~~
infrastructure\entity_system\entity_controller_impl.py:1292:35: error: Item
"None" of "dict[str, Any] | None" has no attribute "get"  [union-attr]
                improvement_percent = results.get("improvement_percent", 0...
                                      ^~~~~~~~~~~
infrastructure\entity_system\entity_controller_impl.py:1397:34: error: Item
"None" of "dict[str, Any] | None" has no attribute "get"  [union-attr]
                        "threshold": results.get("improvement_percent", 0....
                                     ^~~~~~~~~~~
infrastructure\entity_system\entity_controller_impl.py:1617:45: error:
TypedDict key must be a string literal; expected one of ("analysis_interval",
"experiment_duration", "confidence_threshold", "improvement_threshold",
"ai_enabled", ...)  [literal-required]
                        old_value = self.config[key]
                                                ^~~
infrastructure\entity_system\entity_controller_impl.py:1618:33: error:
TypedDict key must be a string literal; expected one of ("analysis_interval",
"experiment_duration", "confidence_threshold", "improvement_threshold",
"ai_enabled", ...)  [literal-required]
                        self.config[key] = value
                                    ^~~
infrastructure\entity_system\entity_controller_impl.py:1653:20: error:
Incompatible return value type (got "list[dict[str, Any]]", expected
"list[Hypothesis]")  [return-value]
                return ai_hypotheses[:5]  # ќграничиваем количество гипоте...
                       ^~~~~~~~~~~~~~~~~
infrastructure\entity_system\entity_controller_impl.py:1661:13: error: Need
type annotation for "patterns" (hint: "patterns: list[<type>] = ...") 
[var-annotated]
                patterns = []
                ^~~~~~~~
infrastructure\entity_system\entity_controller_impl.py:1968:49: error:
TypedDict key must be a string literal; expected one of ("analysis_interval",
"experiment_duration", "confidence_threshold", "improvement_threshold",
"ai_enabled", ...)  [literal-required]
                            old_value = self.config[key]
                                                    ^~~
infrastructure\entity_system\entity_controller_impl.py:1969:37: error:
TypedDict key must be a string literal; expected one of ("analysis_interval",
"experiment_duration", "confidence_threshold", "improvement_threshold",
"ai_enabled", ...)  [literal-required]
                            self.config[key] = value
                                        ^~~
infrastructure\entity_system\entity_controller_impl.py:2042:13: error: Need
type annotation for "evolution_hypotheses" (hint:
"evolution_hypotheses: list[<type>] = ...")  [var-annotated]
                evolution_hypotheses = []
                ^~~~~~~~~~~~~~~~~~~~
infrastructure\entity_system\entity_controller_impl.py:2078:20: error:
Incompatible return value type (got "list[dict[str, Any]]", expected
"list[Hypothesis]")  [return-value]
                return evolution_hypotheses
                       ^~~~~~~~~~~~~~~~~~~~
infrastructure\entity_system\perception\code_scanner.py:90:37: error:
Incompatible types in assignment (expression has type "dict[str, int]", target
has type "int")  [assignment]
                metrics["complexity"] = complexity
                                        ^~~~~~~~~~
infrastructure\entity_system\perception\code_scanner.py:92:34: error:
Incompatible types in assignment (expression has type "dict[str, Any]", target
has type "int")  [assignment]
                metrics["quality"] = quality
                                     ^~~~~~~
infrastructure\entity_system\perception\code_scanner.py:201:29: error:
Incompatible types in assignment (expression has type
"dict[str, dict[str, Any]]", target has type "list[str]")  [assignment]
            layers["metrics"] = layer_metrics
                                ^~~~~~~~~~~~~
infrastructure\entity_system\core\entity_controller.py:19:1: error: Module
"infrastructure.entity_system.ai_enhancement" has no attribute
"AIEnhancementEngine"  [attr-defined]
    from ..ai_enhancement import (
    ^
infrastructure\entity_system\core\entity_controller.py:19:1: error: Module
"infrastructure.entity_system.ai_enhancement" has no attribute "MLPredictor" 
[attr-defined]
    from ..ai_enhancement import (
    ^
infrastructure\entity_system\core\entity_controller.py:19:1: error: Module
"infrastructure.entity_system.ai_enhancement" has no attribute "NeuralOptimizer"
 [attr-defined]
    from ..ai_enhancement import (
    ^
infrastructure\entity_system\core\entity_controller.py:19:1: error: Module
"infrastructure.entity_system.ai_enhancement" has no attribute
"QuantumOptimizer"  [attr-defined]
    from ..ai_enhancement import (
    ^
infrastructure\entity_system\core\entity_controller.py:25:1: error: Module
"infrastructure.entity_system.evolution" has no attribute "AdaptiveLearning" 
[attr-defined]
    from ..evolution import (
    ^
infrastructure\entity_system\core\entity_controller.py:25:1: error: Module
"infrastructure.entity_system.evolution" has no attribute "EvolutionEngine" 
[attr-defined]
    from ..evolution import (
    ^
infrastructure\entity_system\core\entity_controller.py:25:1: error: Module
"infrastructure.entity_system.evolution" has no attribute "GeneticOptimizer" 
[attr-defined]
    from ..evolution import (
    ^
infrastructure\entity_system\core\entity_controller.py:25:1: error: Module
"infrastructure.entity_system.evolution" has no attribute "MetaLearning" 
[attr-defined]
    from ..evolution import (
    ^
infrastructure\entity_system\core\coordination_engine.py:422:25: error:
Unsupported target for indexed assignment ("Collection[str]")  [index]
                            topology["latency_matrix"][f"{node1_id}-{node2...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\entity_system\core\coordination_engine.py:435:20: error:
Incompatible return value type (got "dict[str, str | None]", expected
"dict[str, str]")  [return-value]
                return routing_table
                       ^~~~~~~~~~~~~
infrastructure\entity_system\ai_enhancement\quantum_optimizer.py:462:16: error:
Incompatible return value type (got "bool_", expected "bool")  [return-value]
            return np.std(recent_scores) < 0.01
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\entity_system\ai_enhancement\ml_predictor.py:437:21: error: Dict
entry 1 has incompatible type "str": "dict[str, float]"; expected "str": "float"
 [dict-item]
                        "model_metrics": {
                        ^
infrastructure\core\risk_manager.py:210:22: error: Argument "name" to "Event"
has incompatible type "str"; expected "EventName"  [arg-type]
                    name="risk.metrics.update",
                         ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\risk_manager.py:211:22: error: Argument "type" to "Event"
has incompatible type "str"; expected "EventType"  [arg-type]
                    type="risk",
                         ^~~~~~
infrastructure\core\risk_manager.py:292:22: error: Argument "name" to "Event"
has incompatible type "str"; expected "EventName"  [arg-type]
                    name="risk.limits.update",
                         ^~~~~~~~~~~~~~~~~~~~
infrastructure\core\risk_manager.py:293:22: error: Argument "type" to "Event"
has incompatible type "str"; expected "EventType"  [arg-type]
                    type="risk",
                         ^~~~~~
infrastructure\core\risk_manager.py:403:26: error: Argument "name" to "Event"
has incompatible type "str"; expected "EventName"  [arg-type]
                        name="risk.position.adjust",
                             ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\risk_manager.py:404:26: error: Argument "type" to "Event"
has incompatible type "str"; expected "EventType"  [arg-type]
                        type="risk",
                             ^~~~~~
infrastructure\core\metrics.py:278:21: error: Missing positional arguments
"name", "type" in call to "Event"  [call-arg]
                event = MessagingEvent(
                        ^
infrastructure\core\health_checker.py:528:21: error: Missing positional
arguments "name", "type" in call to "Event"  [call-arg]
                event = MessagingEvent(
                        ^
infrastructure\core\circuit_breaker.py:84:40: error: No overload variant of
"int" matches argument type "object"  [call-overload]
                circuit["failure_count"] = int(failure_count or 0)
                                           ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\circuit_breaker.py:84:40: note: Possible overload variants:
infrastructure\core\circuit_breaker.py:84:40: note:     def __new__(cls, str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc = ..., /) -> int
infrastructure\core\circuit_breaker.py:84:40: note:     def __new__(cls, str | bytes | bytearray, /, base: SupportsIndex) -> int
infrastructure\core\circuit_breaker.py:85:9: error: Unsupported operand types
for + ("object" and "int")  [operator]
            circuit["failure_count"] += 1
            ^
infrastructure\core\circuit_breaker.py:110:13: error: Missing positional
arguments "name", "type" in call to "Event"  [call-arg]
                MessagingEvent(
                ^
infrastructure\core\circuit_breaker.py:110:13: error: Argument 1 to "publish"
of "EventBus" has incompatible type "domain.types.messaging_types.Event";
expected "infrastructure.messaging.optimized_event_bus.Event"  [arg-type]
                MessagingEvent(
                ^
infrastructure\core\circuit_breaker.py:153:13: error: Missing positional
arguments "name", "type" in call to "Event"  [call-arg]
                MessagingEvent(
                ^
infrastructure\core\circuit_breaker.py:153:13: error: Argument 1 to "publish"
of "EventBus" has incompatible type "domain.types.messaging_types.Event";
expected "infrastructure.messaging.optimized_event_bus.Event"  [arg-type]
                MessagingEvent(
                ^
infrastructure\core\circuit_breaker.py:169:44: error: No overload variant of
"int" matches argument type "object"  [call-overload]
                    circuit["success_count"] = int(circuit.get("success_co...
                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\circuit_breaker.py:169:44: note: Possible overload variants:
infrastructure\core\circuit_breaker.py:169:44: note:     def __new__(cls, str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc = ..., /) -> int
infrastructure\core\circuit_breaker.py:169:44: note:     def __new__(cls, str | bytes | bytearray, /, base: SupportsIndex) -> int
infrastructure\core\circuit_breaker.py:170:13: error: Unsupported operand types
for + ("object" and "int")  [operator]
                circuit["success_count"] += 1
                ^
infrastructure\core\circuit_breaker.py:194:13: error: Missing positional
arguments "name", "type" in call to "Event"  [call-arg]
                MessagingEvent(
                ^
infrastructure\core\circuit_breaker.py:194:13: error: Argument 1 to "publish"
of "EventBus" has incompatible type "domain.types.messaging_types.Event";
expected "infrastructure.messaging.optimized_event_bus.Event"  [arg-type]
                MessagingEvent(
                ^
infrastructure\core\circuit_breaker.py:300:13: error: Missing positional
arguments "name", "type" in call to "Event"  [call-arg]
                MessagingEvent(
                ^
infrastructure\core\circuit_breaker.py:300:13: error: Argument 1 to "publish"
of "EventBus" has incompatible type "domain.types.messaging_types.Event";
expected "infrastructure.messaging.optimized_event_bus.Event"  [arg-type]
                MessagingEvent(
                ^
infrastructure\agents\evolvable_meta_controller.py:235:29: error: "object" has
no attribute "extend"  [attr-defined]
                                aggregated["signals"].extend(signals)
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\news\observers.py:33:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\sessions\session_marker.py:360:16: error: Incompatible return value type
(got "dict[str, str | float | int] | None", expected "dict[str, object] | None")
 [return-value]
            return stats if stats else None
                   ^~~~~~~~~~~~~~~~~~~~~~~~
domain\protocols\performance.py:143:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\performance.py:144:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\performance.py:226:26: error: Argument "avg_time" to
"PerformanceProfile" has incompatible type "floating[Any]"; expected "float" 
[arg-type]
                    avg_time=np.mean(times),
                             ^~~~~~~~~~~~~~
domain\protocols\performance.py:229:26: error: Argument "std_time" to
"PerformanceProfile" has incompatible type "floating[Any]"; expected "float" 
[arg-type]
                    std_time=np.std(times),
                             ^~~~~~~~~~~~~
domain\protocols\performance.py:230:26: error: Argument "p95_time" to
"PerformanceProfile" has incompatible type "floating[Any]"; expected "float" 
[arg-type]
                    p95_time=np.percentile(times, 95),
                             ^~~~~~~~~~~~~~~~~~~~~~~~
domain\protocols\performance.py:231:26: error: Argument "p99_time" to
"PerformanceProfile" has incompatible type "floating[Any]"; expected "float" 
[arg-type]
                    p99_time=np.percentile(times, 99),
                             ^~~~~~~~~~~~~~~~~~~~~~~~
domain\protocols\performance.py:234:27: error: Argument "cpu_usage" to
"PerformanceProfile" has incompatible type "floating[Any]"; expected "float" 
[arg-type]
                    cpu_usage=np.mean([p.cpu_usage for p in recent_profile...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\protocols\performance.py:252:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\performance.py:273:9: error: Need type annotation for
"memory_usage" (hint: "memory_usage: list[<type>] = ...")  [var-annotated]
            memory_usage = []
            ^~~~~~~~~~~~
domain\protocols\performance.py:301:22: error: Argument "avg_time" to
"BenchmarkResult" has incompatible type "floating[Any]"; expected "float" 
[arg-type]
                avg_time=avg_time,
                         ^~~~~~~~
domain\protocols\performance.py:304:22: error: Argument "std_time" to
"BenchmarkResult" has incompatible type "floating[Any]"; expected "float" 
[arg-type]
                std_time=std_time,
                         ^~~~~~~~
domain\protocols\performance.py:358:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\performance.py:438:9: error: Need type annotation for "cache"
(hint: "cache: dict[<type>, <type>] = ...")  [var-annotated]
            cache = {}
            ^~~~~
domain\market_maker\mm_pattern_memory.py:238:37: error: Argument 1 to "float"
has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                    key=lambda x: float(x["similarity_score"]), reverse=Tr...
                                        ^~~~~~~~~~~~~~~~~~~~~
domain\market_maker\mm_pattern_memory.py:526:21: error: Argument 2 to
"run_in_executor" of "AbstractEventLoop" has incompatible type
"Callable[[Path, list[dict[str, Any]]], None]"; expected
"Callable[[Path, list[PatternMemoryDict]], None]"  [arg-type]
                        self._write_patterns_to_file,
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\market_maker\mm_pattern_memory.py:546:33: error: "object" has no
attribute "isoformat"  [attr-defined]
                    "last_cleanup": self.storage_stats["last_cleanup"].iso...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\risk\liquidity_gravity_monitor.py:375:17: error:
"LiquidityGravityResult" has no attribute "gravity_score"  [attr-defined]
                    f"Saved results for {symbol}: "
                    ^
application\monitoring\pattern_observer.py:91:32: error: "Timestamp" has no
attribute "isoformat"  [attr-defined]
                "start_timestamp": self.start_timestamp.isoformat(),
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\monitoring\pattern_observer.py:102:28: error: "Timestamp" has no
attribute "isoformat"  [attr-defined]
                "last_update": self.last_update.isoformat(),
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~
application\monitoring\pattern_observer.py:137:32: error: "Timestamp" has no
attribute "isoformat"  [attr-defined]
                "start_timestamp": self.start_timestamp.isoformat(),
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\monitoring\pattern_observer.py:138:30: error: "Timestamp" has no
attribute "isoformat"  [attr-defined]
                "end_timestamp": self.end_timestamp.isoformat(),
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\monitoring\pattern_observer.py:175:26: error: "Timestamp" has no
attribute "isoformat"  [attr-defined]
                "timestamp": self.timestamp.isoformat(),
                             ^~~~~~~~~~~~~~~~~~~~~~~~
shared\unified_cache.py:61:24: error: "DataFrame" has no attribute
"memory_usage"  [attr-defined]
                    return self.value.memory_usage(deep=True).sum()
                           ^~~~~~~~~~~~~~~~~~~~~~~
shared\unified_cache.py:184:17: error: "dict[str, CacheEntry]" has no attribute
"move_to_end"  [attr-defined]
                    self._cache.move_to_end(key)
                    ^~~~~~~~~~~~~~~~~~~~~~~
shared\unified_cache.py:301:25: error: Unsupported target for indexed
assignment ("Collection[str]")  [index]
                            cache_data["entries"][key] = {
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~
shared\indicators.py:16:9: error: Module has no attribute "cut"  [attr-defined]
            pd.cut(data["price"], bins, retbins=True, labels=False),
            ^~~~~~
shared\indicators.py:17:9: error: Module has no attribute "cut"  [attr-defined]
            pd.cut(data["price"], bins, retbins=True)[1],
            ^~~~~~
shared\indicators.py:19:22: error: "DataFrame" has no attribute "groupby" 
[attr-defined]
        volume_profile = data.groupby(hist)["volume"].sum()
                         ^~~~~~~~~~~~
shared\data_loader.py:4:12: error: Module has no attribute "read_csv" 
[attr-defined]
        return pd.read_csv(filepath)
               ^~~~~~~~~~~
shared\data_loader.py:8:5: error: "DataFrame" has no attribute "to_csv" 
[attr-defined]
        data.to_csv(filepath)
        ^~~~~~~~~~~
interfaces\presentation\dashboard\app.py:19:5: error: Module
"infrastructure.entity_system.application" has no attribute "ImprovementApplier"
 [attr-defined]
        from infrastructure.entity_system.application import ImprovementAp...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
interfaces\presentation\dashboard\app.py:20:5: error: Module
"infrastructure.entity_system.core" has no attribute "EntityAnalytics" 
[attr-defined]
        from infrastructure.entity_system.core import EntityAnalytics
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\api.py:27:5: error: Module
"infrastructure.entity_system.core" has no attribute "force_entity_analysis" 
[attr-defined]
        from infrastructure.entity_system.core import (force_entity_analys...
        ^
interfaces\presentation\dashboard\api.py:27:5: error: Module
"infrastructure.entity_system.core" has no attribute "get_entity_status" 
[attr-defined]
        from infrastructure.entity_system.core import (force_entity_analys...
        ^
interfaces\presentation\dashboard\api.py:49:10: error: Incompatible types in
assignment (expression has type "logging.Logger", variable has type
"loguru.Logger")  [assignment]
    logger = logging.getLogger(__name__)
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\api.py:121:13: error: Need type annotation
for "bot_state"  [var-annotated]
    bot_state = {
                ^
interfaces\presentation\dashboard\api.py:244:39: error: Incompatible types in
assignment (expression has type "str", target has type
"list[Any] | datetime | bool | None")  [assignment]
            bot_state["current_symbol"] = request.symbol
                                          ^~~~~~~~~~~~~~
interfaces\presentation\dashboard\api.py:245:42: error: Incompatible types in
assignment (expression has type "str", target has type
"list[Any] | datetime | bool | None")  [assignment]
            bot_state["current_timeframe"] = request.timeframe
                                             ^~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\api.py:383:9: error: Item "datetime" of
"list[Any] | datetime | bool | None" has no attribute "append"  [union-attr]
            bot_state["errors"].append(
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\api.py:383:9: error: Item "bool" of
"list[Any] | datetime | bool | None" has no attribute "append"  [union-attr]
            bot_state["errors"].append(
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\api.py:383:9: error: Item "None" of
"list[Any] | datetime | bool | None" has no attribute "append"  [union-attr]
            bot_state["errors"].append(
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\api.py:408:19: error: Name
"handle_subscription" is not defined  [name-defined]
                await handle_subscription(websocket, data)
                      ^~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\api.py:410:19: error: Name
"handle_unsubscription" is not defined  [name-defined]
                await handle_unsubscription(websocket, data)
                      ^~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\api.py:464:2: error: Name "get_status"
already defined on line 213  [no-redef]
    @app.get("/api/v1/status")
     ^
interfaces\presentation\dashboard\api.py:560:45: error: Invalid index type
"str" for "str"; expected type "SupportsIndex | slice[Any, Any, Any]"  [index]
                if datetime.fromisoformat(point["timestamp"]) >= start_tim...
                                                ^~~~~~~~~~~
interfaces\presentation\dashboard\api.py:592:18: error: Value of type
"Collection[str]" is not indexable  [index]
            trades = mock_data["trades"][:limit]
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\base_strategy.py:187:16: error: "DataFrame" has no
attribute "isnull"  [attr-defined]
                if data.isnull().any().any():
                   ^~~~~~~~~~~
infrastructure\strategies\base_strategy.py:313:20: error: "Series" has no
attribute "cov"  [attr-defined]
                beta = returns.cov(market_returns) / market_returns.var()
                       ^~~~~~~~~~~
infrastructure\strategies\base_strategy.py:338:40: error: Unsupported operand
types for > ("int" and "Series")  [operator]
                downside_returns = returns[returns < 0]
                                           ^
infrastructure\strategies\base_strategy.py:348:29: error: Unsupported operand
types for < ("int" and "Series")  [operator]
                gains = returns[returns > 0]
                                ^
infrastructure\strategies\base_strategy.py:349:30: error: Unsupported operand
types for > ("int" and "Series")  [operator]
                losses = returns[returns < 0]
                                 ^
infrastructure\sessions\session_validator.py:37:12: error: "DataFrame" has no
attribute "isnull"  [attr-defined]
            if market_data.isnull().any().any():
               ^~~~~~~~~~~~~~~~~~
infrastructure\sessions\session_validator.py:68:31: error: "SessionMetrics" has
no attribute "price_direction_bias"  [attr-defined]
                    if not (-1 <= analysis.metrics.price_direction_bias <=...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:90:12: error: "Series"
has no attribute "rolling"  [attr-defined]
        return prices.rolling(window=period).mean()
               ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:97:12: error: "Series"
has no attribute "ewm"  [attr-defined]
        return prices.ewm(span=period).mean()
               ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:105:12: error:
"Series" has no attribute "rolling"  [attr-defined]
        return prices.rolling(window=period).apply(
               ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:114:12: error:
Incompatible return value type (got "int", expected "Series")  [return-value]
        return 2 * ema1 - ema2
               ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:114:16: error:
Unsupported operand types for * ("int" and "Series")  [operator]
        return 2 * ema1 - ema2
                   ^~~~
infrastructure\services\technical_analysis\indicators.py:114:23: error:
Unsupported operand types for - ("int" and "Series")  [operator]
        return 2 * ema1 - ema2
                          ^~~~
infrastructure\services\technical_analysis\indicators.py:122:12: error:
Incompatible return value type (got "int", expected "Series")  [return-value]
        return 3 * ema1 - 3 * ema2 + ema3
               ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:122:16: error:
Unsupported operand types for * ("int" and "Series")  [operator]
        return 3 * ema1 - 3 * ema2 + ema3
                   ^~~~
infrastructure\services\technical_analysis\indicators.py:122:34: error:
Unsupported operand types for + ("int" and "Series")  [operator]
        return 3 * ema1 - 3 * ema2 + ema3
                                     ^~~~
infrastructure\services\technical_analysis\indicators.py:132:11: error:
"Series" has no attribute "rolling"  [attr-defined]
        std = prices.rolling(window=period).std()
              ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:150:24: error:
"Series" has no attribute "index"  [attr-defined]
        sar = Series(index=close.index, dtype=float)
                           ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:151:26: error:
"Series" has no attribute "index"  [attr-defined]
        trend = Series(index=close.index, dtype=bool)
                             ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:153:5: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
        sar.iloc[0] = low.iloc[0]
        ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:153:19: error: Value
of type "Callable[[], Any]" is not indexable  [index]
        sar.iloc[0] = low.iloc[0]
                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:154:5: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
        trend.iloc[0] = True  # True = восход€щий тренд
        ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:156:12: error: Value
of type "Callable[[], Any]" is not indexable  [index]
            if trend.iloc[i - 1]:
               ^~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:158:13: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                sar.iloc[i] = sar.iloc[i - 1] + acceleration * (
                ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:158:27: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                sar.iloc[i] = sar.iloc[i - 1] + acceleration * (
                              ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:159:17: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                    high.iloc[i - 1] - sar.iloc[i - 1]
                    ^~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:161:13: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                sar.iloc[i] = min(
                ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:162:17: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                    sar.iloc[i],
                    ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:163:17: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                    low.iloc[i - 1],
                    ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:164:17: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                    low.iloc[i - 2] if i > 1 else low.iloc[i - 1],
                    ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:166:16: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                if close.iloc[i] < sar.iloc[i]:
                   ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:167:17: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                    trend.iloc[i] = False
                    ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:168:17: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                    sar.iloc[i] = high.iloc[i - 1]
                    ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:168:31: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                    sar.iloc[i] = high.iloc[i - 1]
                                  ^~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:170:17: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                    trend.iloc[i] = True
                    ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:173:13: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                sar.iloc[i] = sar.iloc[i - 1] - acceleration * (
                ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:173:27: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                sar.iloc[i] = sar.iloc[i - 1] - acceleration * (
                              ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:174:17: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                    sar.iloc[i - 1] - low.iloc[i - 1]
                    ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:176:13: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                sar.iloc[i] = max(
                ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:177:17: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                    sar.iloc[i],
                    ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:178:17: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                    high.iloc[i - 1],
                    ^~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:179:17: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                    high.iloc[i - 2] if i > 1 else high.iloc[i - 1],
                    ^~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:181:16: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                if close.iloc[i] > sar.iloc[i]:
                   ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:182:17: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                    trend.iloc[i] = True
                    ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:183:17: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                    sar.iloc[i] = low.iloc[i - 1]
                    ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:183:31: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                    sar.iloc[i] = low.iloc[i - 1]
                                  ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:185:17: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                    trend.iloc[i] = False
                    ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:200:19: error:
"Series" has no attribute "rolling"  [attr-defined]
        tenkan_high = high.rolling(window=tenkan_period).max()
                      ^~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:201:18: error:
"Series" has no attribute "rolling"  [attr-defined]
        tenkan_low = low.rolling(window=tenkan_period).min()
                     ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:204:18: error:
"Series" has no attribute "rolling"  [attr-defined]
        kijun_high = high.rolling(window=kijun_period).max()
                     ^~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:205:17: error:
"Series" has no attribute "rolling"  [attr-defined]
        kijun_low = low.rolling(window=kijun_period).min()
                    ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:210:26: error:
"Series" has no attribute "rolling"  [attr-defined]
        senkou_span_b_high = high.rolling(window=senkou_span_b_period).max...
                             ^~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:211:25: error:
"Series" has no attribute "rolling"  [attr-defined]
        senkou_span_b_low = low.rolling(window=senkou_span_b_period).min()
                            ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:214:32: error:
"Series" has no attribute "index"  [attr-defined]
        chikou_span = Series(index=high.index)
                                   ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:216:9: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
            chikou_span.iloc[:-kijun_period] = high.iloc[kijun_period:].va...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:216:44: error: Value
of type "Callable[[], Any]" is not indexable  [index]
            chikou_span.iloc[:-kijun_period] = high.iloc[kijun_period:].va...
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:237:17: error:
Unsupported left operand type for - ("Series")  [operator]
        macd_line = ema_fast - ema_slow
                    ^~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:252:11: error:
Unsupported left operand type for - ("Series")  [operator]
        tr1 = high - low
              ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:253:22: error:
"Series" has no attribute "shift"  [attr-defined]
        tr2 = abs(high - close.shift(1))
                         ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:254:21: error:
"Series" has no attribute "shift"  [attr-defined]
        tr3 = abs(low - close.shift(1))
                        ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:255:10: error:
"DataFrame" has no attribute "max"  [attr-defined]
        tr = DataFrame({"tr1": tr1, "tr2": tr2, "tr3": tr3}).max(axis=1)
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:257:22: error:
"Series" has no attribute "shift"  [attr-defined]
        dm_plus = high - high.shift(1)
                         ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:258:16: error:
"Series" has no attribute "shift"  [attr-defined]
        dm_minus = low.shift(1) - low
                   ^~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:282:22: error:
Unsupported left operand type for + ("Series")  [operator]
        typical_price = (high + low + close) / 3
                         ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:299:16: error:
"Series" has no attribute "rolling"  [attr-defined]
            return series.rolling(window=period).apply(
                   ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:304:16: error:
"Series" has no attribute "rolling"  [attr-defined]
            return series.rolling(window=period).apply(
                   ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:310:24: error:
Unsupported left operand type for - ("Series")  [operator]
        aroon_oscillator = aroon_up_line - aroon_down_line
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:319:13: error:
"Series" has no attribute "diff"  [attr-defined]
        delta = prices.diff()
                ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:341:18: error:
"Series" has no attribute "rolling"  [attr-defined]
        lowest_low = low.rolling(window=k_period).min()
                     ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:342:20: error:
"Series" has no attribute "rolling"  [attr-defined]
        highest_high = high.rolling(window=k_period).max()
                       ^~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:356:20: error:
"Series" has no attribute "rolling"  [attr-defined]
        highest_high = high.rolling(window=period).max()
                       ^~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:357:18: error:
"Series" has no attribute "rolling"  [attr-defined]
        lowest_low = low.rolling(window=period).min()
                     ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:366:21: error:
"Series" has no attribute "shift"  [attr-defined]
        return prices - prices.shift(period)
                        ^~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:373:23: error:
"Series" has no attribute "shift"  [attr-defined]
        return ((prices - prices.shift(period)) / prices.shift(period)) * ...
                          ^~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:388:22: error:
Unsupported left operand type for + ("Series")  [operator]
        typical_price = (high + low + close) / 3
                         ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:402:24: error:
"Series" has no attribute "index"  [attr-defined]
        obv = Series(index=close.index, dtype=float)
                           ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:403:5: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
        obv.iloc[0] = volume.iloc[0]
        ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:403:19: error: Value
of type "Callable[[], Any]" is not indexable  [index]
        obv.iloc[0] = volume.iloc[0]
                      ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:405:12: error: Value
of type "Callable[[], Any]" is not indexable  [index]
            if close.iloc[i] > close.iloc[i - 1]:
               ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:406:13: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                obv.iloc[i] = obv.iloc[i - 1] + volume.iloc[i]
                ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:406:27: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                obv.iloc[i] = obv.iloc[i - 1] + volume.iloc[i]
                              ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:407:14: error: Value
of type "Callable[[], Any]" is not indexable  [index]
            elif close.iloc[i] < close.iloc[i - 1]:
                 ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:408:13: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                obv.iloc[i] = obv.iloc[i - 1] - volume.iloc[i]
                ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:408:27: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                obv.iloc[i] = obv.iloc[i - 1] - volume.iloc[i]
                              ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:410:13: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                obv.iloc[i] = obv.iloc[i - 1]
                ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:410:27: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                obv.iloc[i] = obv.iloc[i - 1]
                              ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:437:11: error:
Unsupported left operand type for - ("Series")  [operator]
        tr1 = high - low
              ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:438:22: error:
"Series" has no attribute "shift"  [attr-defined]
        tr2 = abs(high - close.shift(1))
                         ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:439:21: error:
"Series" has no attribute "shift"  [attr-defined]
        tr3 = abs(low - close.shift(1))
                        ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:440:10: error:
"DataFrame" has no attribute "max"  [attr-defined]
        tr = DataFrame({"tr1": tr1, "tr2": tr2, "tr3": tr3}).max(axis=1)
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:441:11: error:
Unsupported left operand type for - ("Series")  [operator]
        bp1 = close - low
              ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:442:19: error:
"Series" has no attribute "shift"  [attr-defined]
        bp2 = close - close.shift(1)
                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:443:10: error:
"DataFrame" has no attribute "min"  [attr-defined]
        bp = DataFrame({"bp1": bp1, "bp2": bp2}).min(axis=1)
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:461:21: error:
Unsupported left operand type for + ("Series")  [operator]
        median_price = (high + low) / 2
                        ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:462:10: error:
Unsupported left operand type for - ("Series")  [operator]
        ao = calc_sma(median_price, period1) - calc_sma(median_price, peri...
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis\indicators.py:480:12: error:
Unsupported left operand type for / ("Series")  [operator]
        return volume / volume_sma
               ^~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:500:28: error: Value
of type "Callable[[], Any]" is not indexable  [index]
            price_level = int((close.iloc[i] - low.min()) / price_step)
                               ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:502:44: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                volume_profile[price_level] += volume.iloc[i]
                                               ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:514:22: error:
Unsupported left operand type for + ("Series")  [operator]
        typical_price = (high + low + close) / 3
                         ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:515:48: error:
"Series" has no attribute "cumsum"  [attr-defined]
        vwap = (typical_price * volume).cumsum() / volume.cumsum()
                                                   ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:527:31: error:
Unsupported left operand type for - ("Series")  [operator]
        money_flow_multiplier = ((close - low) - (high - close)) / (high -...
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:545:31: error:
Unsupported left operand type for - ("Series")  [operator]
        money_flow_multiplier = ((close - low) - (high - close)) / (high -...
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:549:11: error:
"Series" has no attribute "rolling"  [attr-defined]
            / volume.rolling(window=period).sum()
              ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:559:12: error:
Unsupported left operand type for * ("Series")  [operator]
        vpt = (price_change * volume).cumsum()
               ^~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:572:11: error:
Unsupported left operand type for - ("Series")  [operator]
        tr1 = high - low
              ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:573:22: error:
"Series" has no attribute "shift"  [attr-defined]
        tr2 = abs(high - close.shift(1))
                         ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:574:21: error:
"Series" has no attribute "shift"  [attr-defined]
        tr3 = abs(low - close.shift(1))
                        ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:575:10: error:
"DataFrame" has no attribute "max"  [attr-defined]
        tr = DataFrame({"tr1": tr1, "tr2": tr2, "tr3": tr3}).max(axis=1)
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:585:13: error:
Unsupported left operand type for / ("Series")  [operator]
        natr = (atr / close) * 100
                ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:601:22: error:
Unsupported left operand type for + ("Series")  [operator]
        typical_price = (high + low + close) / 3
                         ^~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:603:21: error:
Unsupported operand types for + ("Series" and "float")  [operator]
        upper_channel = calc_ema(typical_price, period) + (multiplier * at...
                        ^
infrastructure\services\technical_analysis\indicators.py:603:69: error:
Unsupported operand types for * ("float" and "Series")  [operator]
    ...  upper_channel = calc_ema(typical_price, period) + (multiplier * atr)
                                                                         ^~~
infrastructure\services\technical_analysis\indicators.py:605:21: error:
Unsupported operand types for - ("Series" and "float")  [operator]
        lower_channel = calc_ema(typical_price, period) - (multiplier * at...
                        ^
infrastructure\services\technical_analysis\indicators.py:605:69: error:
Unsupported operand types for * ("float" and "Series")  [operator]
    ...  lower_channel = calc_ema(typical_price, period) - (multiplier * atr)
                                                                         ^~~
infrastructure\services\technical_analysis\indicators.py:606:12: error:
Incompatible return value type (got "tuple[float, Series, float]", expected
"tuple[Series, Series, Series]")  [return-value]
        return upper_channel, middle_channel, lower_channel
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:615:21: error:
"Series" has no attribute "rolling"  [attr-defined]
        upper_channel = high.rolling(window=period).max()
                        ^~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:616:21: error:
"Series" has no attribute "rolling"  [attr-defined]
        lower_channel = low.rolling(window=period).min()
                        ^~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:625:12: error:
"Series" has no attribute "rolling"  [attr-defined]
        return prices.rolling(window=period).std()
               ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:635:18: error:
"Series" has no attribute "rolling"  [attr-defined]
        volatility = returns.rolling(window=period).std() * np.sqrt(annual...
                     ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:647:19: error:
"Series" has no attribute "rolling"  [attr-defined]
        price_highs = price.rolling(window=lookback_period, center=True).m...
                      ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:648:18: error:
"Series" has no attribute "rolling"  [attr-defined]
        price_lows = price.rolling(window=lookback_period, center=True).mi...
                     ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:649:23: error:
"Series" has no attribute "rolling"  [attr-defined]
        indicator_highs = indicator.rolling(window=lookback_period, center...
                          ^~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:650:22: error:
"Series" has no attribute "rolling"  [attr-defined]
        indicator_lows = indicator.rolling(window=lookback_period, center=...
                         ^~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:653:9: error: Value of
type "Callable[[], Any]" is not indexable  [index]
            price.iloc[-1] < price_lows.iloc[-2]
            ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:654:13: error: Value
of type "Callable[[], Any]" is not indexable  [index]
            and indicator.iloc[-1] > indicator_lows.iloc[-2]
                ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:658:9: error: Value of
type "Callable[[], Any]" is not indexable  [index]
            price.iloc[-1] > price_highs.iloc[-2]
            ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\indicators.py:659:13: error: Value
of type "Callable[[], Any]" is not indexable  [index]
            and indicator.iloc[-1] < indicator_highs.iloc[-2]
                ^~~~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\strategy_execution.py:338:17: error:
"DataFrame" has no attribute "copy"  [attr-defined]
        data_copy = market_data.copy()
                    ^~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\strategy_execution.py:346:33: error:
Item "Timestamp" of "Timestamp | DatetimeIndex | Any" has no attribute "hour" 
[union-attr]
                data_copy["hour"] = pd.to_datetime(data_copy.index).hour
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\strategy_execution.py:346:33: error:
Item "DatetimeIndex" of "Timestamp | DatetimeIndex | Any" has no attribute
"hour"  [union-attr]
                data_copy["hour"] = pd.to_datetime(data_copy.index).hour
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\sentiment_adjustment.py:143:19: error:
Value of type "Callable[[], Any]" is not indexable  [index]
        current_rsi = rsi.iloc[-1]
                      ^~~~~~~~~~~~
infrastructure\services\enhanced_trading\sentiment_adjustment.py:159:13: error:
"Series" has no attribute "ewm"  [attr-defined]
        ema12 = close.ewm(span=12).mean()
                ^~~~~~~~~
infrastructure\services\enhanced_trading\sentiment_adjustment.py:160:13: error:
"Series" has no attribute "ewm"  [attr-defined]
        ema26 = close.ewm(span=26).mean()
                ^~~~~~~~~
infrastructure\services\enhanced_trading\sentiment_adjustment.py:189:13: error:
"Series" has no attribute "rolling"  [attr-defined]
        sma20 = close.rolling(window=20).mean()
                ^~~~~~~~~~~~~
infrastructure\services\enhanced_trading\sentiment_adjustment.py:190:13: error:
"Series" has no attribute "rolling"  [attr-defined]
        sma50 = close.rolling(window=50).mean()
                ^~~~~~~~~~~~~
infrastructure\services\enhanced_trading\sentiment_adjustment.py:193:21: error:
Value of type "Callable[[], Any]" is not indexable  [index]
        current_price = close.iloc[-1]
                        ^~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\sentiment_adjustment.py:660:13: error:
"Series" has no attribute "diff"  [attr-defined]
        delta = prices.diff()
                ^~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:19:16: error: "Series" has
no attribute "ewm"  [attr-defined]
            return data.ewm(span=period).mean()
                   ^~~~~~~~
infrastructure\ml_services\technical_indicators.py:24:16: error: "Series" has
no attribute "rolling"  [attr-defined]
            return data.rolling(window=period).mean()
                   ^~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:29:17: error: "Series" has
no attribute "diff"  [attr-defined]
            delta = data.diff()
                    ^~~~~~~~~
infrastructure\ml_services\technical_indicators.py:41:20: error: "Series" has
no attribute "ewm"  [attr-defined]
            ema_fast = data.ewm(span=fast).mean()
                       ^~~~~~~~
infrastructure\ml_services\technical_indicators.py:42:20: error: "Series" has
no attribute "ewm"  [attr-defined]
            ema_slow = data.ewm(span=slow).mean()
                       ^~~~~~~~
infrastructure\ml_services\technical_indicators.py:53:15: error: "Series" has
no attribute "rolling"  [attr-defined]
            sma = data.rolling(window=period).mean()
                  ^~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:54:15: error: "Series" has
no attribute "rolling"  [attr-defined]
            std = data.rolling(window=period).std()
                  ^~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:64:20: error: Unsupported
left operand type for - ("Series")  [operator]
            high_low = high - low
                       ^~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:65:33: error: "Series" has
no attribute "shift"  [attr-defined]
            high_close = abs(high - close.shift())
                                    ^~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:66:31: error: "Series" has
no attribute "shift"  [attr-defined]
            low_close = abs(low - close.shift())
                                  ^~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:67:22: error: "DataFrame"
has no attribute "max"  [attr-defined]
            true_range = DataFrame({"hl": high_low, "hc": high_close, "lc"...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\ml_services\technical_indicators.py:80:22: error: "Series" has
no attribute "rolling"  [attr-defined]
            lowest_low = low.rolling(window=k_period).min()
                         ^~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:81:24: error: "Series" has
no attribute "rolling"  [attr-defined]
            highest_high = high.rolling(window=k_period).max()
                           ^~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:91:24: error: "Series" has
no attribute "rolling"  [attr-defined]
            highest_high = high.rolling(window=period).max()
                           ^~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:92:22: error: "Series" has
no attribute "rolling"  [attr-defined]
            lowest_low = low.rolling(window=period).min()
                         ^~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:101:26: error: Unsupported
left operand type for + ("Series")  [operator]
            typical_price = (high + low + close) / 3
                             ^~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:115:15: error: Unsupported
left operand type for - ("Series")  [operator]
            tr1 = high - low
                  ^~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:116:26: error: "Series" has
no attribute "shift"  [attr-defined]
            tr2 = abs(high - close.shift())
                             ^~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:117:25: error: "Series" has
no attribute "shift"  [attr-defined]
            tr3 = abs(low - close.shift())
                            ^~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:118:14: error: "DataFrame"
has no attribute "max"  [attr-defined]
            tr = DataFrame({"tr1": tr1, "tr2": tr2, "tr3": tr3}).max(axis=...
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:120:26: error: "Series" has
no attribute "shift"  [attr-defined]
            up_move = high - high.shift()
                             ^~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:121:21: error: "Series" has
no attribute "shift"  [attr-defined]
            down_move = low.shift() - low
                        ^~~~~~~~~
infrastructure\ml_services\technical_indicators.py:124:19: error: Incompatible
types in assignment (expression has type "Series", variable has type
"ndarray[Any, dtype[Any]]")  [assignment]
            plus_dm = Series(plus_dm, index=high.index)
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:124:41: error: "Series" has
no attribute "index"  [attr-defined]
            plus_dm = Series(plus_dm, index=high.index)
                                            ^~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:125:20: error: Incompatible
types in assignment (expression has type "Series", variable has type
"ndarray[Any, dtype[Any]]")  [assignment]
            minus_dm = Series(minus_dm, index=high.index)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:125:43: error: "Series" has
no attribute "index"  [attr-defined]
            minus_dm = Series(minus_dm, index=high.index)
                                              ^~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:128:26: error:
"ndarray[Any, dtype[Any]]" has no attribute "rolling"  [attr-defined]
            plus_dm_smooth = plus_dm.rolling(window=period).mean()
                             ^~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:129:27: error:
"ndarray[Any, dtype[Any]]" has no attribute "rolling"  [attr-defined]
            minus_dm_smooth = minus_dm.rolling(window=period).mean()
                              ^~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:150:35: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            indicators["rsi"] = float(rsi.iloc[-1]) if not np.isnan(rsi.il...
                                      ^~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:154:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(macd_data["macd"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:155:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(macd_data["macd"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:159:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(macd_data["signal"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:160:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(macd_data["signal"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:164:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(macd_data["histogram"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:165:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(macd_data["histogram"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:171:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(bb_data["upper"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:172:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(bb_data["upper"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:176:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(bb_data["middle"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:177:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(bb_data["middle"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:181:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(bb_data["lower"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:182:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(bb_data["lower"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:187:35: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            indicators["atr"] = float(atr.iloc[-1]) if not np.isnan(atr.il...
                                      ^~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:191:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(stoch_data["k"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:192:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(stoch_data["k"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:196:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(stoch_data["d"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:197:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(stoch_data["d"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:203:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(williams_r.iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:204:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(williams_r.iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:209:35: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            indicators["cci"] = float(cci.iloc[-1]) if not np.isnan(cci.il...
                                      ^~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:213:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(adx_data["adx"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:214:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(adx_data["adx"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:218:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(adx_data["plus_di"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:219:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(adx_data["plus_di"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:223:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(adx_data["minus_di"].iloc[-1])
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\technical_indicators.py:224:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                if not np.isnan(adx_data["minus_di"].iloc[-1])
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\regime_discovery.py:448:26: error: Argument "type"
to "Event" has incompatible type "domain.types.infrastructure_types.EventType";
expected "domain.types.messaging_types.EventType"  [arg-type]
                        type=EventType.SYSTEM_HEALTH_CHECK,
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\ml_models.py:83:20: error: Incompatible return value
type (got "dict[str, dict[str, float]]", expected "dict[str, float]") 
[return-value]
                return self._get_best_model_metrics()
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\ml_models.py:292:31: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                        best_f1 = metrics["f1"]
                                  ^~~~~~~~~~~~~
infrastructure\ml_services\meta_learning.py:368:27: error: Argument 1 to
"float" has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                        float(p["performance"]) for p in performances if p...
                              ^~~~~~~~~~~~~~~~
infrastructure\ml_services\meta_learning.py:371:27: error: Argument 1 to
"float" has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                        float(p["performance"]) for p in performances if p...
                              ^~~~~~~~~~~~~~~~
infrastructure\ml_services\market_regime_detector.py:31:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            features['volatility'] = data['close'].pct_change().rolling(wi...
            ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\market_regime_detector.py:34:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            features['trend'] = data['close'].rolling(window=20).mean().pc...
            ^~~~~~~~~~~~~~~~~
infrastructure\ml_services\market_regime_detector.py:38:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features['volume_ratio'] = data['volume'].rolling(window=2...
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\market_regime_detector.py:40:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features['volume_ratio'] = 1.0
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\market_regime_detector.py:43:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            features['momentum'] = data['close'].pct_change(periods=5)
            ^~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\market_regime_detector.py:47:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features['range'] = (data['high'] - data['low']) / data['c...
                ^~~~~~~~~~~~~~~~~
infrastructure\ml_services\market_regime_detector.py:49:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features['range'] = data['close'].rolling(window=5).max() ...
                ^~~~~~~~~~~~~~~~~
infrastructure\ml_services\market_regime_detector.py:51:16: error: "DataFrame"
has no attribute "dropna"  [attr-defined]
            return features.dropna()
                   ^~~~~~~~~~~~~~~
infrastructure\ml_services\market_regime_detector.py:90:35: error: "DataFrame"
has no attribute "iloc"  [attr-defined]
                    regime_features = features.iloc[regime_mask]
                                      ^~~~~~~~~~~~~
infrastructure\ml_services\candle_patterns.py:47:23: error: "DataFrame" has no
attribute "tail"  [attr-defined]
            recent_data = data.tail(20)  # јнализируем последние 20 свечей
                          ^~~~~~~~~
infrastructure\ml_services\candle_patterns.py:71:23: error: "DataFrame" has no
attribute "tail"  [attr-defined]
            recent_data = data.tail(20)
                          ^~~~~~~~~
infrastructure\ml_services\candle_patterns.py:97:23: error: "DataFrame" has no
attribute "tail"  [attr-defined]
            recent_data = data.tail(20)
                          ^~~~~~~~~
infrastructure\ml_services\candle_patterns.py:123:23: error: "DataFrame" has no
attribute "tail"  [attr-defined]
            recent_data = data.tail(20)
                          ^~~~~~~~~
infrastructure\ml_services\candle_patterns.py:168:23: error: "DataFrame" has no
attribute "tail"  [attr-defined]
            recent_data = data.tail(20)
                          ^~~~~~~~~
infrastructure\ml_services\candle_patterns.py:196:23: error: "DataFrame" has no
attribute "tail"  [attr-defined]
            recent_data = data.tail(20)
                          ^~~~~~~~~
infrastructure\ml_services\candle_patterns.py:224:23: error: "DataFrame" has no
attribute "tail"  [attr-defined]
            recent_data = data.tail(20)
                          ^~~~~~~~~
infrastructure\ml_services\candle_patterns.py:253:23: error: "DataFrame" has no
attribute "tail"  [attr-defined]
            recent_data = data.tail(20)
                          ^~~~~~~~~
infrastructure\market_profiles\analysis\pattern_analyzer.py:164:31: error:
Argument 1 to "Confidence" has incompatible type
"SupportsDunderLT[Any] | SupportsDunderGT[Any]"; expected "float"  [arg-type]
                return Confidence(final_confidence)
                                  ^~~~~~~~~~~~~~~~
infrastructure\market_profiles\analysis\pattern_analyzer.py:231:25: error:
Argument 1 to "_calculate_context_similarity" of "PatternAnalyzer" has
incompatible type "PatternContext"; expected "dict[str, Any]"  [arg-type]
                            current_context, hist_pattern.pattern.context
                            ^~~~~~~~~~~~~~~
infrastructure\market_profiles\analysis\pattern_analyzer.py:231:42: error:
Argument 2 to "_calculate_context_similarity" of "PatternAnalyzer" has
incompatible type "PatternContext"; expected "dict[str, Any]"  [arg-type]
                            current_context, hist_pattern.pattern.context
                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\market_profiles\analysis\pattern_analyzer.py:295:65: error:
Argument 1 to "_calculate_weighted_outcome" of "PatternAnalyzer" has
incompatible type "list[PatternResultProtocol]"; expected "list[PatternResult]" 
[arg-type]
    ...weighted_outcome = self._calculate_weighted_outcome(outcomes, weights)
                                                           ^~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:29:20: error:
"DataFrame" has no attribute "copy"  [attr-defined]
            features = data.copy()
                       ^~~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:90:17: error: "Series"
has no attribute "diff"  [attr-defined]
            delta = prices.diff()
                    ^~~~~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:99:20: error: "Series"
has no attribute "ewm"  [attr-defined]
            ema_fast = prices.ewm(span=fast).mean()
                       ^~~~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:100:20: error: "Series"
has no attribute "ewm"  [attr-defined]
            ema_slow = prices.ewm(span=slow).mean()
                       ^~~~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:107:15: error: "Series"
has no attribute "rolling"  [attr-defined]
            sma = prices.rolling(window=period).mean()
                  ^~~~~~~~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:108:15: error: "Series"
has no attribute "rolling"  [attr-defined]
            std = prices.rolling(window=period).std()
                  ^~~~~~~~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:119:27: error:
"DataFrame" has no attribute "select_dtypes"  [attr-defined]
            numeric_columns = features.select_dtypes(include=[np.number])....
                              ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:124:27: error:
"DataFrame" has no attribute "copy"  [attr-defined]
            scaled_features = features.copy()
                              ^~~~~~~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:136:27: error:
"DataFrame" has no attribute "select_dtypes"  [attr-defined]
            numeric_columns = features.select_dtypes(include=[np.number])....
                              ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:157:28: error:
"DataFrame" has no attribute "corrwith"  [attr-defined]
                correlations = features.corrwith(target).abs()
                               ^~~~~~~~~~~~~~~~~
infrastructure\external_services\ml\feature_engineer.py:163:25: error:
"DataFrame" has no attribute "var"  [attr-defined]
                variances = features.var()
                            ^~~~~~~~~~~~
infrastructure\data\symbol_metrics_provider.py:208:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                df['timestamp'] = pd.to_datetime(df['timestamp'])
                ^~~~~~~~~~~~~~~
infrastructure\data\symbol_metrics_provider.py:209:13: error: "DataFrame" has
no attribute "set_index"  [attr-defined]
                df.set_index('timestamp', inplace=True)
                ^~~~~~~~~~~~
infrastructure\data\symbol_metrics_provider.py:258:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                df['timestamp'] = pd.to_datetime(df['timestamp'])
                ^~~~~~~~~~~~~~~
infrastructure\data\symbol_metrics_provider.py:259:13: error: "DataFrame" has
no attribute "set_index"  [attr-defined]
                df.set_index('timestamp', inplace=True)
                ^~~~~~~~~~~~
infrastructure\data\symbol_metrics_provider.py:266:22: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                latest = df.iloc[-1]
                         ^~~~~~~
infrastructure\data\symbol_metrics_provider.py:329:31: error:
"OrderBookSnapshot" has no attribute "to_dict"  [attr-defined]
                    'order_book': order_book.to_dict() if isinstance(order...
                                  ^~~~~~~~~~~~~~~~~~
infrastructure\data\symbol_metrics_provider.py:357:18: error: Module has no
attribute "concat"  [attr-defined]
                tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
                     ^~~~~~~~~
infrastructure\data\symbol_metrics_provider.py:397:22: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                latest = df.iloc[-1]
                         ^~~~~~~
infrastructure\data\symbol_metrics_provider.py:450:52: error: Module has no
attribute "isna"  [attr-defined]
    ...          anomaly = abs(z_score.iloc[-1]) if not pd.isna(z_score.iloc[...
                                                        ^~~~~~~
infrastructure\core\visualization.py:110:30: error: "int" has no attribute
"cumprod"  [attr-defined]
            cumulative_returns = (1 + rets).cumprod()
                                 ^~~~~~~~~~~~~~~~~~
infrastructure\core\visualization.py:110:35: error: Unsupported operand types
for + ("int" and "Series")  [operator]
            cumulative_returns = (1 + rets).cumprod()
                                      ^~~~
infrastructure\core\visualization.py:138:18: error: "Series" has no attribute
"rolling"  [attr-defined]
        volatility = returns.rolling(window).std() * np.sqrt(252)
                     ^~~~~~~~~~~~~~~
infrastructure\core\visualization.py:139:26: error: "int" has no attribute
"cumprod"  [attr-defined]
        cumulative_returns = (1 + returns).cumprod()
                             ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\visualization.py:139:31: error: Unsupported operand types
for + ("int" and "Series")  [operator]
        cumulative_returns = (1 + returns).cumprod()
                                  ^~~~~~~
infrastructure\core\visualization.py:215:32: error: "int" has no attribute
"cumprod"  [attr-defined]
            cumulative_benchmark = (1 + benchmark).cumprod()
                                   ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\visualization.py:215:37: error: Unsupported operand types
for + ("int" and "Series")  [operator]
            cumulative_benchmark = (1 + benchmark).cumprod()
                                        ^~~~~~~~~
infrastructure\core\visualization.py:226:30: error: "int" has no attribute
"cumprod"  [attr-defined]
            cumulative_returns = (1 + rets).cumprod()
                                 ^~~~~~~~~~~~~~~~~~
infrastructure\core\visualization.py:226:35: error: Unsupported operand types
for + ("int" and "Series")  [operator]
            cumulative_returns = (1 + rets).cumprod()
                                      ^~~~
infrastructure\core\visualization.py:389:15: error: "Series" has no attribute
"index"  [attr-defined]
                x=cvd.index,
                  ^~~~~~~~~
infrastructure\core\visualization.py:398:52: error: "Series" has no attribute
"__iter__" (not iterable)  [attr-defined]
        colors = ["red" if x < 0 else "green" for x in delta]
                                                       ^~~~~
infrastructure\core\visualization.py:401:15: error: "Series" has no attribute
"index"  [attr-defined]
                x=delta.index,
                  ^~~~~~~~~~~
infrastructure\core\visualization.py:434:15: error: "Series" has no attribute
"index"  [attr-defined]
                x=equity.index,
                  ^~~~~~~~~~~~
infrastructure\core\visualization.py:563:19: error: "Series" has no attribute
"index"  [attr-defined]
                    x=values.index,
                      ^~~~~~~~~~~~
infrastructure\core\technical_analysis.py:22:12: error: "Series" has no
attribute "ewm"  [attr-defined]
        return pd.Series(data).ewm(span=period, adjust=False).mean()
               ^~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:27:12: error: "Series" has no
attribute "rolling"  [attr-defined]
        return pd.Series(data).rolling(window=period).mean()
               ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:34:9: error: "Series" has no
attribute "rolling"  [attr-defined]
            pd.Series(data)
            ^
infrastructure\core\technical_analysis.py:50:24: error: "Series" has no
attribute "rolling"  [attr-defined]
        stoch = (rsi_val - rsi_val.rolling(period).min()) / (
                           ^~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:51:9: error: "Series" has no
attribute "rolling"  [attr-defined]
            rsi_val.rolling(period).max() - rsi_val.rolling(period).min()
            ^~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:77:13: error: Unsupported operand
types for + ("Series" and "float")  [operator]
        upper = middle + (atr_val * multiplier)
                ^
infrastructure\core\technical_analysis.py:77:23: error: Unsupported operand
types for * ("Series" and "float")  [operator]
        upper = middle + (atr_val * multiplier)
                          ^
infrastructure\core\technical_analysis.py:78:13: error: Unsupported operand
types for - ("Series" and "float")  [operator]
        lower = middle - (atr_val * multiplier)
                ^
infrastructure\core\technical_analysis.py:78:23: error: Unsupported operand
types for * ("Series" and "float")  [operator]
        lower = middle - (atr_val * multiplier)
                          ^
infrastructure\core\technical_analysis.py:79:12: error: Incompatible return
value type (got "tuple[float, Series, float]", expected
"tuple[Series, Series, Series]")  [return-value]
        return upper, middle, lower
               ^~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:109:11: error: Unsupported left
operand type for - ("Series")  [operator]
        tr1 = high_series - low_series
              ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:110:29: error: "Series" has no
attribute "shift"  [attr-defined]
        tr2 = abs(high_series - close_series.shift(1))
                                ^~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:111:28: error: "Series" has no
attribute "shift"  [attr-defined]
        tr3 = abs(low_series - close_series.shift(1))
                               ^~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:112:10: error: Module has no
attribute "concat"  [attr-defined]
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
             ^~~~~~~~~
infrastructure\core\technical_analysis.py:114:29: error: "Series" has no
attribute "shift"  [attr-defined]
        up_move = high_series - high_series.shift(1)
                                ^~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:115:17: error: "Series" has no
attribute "shift"  [attr-defined]
        down_move = low_series.shift(1) - low_series
                    ^~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:118:21: error: "Series" has no
attribute "rolling"  [attr-defined]
        plus_di = 100 * pd.Series(plus_dm).rolling(period).mean() / atr_va...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:119:22: error: "Series" has no
attribute "rolling"  [attr-defined]
        minus_di = 100 * pd.Series(minus_dm).rolling(period).mean() / atr_...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:129:11: error: Unsupported left
operand type for + ("Series")  [operator]
        tp = (pd.Series(high) + pd.Series(low) + pd.Series(close)) / 3
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:131:13: error: "Series" has no
attribute "rolling"  [attr-defined]
        tp_md = pd.Series(tp).rolling(period).apply(lambda x: np.abs(x - x...
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:146:22: error: Unsupported left
operand type for + ("Series")  [operator]
        typical_price = (pd.Series(high) + pd.Series(low) + pd.Series(clos...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:148:55: error: "Series" has no
attribute "cumsum"  [attr-defined]
    ...eturn (typical_price * volume_series).cumsum() / volume_series.cumsum(...
                                                        ^~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:157:46: error: "Series" has no
attribute "index"  [attr-defined]
        bullish_fractal = pd.Series(False, index=high_series.index)
                                                 ^~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:158:46: error: "Series" has no
attribute "index"  [attr-defined]
        bearish_fractal = pd.Series(False, index=low_series.index)
                                                 ^~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:164:13: error: Unsupported target for
indexed assignment ("Callable[[], Any]")  [index]
                bullish_fractal.iloc[i] = True
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:169:13: error: Unsupported target for
indexed assignment ("Callable[[], Any]")  [index]
                bearish_fractal.iloc[i] = True
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:175:12: error: Unsupported left
operand type for - ("Series")  [operator]
        return pd.Series(buy_volume) - pd.Series(sell_volume)
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:180:20: error: Unsupported left
operand type for + ("Series")  [operator]
        total_volume = pd.Series(bid_volume) + pd.Series(ask_volume)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:181:13: error: Unsupported left
operand type for - ("Series")  [operator]
        return (pd.Series(bid_volume) - pd.Series(ask_volume)) / total_vol...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:401:53: error: "Series" has no
attribute "index"  [attr-defined]
            empty_series = pd.Series(dtype=float, index=data.index)
                                                        ^~~~~~~~~~
infrastructure\core\technical_analysis.py:430:15: error: "Series" has no
attribute "rolling"  [attr-defined]
        support = low.rolling(period).min().iloc[-1]
                  ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:431:18: error: "Series" has no
attribute "rolling"  [attr-defined]
        resistance = high.rolling(period).max().iloc[-1]
                     ^~~~~~~~~~~~
infrastructure\core\technical_analysis.py:442:33: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            bin_index = np.digitize(price.iloc[i], price_bins) - 1
                                    ^~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:444:42: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                volume_profile[bin_index] += volume.iloc[i]
                                             ^~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:450:19: error: "Series" has no
attribute "shift"  [attr-defined]
        return data - data.shift(period)
                      ^~~~~~~~~~
infrastructure\core\technical_analysis.py:455:12: error: "Series" has no
attribute "rolling"  [attr-defined]
        return data.rolling(period).std()
               ^~~~~~~~~~~~
infrastructure\core\technical_analysis.py:463:17: error: "Series" has no
attribute "rolling"  [attr-defined]
        volume_ma = volume.rolling(window).mean()
                    ^~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:487:26: error: Value of type
"Callable[[], Any]" is not indexable  [index]
        trend = "bullish" if ema_short.iloc[-1] > ema_long.iloc[-1] else "...
                             ^~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:489:20: error: "Series" has no
attribute "tail"  [attr-defined]
        recent_highs = high.tail(window)
                       ^~~~~~~~~
infrastructure\core\technical_analysis.py:490:19: error: "Series" has no
attribute "tail"  [attr-defined]
        recent_lows = low.tail(window)
                      ^~~~~~~~
infrastructure\core\technical_analysis.py:503:28: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            "ema_short": float(ema_short.iloc[-1]),
                               ^~~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:504:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            "ema_long": float(ema_long.iloc[-1]),
                              ^~~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:596:12: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        high = pd.Series(high)
               ^~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:597:11: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        low = pd.Series(low)
              ^~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:598:13: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        close = pd.Series(close)
                ^~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:600:19: error: "ndarray[Any, Any]"
has no attribute "rolling"  [attr-defined]
        tenkan_high = high.rolling(tenkan_period).max()
                      ^~~~~~~~~~~~
infrastructure\core\technical_analysis.py:601:18: error: "ndarray[Any, Any]"
has no attribute "rolling"  [attr-defined]
        tenkan_low = low.rolling(tenkan_period).min()
                     ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:604:18: error: "ndarray[Any, Any]"
has no attribute "rolling"  [attr-defined]
        kijun_high = high.rolling(kijun_period).max()
                     ^~~~~~~~~~~~
infrastructure\core\technical_analysis.py:605:17: error: "ndarray[Any, Any]"
has no attribute "rolling"  [attr-defined]
        kijun_low = low.rolling(kijun_period).min()
                    ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:610:26: error: "ndarray[Any, Any]"
has no attribute "rolling"  [attr-defined]
        senkou_span_b_high = high.rolling(senkou_span_b_period).max()
                             ^~~~~~~~~~~~
infrastructure\core\technical_analysis.py:611:25: error: "ndarray[Any, Any]"
has no attribute "rolling"  [attr-defined]
        senkou_span_b_low = low.rolling(senkou_span_b_period).min()
                            ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:614:19: error: "ndarray[Any, Any]"
has no attribute "shift"  [attr-defined]
        chikou_span = close.shift(-displacement)
                      ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:642:12: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        high = pd.Series(high)
               ^~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:643:11: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        low = pd.Series(low)
              ^~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:644:13: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        close = pd.Series(close)
                ^~~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:646:20: error: "ndarray[Any, Any]"
has no attribute "rolling"  [attr-defined]
        highest_high = high.rolling(k_period).max()
                       ^~~~~~~~~~~~
infrastructure\core\technical_analysis.py:647:18: error: "ndarray[Any, Any]"
has no attribute "rolling"  [attr-defined]
        lowest_low = low.rolling(k_period).min()
                     ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:664:27: error: "Series" has no
attribute "index"  [attr-defined]
        obv = pd.Series(index=close.index, dtype=float)
                              ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:665:5: error: Unsupported target for
indexed assignment ("Callable[[], Any]")  [index]
        obv.iloc[0] = volume.iloc[0]
        ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:665:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
        obv.iloc[0] = volume.iloc[0]
                      ^~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:667:12: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            if close.iloc[i] > close.iloc[i - 1]:
               ^~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:668:13: error: Unsupported target for
indexed assignment ("Callable[[], Any]")  [index]
                obv.iloc[i] = obv.iloc[i - 1] + volume.iloc[i]
                ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:668:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                obv.iloc[i] = obv.iloc[i - 1] + volume.iloc[i]
                              ^~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:669:14: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            elif close.iloc[i] < close.iloc[i - 1]:
                 ^~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:670:13: error: Unsupported target for
indexed assignment ("Callable[[], Any]")  [index]
                obv.iloc[i] = obv.iloc[i - 1] - volume.iloc[i]
                ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:670:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                obv.iloc[i] = obv.iloc[i - 1] - volume.iloc[i]
                              ^~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:672:13: error: Unsupported target for
indexed assignment ("Callable[[], Any]")  [index]
                obv.iloc[i] = obv.iloc[i - 1]
                ^~~~~~~~~~~
infrastructure\core\technical_analysis.py:672:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                obv.iloc[i] = obv.iloc[i - 1]
                              ^~~~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:689:22: error: Unsupported left
operand type for + ("Series")  [operator]
        typical_price = (high + low + close) / 3
                         ^~~~~~~~~~
infrastructure\core\technical_analysis.py:690:48: error: "Series" has no
attribute "cumsum"  [attr-defined]
        return (typical_price * volume).cumsum() / volume.cumsum()
                                                   ^~~~~~~~~~~~~
infrastructure\core\technical_analysis.py:712:16: error: "Series" has no
attribute "diff"  [attr-defined]
            return data.diff(period)
                   ^~~~~~~~~
infrastructure\core\technical_analysis.py:714:45: error: "Series" has no
attribute "index"  [attr-defined]
            return pd.Series(dtype=float, index=data.index)
                                                ^~~~~~~~~~
infrastructure\core\technical.py:19:12: error: "Series" has no attribute "ewm" 
[attr-defined]
        return pd.Series(data).ewm(span=period, adjust=False).mean()
               ^~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:24:12: error: "Series" has no attribute
"rolling"  [attr-defined]
        return pd.Series(data).rolling(window=period).mean()
               ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:31:9: error: "Series" has no attribute
"rolling"  [attr-defined]
            pd.Series(data)
            ^
infrastructure\core\technical.py:47:24: error: "Series" has no attribute
"rolling"  [attr-defined]
        stoch = (rsi_val - rsi_val.rolling(period).min()) / (
                           ^~~~~~~~~~~~~~~
infrastructure\core\technical.py:48:9: error: "Series" has no attribute
"rolling"  [attr-defined]
            rsi_val.rolling(period).max() - rsi_val.rolling(period).min()
            ^~~~~~~~~~~~~~~
infrastructure\core\technical.py:74:13: error: Unsupported operand types for +
("Series" and "float")  [operator]
        upper = middle + (atr_val * multiplier)
                ^
infrastructure\core\technical.py:74:23: error: Unsupported operand types for *
("Series" and "float")  [operator]
        upper = middle + (atr_val * multiplier)
                          ^
infrastructure\core\technical.py:75:13: error: Unsupported operand types for -
("Series" and "float")  [operator]
        lower = middle - (atr_val * multiplier)
                ^
infrastructure\core\technical.py:75:23: error: Unsupported operand types for *
("Series" and "float")  [operator]
        lower = middle - (atr_val * multiplier)
                          ^
infrastructure\core\technical.py:76:12: error: Incompatible return value type
(got "tuple[float, Series, float]", expected "tuple[Series, Series, Series]") 
[return-value]
        return upper, middle, lower
               ^~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:106:11: error: Unsupported left operand type
for - ("Series")  [operator]
        tr1 = high_series - low_series
              ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:107:29: error: "Series" has no attribute
"shift"  [attr-defined]
        tr2 = abs(high_series - close_series.shift(1))
                                ^~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:108:28: error: "Series" has no attribute
"shift"  [attr-defined]
        tr3 = abs(low_series - close_series.shift(1))
                               ^~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:109:10: error: Module has no attribute
"concat"  [attr-defined]
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
             ^~~~~~~~~
infrastructure\core\technical.py:111:29: error: "Series" has no attribute
"shift"  [attr-defined]
        up_move = high_series - high_series.shift(1)
                                ^~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:112:17: error: "Series" has no attribute
"shift"  [attr-defined]
        down_move = low_series.shift(1) - low_series
                    ^~~~~~~~~~~~~~~~
infrastructure\core\technical.py:115:21: error: "Series" has no attribute
"rolling"  [attr-defined]
        plus_di = 100 * pd.Series(plus_dm).rolling(period).mean() / atr_va...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:116:22: error: "Series" has no attribute
"rolling"  [attr-defined]
        minus_di = 100 * pd.Series(minus_dm).rolling(period).mean() / atr_...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:126:11: error: Unsupported left operand type
for + ("Series")  [operator]
        tp = (pd.Series(high) + pd.Series(low) + pd.Series(close)) / 3
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:128:13: error: "Series" has no attribute
"rolling"  [attr-defined]
        tp_md = pd.Series(tp).rolling(period).apply(lambda x: np.abs(x - x...
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:143:22: error: Unsupported left operand type
for + ("Series")  [operator]
        typical_price = (pd.Series(high) + pd.Series(low) + pd.Series(clos...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:145:55: error: "Series" has no attribute
"cumsum"  [attr-defined]
    ...eturn (typical_price * volume_series).cumsum() / volume_series.cumsum(...
                                                        ^~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:154:46: error: "Series" has no attribute
"index"  [attr-defined]
        bullish_fractal = pd.Series(False, index=high_series.index)
                                                 ^~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:155:46: error: "Series" has no attribute
"index"  [attr-defined]
        bearish_fractal = pd.Series(False, index=low_series.index)
                                                 ^~~~~~~~~~~~~~~~
infrastructure\core\technical.py:161:13: error: Unsupported target for indexed
assignment ("Callable[[], Any]")  [index]
                bullish_fractal.iloc[i] = True
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:166:13: error: Unsupported target for indexed
assignment ("Callable[[], Any]")  [index]
                bearish_fractal.iloc[i] = True
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:172:12: error: Unsupported left operand type
for - ("Series")  [operator]
        return pd.Series(buy_volume) - pd.Series(sell_volume)
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:177:20: error: Unsupported left operand type
for + ("Series")  [operator]
        total_volume = pd.Series(bid_volume) + pd.Series(ask_volume)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:178:13: error: Unsupported left operand type
for - ("Series")  [operator]
        return (pd.Series(bid_volume) - pd.Series(ask_volume)) / total_vol...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:388:12: error: "Series" has no attribute "ewm"
 [attr-defined]
        return data.ewm(span=period, adjust=False).mean()
               ^~~~~~~~
infrastructure\core\technical.py:426:46: error: "Series" has no attribute
"index"  [attr-defined]
        bullish_fractal = pd.Series(False, index=high.index)
                                                 ^~~~~~~~~~
infrastructure\core\technical.py:427:46: error: "Series" has no attribute
"index"  [attr-defined]
        bearish_fractal = pd.Series(False, index=low.index)
                                                 ^~~~~~~~~
infrastructure\core\technical.py:430:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            if all(low.iloc[i] < low.iloc[i - j] for j in range(1, period ...
                   ^~~~~~~~~~~
infrastructure\core\technical.py:431:13: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                low.iloc[i] < low.iloc[i + j] for j in range(1, period + 1...
                ^~~~~~~~~~~
infrastructure\core\technical.py:433:13: error: Unsupported target for indexed
assignment ("Callable[[], Any]")  [index]
                bullish_fractal.iloc[i] = True
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:435:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            if all(high.iloc[i] > high.iloc[i - j] for j in range(1, perio...
                   ^~~~~~~~~~~~
infrastructure\core\technical.py:436:13: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                high.iloc[i] > high.iloc[i + j] for j in range(1, period +...
                ^~~~~~~~~~~~
infrastructure\core\technical.py:438:13: error: Unsupported target for indexed
assignment ("Callable[[], Any]")  [index]
                bearish_fractal.iloc[i] = True
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:446:15: error: "Series" has no attribute
"rolling"  [attr-defined]
        support = low.rolling(window=period).min().iloc[-1]
                  ^~~~~~~~~~~
infrastructure\core\technical.py:447:18: error: "Series" has no attribute
"rolling"  [attr-defined]
        resistance = high.rolling(window=period).max().iloc[-1]
                     ^~~~~~~~~~~~
infrastructure\core\technical.py:455:36: error: Argument 1 to "histogram" has
incompatible type "Series"; expected
"_SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes]"
 [arg-type]
        hist, bin_edges = np.histogram(price, bins=bins, weights=volume)
                                       ^~~~~
infrastructure\core\technical.py:455:62: error: Argument "weights" to
"histogram" has incompatible type "Series"; expected
"_SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] | None"
 [arg-type]
        hist, bin_edges = np.histogram(price, bins=bins, weights=volume)
                                                                 ^~~~~~
infrastructure\core\technical.py:461:12: error: "Series" has no attribute
"diff"  [attr-defined]
        return data.diff(period)
               ^~~~~~~~~
infrastructure\core\technical.py:466:12: error: "Series" has no attribute
"rolling"  [attr-defined]
        return data.pct_change().rolling(window=period).std()
               ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:473:17: error: "Series" has no attribute
"rolling"  [attr-defined]
        volume_ma = volume.rolling(window=window).mean()
                    ^~~~~~~~~~~~~~
infrastructure\core\technical.py:494:17: error: "Series" has no attribute
"rolling"  [attr-defined]
        sma_short = close.rolling(window=window // 2).mean()
                    ^~~~~~~~~~~~~
infrastructure\core\technical.py:495:16: error: "Series" has no attribute
"rolling"  [attr-defined]
        sma_long = close.rolling(window=window).mean()
                   ^~~~~~~~~~~~~
infrastructure\core\technical.py:498:18: error: Value of type
"Callable[[], Any]" is not indexable  [index]
        volatility = calculate_volatility(close, window).iloc[-1]
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:500:15: error: Value of type
"Callable[[], Any]" is not indexable  [index]
        adx_val = adx(high, low, close, window).iloc[-1]
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\technical.py:564:12: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        high = pd.Series(high)
               ^~~~~~~~~~~~~~~
infrastructure\core\technical.py:565:11: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        low = pd.Series(low)
              ^~~~~~~~~~~~~~
infrastructure\core\technical.py:566:13: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        close = pd.Series(close)
                ^~~~~~~~~~~~~~~~
infrastructure\core\technical.py:568:15: error: "ndarray[Any, Any]" has no
attribute "rolling"  [attr-defined]
        tenkan = (high.rolling(tenkan_period).max() + low.rolling(tenkan_p...
                  ^~~~~~~~~~~~
infrastructure\core\technical.py:570:14: error: "ndarray[Any, Any]" has no
attribute "rolling"  [attr-defined]
        kijun = (high.rolling(kijun_period).max() + low.rolling(kijun_peri...
                 ^~~~~~~~~~~~
infrastructure\core\technical.py:576:13: error: "ndarray[Any, Any]" has no
attribute "rolling"  [attr-defined]
                high.rolling(senkou_span_b_period).max()
                ^~~~~~~~~~~~
infrastructure\core\technical.py:577:15: error: "ndarray[Any, Any]" has no
attribute "rolling"  [attr-defined]
                + low.rolling(senkou_span_b_period).min()
                  ^~~~~~~~~~~
infrastructure\core\technical.py:582:19: error: "ndarray[Any, Any]" has no
attribute "shift"  [attr-defined]
        chikou_span = close.shift(-displacement)
                      ^~~~~~~~~~~
infrastructure\core\technical.py:600:12: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        high = pd.Series(high)
               ^~~~~~~~~~~~~~~
infrastructure\core\technical.py:601:11: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        low = pd.Series(low)
              ^~~~~~~~~~~~~~
infrastructure\core\technical.py:602:13: error: Incompatible types in
assignment (expression has type "Series", variable has type "ndarray[Any, Any]")
 [assignment]
        close = pd.Series(close)
                ^~~~~~~~~~~~~~~~
infrastructure\core\technical.py:604:18: error: "ndarray[Any, Any]" has no
attribute "rolling"  [attr-defined]
        lowest_low = low.rolling(k_period).min()
                     ^~~~~~~~~~~
infrastructure\core\technical.py:605:20: error: "ndarray[Any, Any]" has no
attribute "rolling"  [attr-defined]
        highest_high = high.rolling(k_period).max()
                       ^~~~~~~~~~~~
infrastructure\core\technical.py:614:27: error: "Series" has no attribute
"index"  [attr-defined]
        obv = pd.Series(index=close.index, dtype=float)
                              ^~~~~~~~~~~
infrastructure\core\technical.py:615:5: error: Unsupported target for indexed
assignment ("Callable[[], Any]")  [index]
        obv.iloc[0] = volume.iloc[0]
        ^~~~~~~~~~~
infrastructure\core\technical.py:615:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
        obv.iloc[0] = volume.iloc[0]
                      ^~~~~~~~~~~~~~
infrastructure\core\technical.py:617:12: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            if close.iloc[i] > close.iloc[i - 1]:
               ^~~~~~~~~~~~~
infrastructure\core\technical.py:618:13: error: Unsupported target for indexed
assignment ("Callable[[], Any]")  [index]
                obv.iloc[i] = obv.iloc[i - 1] + volume.iloc[i]
                ^~~~~~~~~~~
infrastructure\core\technical.py:618:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                obv.iloc[i] = obv.iloc[i - 1] + volume.iloc[i]
                              ^~~~~~~~~~~~~~~
infrastructure\core\technical.py:619:14: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            elif close.iloc[i] < close.iloc[i - 1]:
                 ^~~~~~~~~~~~~
infrastructure\core\technical.py:620:13: error: Unsupported target for indexed
assignment ("Callable[[], Any]")  [index]
                obv.iloc[i] = obv.iloc[i - 1] - volume.iloc[i]
                ^~~~~~~~~~~
infrastructure\core\technical.py:620:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                obv.iloc[i] = obv.iloc[i - 1] - volume.iloc[i]
                              ^~~~~~~~~~~~~~~
infrastructure\core\technical.py:622:13: error: Unsupported target for indexed
assignment ("Callable[[], Any]")  [index]
                obv.iloc[i] = obv.iloc[i - 1]
                ^~~~~~~~~~~
infrastructure\core\technical.py:622:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                obv.iloc[i] = obv.iloc[i - 1]
                              ^~~~~~~~~~~~~~~
infrastructure\core\technical.py:630:22: error: Unsupported left operand type
for + ("Series")  [operator]
        typical_price = (high + low + close) / 3
                         ^~~~~~~~~~
infrastructure\core\technical.py:631:48: error: "Series" has no attribute
"cumsum"  [attr-defined]
        vwap = (typical_price * volume).cumsum() / volume.cumsum()
                                                   ^~~~~~~~~~~~~
infrastructure\core\data_processor.py:19:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\core\data_processor.py:47:22: error: "DataFrame" has no
attribute "copy"  [attr-defined]
                result = data.copy()
                         ^~~~~~~~~
infrastructure\core\data_processor.py:66:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data[f"sma_{period}"] = data[column].rolling(window=period...
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:76:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data[f"ema_{period}"] = data[column].ewm(span=period).mean...
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:90:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data[f"rsi_{period}"] = 100 - (100 / (1 + rs))
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:104:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data["macd"] = ema_fast - ema_slow
                ^~~~~~~~~~~~
infrastructure\core\data_processor.py:105:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data["macd_signal"] = data["macd"].ewm(span=signal_period)...
                ^~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:106:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data["macd_histogram"] = data["macd"] - data["macd_signal"...
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:119:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data[f"bb_upper_{period}"] = sma + (std * std_dev)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:120:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data[f"bb_middle_{period}"] = sma
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:121:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data[f"bb_lower_{period}"] = sma - (std * std_dev)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:133:26: error: Module has no attribute
"concat"  [attr-defined]
                true_range = pd.concat([high_low, high_close, low_close], ...
                             ^~~~~~~~~
infrastructure\core\data_processor.py:136:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data[f"atr_{period}"] = true_range.rolling(window=period)....
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:146:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data[f"volume_sma_{period}"] = data[column].rolling(window...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:157:17: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                    data[f"price_change_{period}"] = data[column].pct_chan...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:168:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data[f"volatility_{period}"] = returns.rolling(window=peri...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:178:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                data[f"momentum_{period}"] = data[column] - data[column].s...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:186:22: error: "DataFrame" has no
attribute "copy"  [attr-defined]
                result = data.copy()
                         ^~~~~~~~~
infrastructure\core\data_processor.py:187:31: error: "DataFrame" has no
attribute "select_dtypes"  [attr-defined]
                numeric_columns = data.select_dtypes(include=[np.number])....
                                  ^~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:215:22: error: "DataFrame" has no
attribute "copy"  [attr-defined]
                result = data.copy()
                         ^~~~~~~~~
infrastructure\core\data_processor.py:216:31: error: "DataFrame" has no
attribute "select_dtypes"  [attr-defined]
                numeric_columns = data.select_dtypes(include=[np.number])....
                                  ^~~~~~~~~~~~~~~~~~
infrastructure\core\data_processor.py:244:26: error: "DataFrame" has no
attribute "resample"  [attr-defined]
                    result = data.resample(freq).last()
                             ^~~~~~~~~~~~~
infrastructure\core\data_processor.py:246:26: error: "DataFrame" has no
attribute "resample"  [attr-defined]
                    result = data.resample(freq).first()
                             ^~~~~~~~~~~~~
infrastructure\core\data_processor.py:248:26: error: "DataFrame" has no
attribute "resample"  [attr-defined]
                    result = data.resample(freq).mean()
                             ^~~~~~~~~~~~~
infrastructure\core\data_processor.py:250:26: error: "DataFrame" has no
attribute "resample"  [attr-defined]
                    result = data.resample(freq).sum()
                             ^~~~~~~~~~~~~
infrastructure\core\data_processor.py:252:26: error: "DataFrame" has no
attribute "resample"  [attr-defined]
                    result = data.resample(freq).last()
                             ^~~~~~~~~~~~~
infrastructure\core\data_processor.py:290:30: error: "DataFrame" has no
attribute "isnull"  [attr-defined]
                missing_values = data.isnull().sum()
                                 ^~~~~~~~~~~
infrastructure\core\data_processor.py:302:31: error: "DataFrame" has no
attribute "dtypes"  [attr-defined]
                    "data_types": data.dtypes.to_dict(),
                                  ^~~~~~~~~~~
infrastructure\core\data_pipeline.py:71:22: error: Module has no attribute
"read_csv"  [attr-defined]
                    df = pd.read_csv(source, **kwargs)
                         ^~~~~~~~~~~
infrastructure\core\data_pipeline.py:73:22: error: Module has no attribute
"read_parquet"  [attr-defined]
                    df = pd.read_parquet(source, **kwargs)
                         ^~~~~~~~~~~~~~~
infrastructure\core\data_pipeline.py:84:18: error: "DataFrame" has no attribute
"drop_duplicates"  [attr-defined]
                df = df.drop_duplicates()
                     ^~~~~~~~~~~~~~~~~~
infrastructure\core\data_pipeline.py:85:18: error: "DataFrame" has no attribute
"dropna"  [attr-defined]
                df = df.dropna()
                     ^~~~~~~~~
infrastructure\core\data_pipeline.py:86:25: error: "DataFrame" has no attribute
"shape"  [attr-defined]
                logger.info(f"Cleaned data, shape={df.shape}")
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\data_pipeline.py:94:13: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
                df["datetime"] = pd.to_datetime(df["datetime"])
                ^~~~~~~~~~~~~~
infrastructure\core\data_pipeline.py:96:17: error: "DataFrame" has no attribute
"set_index"  [attr-defined]
                    df.set_index("datetime")
                    ^~~~~~~~~~~~
infrastructure\core\data_pipeline.py:110:25: error: "DataFrame" has no
attribute "shape"  [attr-defined]
                logger.info(f"Aggregated data to {freq}, shape={df.shape}"...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\risk\services.py:127:18: error: Item "None" of
"dict[str, Any] | None" has no attribute "get"  [union-attr]
            var_95 = details.get("var_95", 0)
                     ^~~~~~~~~~~
infrastructure\agents\risk\services.py:134:25: error: Argument "metrics" to
"_trigger_alert" of "RiskMonitoringService" has incompatible type
"dict[str, Any] | None"; expected "dict[str, Any]"  [arg-type]
                    metrics=details,
                            ^~~~~~~
infrastructure\agents\risk\services.py:137:18: error: Item "None" of
"dict[str, Any] | None" has no attribute "get"  [union-attr]
            max_dd = details.get("max_drawdown", 0)
                     ^~~~~~~~~~~
infrastructure\agents\risk\services.py:144:25: error: Argument "metrics" to
"_trigger_alert" of "RiskMonitoringService" has incompatible type
"dict[str, Any] | None"; expected "dict[str, Any]"  [arg-type]
                    metrics=details,
                            ^~~~~~~
infrastructure\agents\risk\services.py:147:22: error: Item "None" of
"dict[str, Any] | None" has no attribute "get"  [union-attr]
            volatility = details.get("volatility", 0)
                         ^~~~~~~~~~~
infrastructure\agents\risk\services.py:154:25: error: Argument "metrics" to
"_trigger_alert" of "RiskMonitoringService" has incompatible type
"dict[str, Any] | None"; expected "dict[str, Any]"  [arg-type]
                    metrics=details,
                            ^~~~~~~
infrastructure\agents\risk\services.py:200:13: error: Dict entry 1 has
incompatible type "str": "floating[Any]"; expected "str": "float"  [dict-item]
                "average": np.mean(risk_values),
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\news\providers.py:13:1: error: Module
"infrastructure.agents.social_media_agent" has no attribute "SocialMediaAgent" 
[attr-defined]
    from infrastructure.agents.social_media_agent import SocialMediaAgent
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\market_regime\types.py:287:26: error: Argument 1 to
"float" has incompatible type
"float | SupportsDunderLT[Any] | SupportsDunderGT[Any]"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                return float(min(1.0, max(0.0, confidence)))
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\market_maker\liquidity_analyzer.py:61:26: error: Module
has no attribute "cut"  [attr-defined]
                price_bins = pd.cut(market_data["close"], bins=20)
                             ^~~~~~
infrastructure\agents\market_maker\liquidity_analyzer.py:62:30: error:
"DataFrame" has no attribute "groupby"  [attr-defined]
                volume_profile = market_data.groupby(price_bins)["volume"]...
                                 ^~~~~~~~~~~~~~~~~~~
examples\liquidity_gravity_quick_example.py:11:1: error: Module
"application.risk.liquidity_gravity_monitor" has no attribute
"LiquidityGravityFilter"; maybe "LiquidityGravityMonitor",
"LiquidityGravityResult", or "LiquidityGravityModel"?  [attr-defined]
    from application.risk.liquidity_gravity_monitor import (LiquidityGravi...
    ^
examples\liquidity_gravity_quick_example.py:11:1: error: Module
"application.risk.liquidity_gravity_monitor" has no attribute
"LiquidityRiskAssessor"  [attr-defined]
    from application.risk.liquidity_gravity_monitor import (LiquidityGravi...
    ^
examples\liquidity_gravity_quick_example.py:38:41: error: Argument "timestamp"
to "OrderBookSnapshot" has incompatible type "Timestamp"; expected "datetime" 
[arg-type]
            bids=bids, asks=asks, timestamp=Timestamp(time.time()), symbol...
                                            ^~~~~~~~~~~~~~~~~~~~~~
domain\sessions\types.py:19:5: error: Cannot assign multiple types to name
"PandasSeries" without an explicit "Type[...]" annotation  [misc]
        PandasSeries = object
        ^~~~~~~~~~~~
domain\sessions\types.py:19:20: error: Incompatible types in assignment
(expression has type "type[object]", variable has type "type[Series]") 
[assignment]
        PandasSeries = object
                       ^~~~~~
domain\sessions\types.py:20:5: error: Cannot assign multiple types to name
"PandasDataFrame" without an explicit "Type[...]" annotation  [misc]
        PandasDataFrame = object
        ^~~~~~~~~~~~~~~
domain\sessions\types.py:20:23: error: Incompatible types in assignment
(expression has type "type[object]", variable has type "type[DataFrame]") 
[assignment]
        PandasDataFrame = object
                          ^~~~~~
domain\sessions\types.py:21:5: error: Cannot assign multiple types to name
"PandasIndex" without an explicit "Type[...]" annotation  [misc]
        PandasIndex = object
        ^~~~~~~~~~~
domain\sessions\types.py:21:19: error: Incompatible types in assignment
(expression has type "type[object]", variable has type "type[Index]") 
[assignment]
        PandasIndex = object
                      ^~~~~~
domain\sessions\types.py:22:5: error: Cannot assign multiple types to name
"PandasTimestamp" without an explicit "Type[...]" annotation  [misc]
        PandasTimestamp = object
        ^~~~~~~~~~~~~~~
domain\sessions\types.py:22:23: error: Incompatible types in assignment
(expression has type "type[object]", variable has type "type[Timestamp]") 
[assignment]
        PandasTimestamp = object
                          ^~~~~~
domain\sessions\types.py:23:5: error: Cannot assign multiple types to name
"NumpyArray" without an explicit "Type[...]" annotation  [misc]
        NumpyArray = object
        ^~~~~~~~~~
domain\sessions\types.py:23:18: error: Incompatible types in assignment
(expression has type "type[object]", variable has type
"type[ndarray[_ShapeType, _DType_co]]")  [assignment]
        NumpyArray = object
                     ^~~~~~
domain\sessions\types.py:24:5: error: Cannot assign multiple types to name
"NumpyFloat" without an explicit "Type[...]" annotation  [misc]
        NumpyFloat = float
        ^~~~~~~~~~
domain\sessions\types.py:24:18: error: Incompatible types in assignment
(expression has type "type[float]", variable has type "type[floating[_64Bit]]") 
[assignment]
        NumpyFloat = float
                     ^~~~~
domain\sessions\types.py:25:5: error: Cannot assign multiple types to name
"NumpyInt" without an explicit "Type[...]" annotation  [misc]
        NumpyInt = int
        ^~~~~~~~
domain\sessions\types.py:25:16: error: Incompatible types in assignment
(expression has type "type[int]", variable has type
"type[signedinteger[_64Bit]]")  [assignment]
        NumpyInt = int
                   ^~~
domain\services\spread_analyzer.py:94:29: error: "DataFrame" has no attribute
"get"  [attr-defined]
                spread_series = historical_data.get(
                                ^~~~~~~~~~~~~~~~~~~
domain\services\liquidity_analyzer.py:7:1: error: Module "pandas" has no
attribute "Interval"  [attr-defined]
    from pandas import Interval
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\liquidity_analyzer.py:122:26: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
                    candle = market_data.iloc[i]
                             ^~~~~~~~~~~~~~~~
domain\services\liquidity_analyzer.py:201:22: error: Module has no attribute
"cut"  [attr-defined]
            price_bins = pd.cut(market_data["close"], bins=50)
                         ^~~~~~
domain\services\liquidity_analyzer.py:202:27: error: "DataFrame" has no
attribute "groupby"  [attr-defined]
            volume_by_price = market_data.groupby(price_bins)["volume"].su...
                              ^~~~~~~~~~~~~~~~~~~
domain\services\liquidity_analyzer.py:293:26: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            previous_highs = market_data.iloc[max(0, index - 5) : index]["...
                             ^~~~~~~~~~~~~~~~
domain\services\liquidity_analyzer.py:303:25: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            previous_lows = market_data.iloc[max(0, index - 5) : index]["l...
                            ^~~~~~~~~~~~~~~~
domain\types\evolution_types.py:191:10: error: Name "StrategyEvaluationResult"
is not defined  [name-defined]
        ) -> 'StrategyEvaluationResult':
             ^
domain\types\evolution_types.py:194:45: error: Name "StrategyEvaluationResult"
is not defined  [name-defined]
        def get_fitness_score(self, evaluation: 'StrategyEvaluationResult'...
                                                ^
domain\types\evolution_types.py:197:68: error: Name "StrategyEvaluationResult"
is not defined  [name-defined]
    ...tion_result(self, strategy_id: UUID) -> Optional['StrategyEvaluationRe...
                                                        ^
domain\types\evolution_types.py:200:39: error: Name "StrategyEvaluationResult"
is not defined  [name-defined]
        def get_all_results(self) -> List['StrategyEvaluationResult']:
                                          ^
domain\types\evolution_types.py:203:47: error: Name "StrategyEvaluationResult"
is not defined  [name-defined]
        def get_approved_strategies(self) -> List['StrategyEvaluationResul...
                                                  ^
domain\types\evolution_types.py:206:55: error: Name "StrategyEvaluationResult"
is not defined  [name-defined]
    ...ef get_top_strategies(self, n: int = 10) -> List['StrategyEvaluationRe...
                                                        ^
domain\types\evolution_types.py:268:27: error: Name "StrategyEvaluationResult"
is not defined  [name-defined]
            evaluations: List['StrategyEvaluationResult'],
                              ^
domain\types\evolution_types.py:277:27: error: Name "StrategyEvaluationResult"
is not defined  [name-defined]
            evaluations: List['StrategyEvaluationResult'],
                              ^
domain\types\evolution_types.py:285:27: error: Name "StrategyEvaluationResult"
is not defined  [name-defined]
            evaluations: List['StrategyEvaluationResult'],
                              ^
domain\types\evolution_types.py:294:27: error: Name "StrategyEvaluationResult"
is not defined  [name-defined]
            evaluations: List['StrategyEvaluationResult'],
                              ^
domain\evolution\strategy_model.py:545:9: error: Incompatible types in
assignment (expression has type "ExitRule", variable has type "EntryRule") 
[assignment]
            for rule in self.exit_rules:
            ^
domain\evolution\strategy_model.py:546:27: error: "EntryRule" has no attribute
"validate_parameters"  [attr-defined]
                errors.extend(rule.validate_parameters())
                              ^~~~~~~~~~~~~~~~~~~~~~~~
domain\evolution\strategy_model.py:606:9: error: Incompatible types in
assignment (expression has type "ExitRule", variable has type "EntryRule") 
[assignment]
            for rule in self.exit_rules:
            ^
domain\evolution\strategy_model.py:607:41: error: Argument 1 to "append" of
"list" has incompatible type "EntryRule"; expected "ExitRule"  [arg-type]
                candidate.exit_rules.append(rule.clone())
                                            ^~~~~~~~~~~~
application\market\mm_follow_controller.py:147:17: error: Name "Symbol" is not
defined  [name-defined]
                    Symbol(symbol), order_book, trades
                    ^~~~~~
application\market\mm_follow_controller.py:157:25: error: Argument 2 to
"find_similar_patterns" of "IPatternMemoryRepository" has incompatible type
"dict[str, Any] | PatternFeatures"; expected "dict[str, Any]"  [arg-type]
                    symbol, features_dict, self.config["min_similarity_thr...
                            ^~~~~~~~~~~~~
application\market\mm_follow_controller.py:167:32: error: Argument
"pattern_memory" to "MatchedPattern" has incompatible type "Any | None";
expected "PatternMemory"  [arg-type]
                    pattern_memory=best_match_data.get("pattern_memory"),
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\market\mm_follow_controller.py:171:34: error: Argument
"expected_outcome" to "MatchedPattern" has incompatible type "Any | None";
expected "PatternResult"  [arg-type]
                    expected_outcome=best_match_data.get("expected_outcome...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\test_liquidity_gravity_integration.py:49:45: error: Argument "timestamp"
to "OrderBookSnapshot" has incompatible type "Timestamp"; expected "datetime" 
[arg-type]
                bids=bids, asks=asks, timestamp=Timestamp(time.time()), sy...
                                                ^~~~~~~~~~~~~~~~~~~~~~
tests\automated_test_suite.py:73:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\automated_test_suite.py:74:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\automated_test_suite.py:75:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\automated_test_suite.py:76:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\automated_test_suite.py:77:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\automated_test_suite.py:414:9: error: Value of type
"Coroutine[Any, Any, None]" must be used  [unused-coroutine]
            performance_monitor.stop_monitoring()
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\automated_test_suite.py:414:9: note: Are you missing an await?
tests\unit\test_volatility_analyzer.py:20:17: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.date_range('2023-01-01', periods=1000, freq='1H')
                    ^~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:26:17: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.date_range('2023-01-01', periods=1000, freq='1H')
                    ^~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:36:9: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
            data['high'] = data[['open', 'close']].max(axis=1) + np.random...
            ^~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:37:9: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
            data['low'] = data[['open', 'close']].min(axis=1) - np.random....
            ^~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:75:23: error: "SignalProcessor" has no
attribute "generate_rsi_signals"  [attr-defined]
            rsi_signals = signal_processor.generate_rsi_signals(sample_mar...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:99:24: error: "SignalProcessor" has no
attribute "generate_macd_signals"  [attr-defined]
            macd_signals = signal_processor.generate_macd_signals(sample_m...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:114:22: error: "SignalProcessor" has
no attribute "generate_moving_average_signals"  [attr-defined]
            ma_signals = signal_processor.generate_moving_average_signals(
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:131:22: error: "SignalProcessor" has
no attribute "generate_bollinger_bands_signals"  [attr-defined]
            bb_signals = signal_processor.generate_bollinger_bands_signals...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:146:26: error: "SignalProcessor" has
no attribute "generate_volume_signals"  [attr-defined]
            volume_signals = signal_processor.generate_volume_signals(samp...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:161:28: error: "SignalProcessor" has
no attribute "filter_signals"  [attr-defined]
            filtered_signals = signal_processor.filter_signals(
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:181:30: error: "SignalProcessor" has
no attribute "aggregate_signals"  [attr-defined]
            aggregated_signals = signal_processor.aggregate_signals(sample...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:194:28: error: "SignalProcessor" has
no attribute "analyze_signal_quality"  [attr-defined]
            quality_analysis = signal_processor.analyze_signal_quality(sam...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:213:29: error: "SignalProcessor" has
no attribute "validate_signals"  [attr-defined]
            validation_result = signal_processor.validate_signals(sample_s...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:230:22: error: "SignalProcessor" has
no attribute "calculate_signal_statistics"  [attr-defined]
            statistics = signal_processor.calculate_signal_statistics(samp...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:252:27: error: "SignalProcessor" has
no attribute "backtest_signals"  [attr-defined]
            backtest_result = signal_processor.backtest_signals(sample_sig...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:278:31: error: "SignalProcessor" has
no attribute "optimize_signal_parameters"  [attr-defined]
            optimization_result = signal_processor.optimize_signal_paramet...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:295:18: error: "SignalProcessor" has
no attribute "generate_signal_alerts"  [attr-defined]
            alerts = signal_processor.generate_signal_alerts(sample_signal...
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:315:19: error: "SignalProcessor" has
no attribute "get_signal_history"  [attr-defined]
            history = signal_processor.get_signal_history(
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:327:13: error: "SignalProcessor" has
no attribute "generate_rsi_signals"  [attr-defined]
                signal_processor.generate_rsi_signals(None)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:329:13: error: "SignalProcessor" has
no attribute "filter_signals"  [attr-defined]
                signal_processor.filter_signals(None, {})
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:337:23: error: "SignalProcessor" has
no attribute "generate_rsi_signals"  [attr-defined]
            rsi_signals = signal_processor.generate_rsi_signals(short_data...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:341:28: error: "SignalProcessor" has
no attribute "filter_signals"  [attr-defined]
            filtered_signals = signal_processor.filter_signals(empty_signa...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:346:9: error: "SignalProcessor" has no
attribute "cleanup"  [attr-defined]
            signal_processor.cleanup()
            ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:348:16: error: "SignalProcessor" has
no attribute "signal_generators"  [attr-defined]
            assert signal_processor.signal_generators == {}
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:349:16: error: "SignalProcessor" has
no attribute "signal_filters"  [attr-defined]
            assert signal_processor.signal_filters == {}
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_unit_signal_processor.py:350:16: error: "SignalProcessor" has
no attribute "signal_aggregators"  [attr-defined]
            assert signal_processor.signal_aggregators == {} 
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:25:34: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.DatetimeIndex(pd.date_range('2023-01-01', periods=1...
                                     ^~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:35:9: error: "DataFrame" has no attribute
"loc"  [attr-defined]
            data.loc[:, 'high'] = data[['open', 'close']].max(axis=1) + np...
            ^~~~~~~~
tests\unit\test_technical_analysis.py:36:9: error: "DataFrame" has no attribute
"loc"  [attr-defined]
            data.loc[:, 'low'] = data[['open', 'close']].min(axis=1) - np....
            ^~~~~~~~
tests\unit\test_technical_analysis.py:47:20: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert not sma_20.iloc[:19].notna().any()  # ѕервые 19 значени...
                       ^~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:48:20: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert not sma_50.iloc[:49].notna().any()  # ѕервые 49 значени...
                       ^~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:49:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert sma_20.iloc[19:].notna().all()  # ќстальные значени€ до...
                   ^~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:50:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert sma_50.iloc[49:].notna().all()  # ќстальные значени€ до...
                   ^~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:60:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert ema_20.iloc[0].notna()  # EMA должна начинатьс€ с перво...
                   ^~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:61:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert ema_50.iloc[0].notna()  # EMA должна начинатьс€ с перво...
                   ^~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:62:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert ema_20.iloc[1:].notna().all()  # ¬се остальные значени€...
                   ^~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:63:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert ema_50.iloc[1:].notna().all()  # ¬се остальные значени€...
                   ^~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:71:20: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert not rsi_14.iloc[:14].notna().any()  # ѕервые 14 значени...
                       ^~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:72:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert rsi_14.iloc[14:].notna().all()  # ќстальные значени€ до...
                   ^~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:73:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (rsi_14 >= 0).all()  # RSI должен быть >= 0
                   ^~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:73:17: error: Unsupported operand types
for <= ("int" and "Series")  [operator]
            assert (rsi_14 >= 0).all()  # RSI должен быть >= 0
                    ^
tests\unit\test_technical_analysis.py:74:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (rsi_14 <= 100).all()  # RSI должен быть <= 100
                   ^~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:74:17: error: Unsupported operand types
for >= ("int" and "Series")  [operator]
            assert (rsi_14 <= 100).all()  # RSI должен быть <= 100
                    ^
tests\unit\test_technical_analysis.py:90:14: error: Unsupported left operand
type for - ("Series")  [operator]
                (macd_line - signal_line).to_numpy(), 
                 ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:106:17: error: Unsupported left operand
type for >= ("Series")  [operator]
            assert (upper >= middle).all()
                    ^~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:107:17: error: Unsupported left operand
type for >= ("Series")  [operator]
            assert (middle >= lower).all()
                    ^~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:123:20: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert not atr_14.iloc[:14].notna().any()  # ѕервые 14 значени...
                       ^~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:124:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert atr_14.iloc[14:].notna().all()  # ќстальные значени€ до...
                   ^~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:125:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (atr_14 >= 0).all()  # ATR должен быть >= 0
                   ^~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:125:17: error: Unsupported operand types
for <= ("int" and "Series")  [operator]
            assert (atr_14 >= 0).all()  # ATR должен быть >= 0
                    ^
tests\unit\test_technical_analysis.py:142:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (k_percent >= 0).all()  # %K должен быть >= 0
                   ^~~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:142:17: error: Unsupported operand types
for <= ("int" and "Series")  [operator]
            assert (k_percent >= 0).all()  # %K должен быть >= 0
                    ^
tests\unit\test_technical_analysis.py:143:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (k_percent <= 100).all()  # %K должен быть <= 100
                   ^~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:143:17: error: Unsupported operand types
for >= ("int" and "Series")  [operator]
            assert (k_percent <= 100).all()  # %K должен быть <= 100
                    ^
tests\unit\test_technical_analysis.py:144:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (d_percent >= 0).all()  # %D должен быть >= 0
                   ^~~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:144:17: error: Unsupported operand types
for <= ("int" and "Series")  [operator]
            assert (d_percent >= 0).all()  # %D должен быть >= 0
                    ^
tests\unit\test_technical_analysis.py:145:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (d_percent <= 100).all()  # %D должен быть <= 100
                   ^~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:145:17: error: Unsupported operand types
for >= ("int" and "Series")  [operator]
            assert (d_percent <= 100).all()  # %D должен быть <= 100
                    ^
tests\unit\test_technical_analysis.py:158:20: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert not williams_r.iloc[:14].notna().any()  # ѕервые 14 зна...
                       ^~~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:159:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert williams_r.iloc[14:].notna().all()  # ќстальные значени...
                   ^~~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:160:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (williams_r >= -100).all()  # Williams %R должен быть >...
                   ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:160:17: error: Unsupported operand types
for <= ("int" and "Series")  [operator]
            assert (williams_r >= -100).all()  # Williams %R должен быть >...
                    ^
tests\unit\test_technical_analysis.py:161:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (williams_r <= 0).all()  # Williams %R должен быть <= 0
                   ^~~~~~~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:161:17: error: Unsupported operand types
for >= ("int" and "Series")  [operator]
            assert (williams_r <= 0).all()  # Williams %R должен быть <= 0
                    ^
tests\unit\test_technical_analysis.py:174:20: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert not cci.iloc[:20].notna().any()  # ѕервые 20 значений д...
                       ^~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:175:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert cci.iloc[20:].notna().all()  # ќстальные значени€ должн...
                   ^~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:191:20: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert not adx.iloc[:14].notna().any()  # ѕервые 14 значений д...
                       ^~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:192:16: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert adx.iloc[14:].notna().all()  # ќстальные значени€ должн...
                   ^~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:193:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (adx >= 0).all()  # ADX должен быть >= 0
                   ^~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:193:17: error: Unsupported operand types
for <= ("int" and "Series")  [operator]
            assert (adx >= 0).all()  # ADX должен быть >= 0
                    ^
tests\unit\test_technical_analysis.py:194:16: error: "bool" has no attribute
"all"  [attr-defined]
            assert (adx <= 100).all()  # ADX должен быть <= 100
                   ^~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:194:17: error: Unsupported operand types
for >= ("int" and "Series")  [operator]
            assert (adx <= 100).all()  # ADX должен быть <= 100
                    ^
tests\unit\test_technical_analysis.py:352:22: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            small_data = sample_data.iloc[:10]
                         ^~~~~~~~~~~~~~~~
tests\unit\test_technical_analysis.py:359:21: error: "DataFrame" has no
attribute "copy"  [attr-defined]
            data_copy = sample_data.copy()
                        ^~~~~~~~~~~~~~~~
tests\unit\test_strategy_optimizer.py:39:34: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.DatetimeIndex(pd.date_range('2023-01-01', periods=1...
                                     ^~~~~~~~~~~~~
tests\unit\test_strategy_optimizer.py:49:9: error: "DataFrame" has no attribute
"loc"  [attr-defined]
            data.loc[:, 'high'] = data[['open', 'close']].max(axis=1) + np...
            ^~~~~~~~
tests\unit\test_strategy_optimizer.py:50:9: error: "DataFrame" has no attribute
"loc"  [attr-defined]
            data.loc[:, 'low'] = data[['open', 'close']].min(axis=1) - np....
            ^~~~~~~~
tests\unit\test_risk_manager.py:23:13: error: Signature of "publish"
incompatible with supertype "EventBus"  [override]
                async def publish(self, event: str, data: Dict[str, Any]) ...
                ^
tests\unit\test_risk_manager.py:23:13: note:      Superclass:
tests\unit\test_risk_manager.py:23:13: note:          def publish(self, event: Event) -> Coroutine[Any, Any, bool]
tests\unit\test_risk_manager.py:23:13: note:      Subclass:
tests\unit\test_risk_manager.py:23:13: note:          def publish(self, event: str, data: dict[str, Any]) -> Coroutine[Any, Any, None]
tests\unit\test_risk_manager.py:23:13: error: Signature of "publish"
incompatible with supertype "EventBusProtocol"  [override]
                async def publish(self, event: str, data: Dict[str, Any]) ...
                ^
tests\unit\test_risk_manager.py:23:13: note:      Superclass:
tests\unit\test_risk_manager.py:23:13: note:          def publish(self, event: Event) -> Coroutine[Any, Any, bool]
tests\unit\test_risk_manager.py:23:13: note:      Subclass:
tests\unit\test_risk_manager.py:23:13: note:          def publish(self, event: str, data: dict[str, Any]) -> Coroutine[Any, Any, None]
tests\unit\test_order_utils.py:177:45: error: Argument 1 to "float" has
incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
            execution_quality = "good" if float(execution_data["slippage"]...
                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_order_utils.py:481:9: error: Need type annotation for
"invalid_order" (hint: "invalid_order: dict[<type>, <type>] = ...") 
[var-annotated]
            invalid_order = {}
            ^~~~~~~~~~~~~
tests\unit\test_ml_pipeline.py:80:13: error: "DataFrame" has no attribute
"drop"  [attr-defined]
            X = sample_dataframe_data.drop(columns=['target'])
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_ml_pipeline.py:177:13: error: "DataFrame" has no attribute
"drop"  [attr-defined]
            X = sample_dataframe_data.drop(columns=['target'])
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_ml_pipeline.py:292:13: error: "DataFrame" has no attribute
"drop"  [attr-defined]
            X = sample_dataframe_data.drop(columns=['target'])
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_market_regime_detector.py:22:34: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.DatetimeIndex(pd.date_range('2023-01-01', periods=1...
                                     ^~~~~~~~~~~~~
tests\unit\test_market_regime_detector.py:31:9: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            data.iloc[:300, data.columns.get_loc('close')] = data.iloc[:30...
            ^~~~~~~~~
tests\unit\test_market_regime_detector.py:32:9: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            data.iloc[300:600, data.columns.get_loc('close')] = data.iloc[...
            ^~~~~~~~~
tests\unit\test_market_regime_detector.py:33:9: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            data.iloc[600:, data.columns.get_loc('close')] = data.iloc[600...
            ^~~~~~~~~
tests\unit\test_market_data_processor.py:22:34: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.DatetimeIndex(pd.date_range('2023-01-01', periods=1...
                                     ^~~~~~~~~~~~~
tests\unit\test_market_data_processor.py:32:9: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
            data['high'] = data[['open', 'close']].max(axis=1) + np.random...
            ^~~~~~~~~~~~
tests\unit\test_market_data_processor.py:33:9: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
            data['low'] = data[['open', 'close']].min(axis=1) - np.random....
            ^~~~~~~~~~~
tests\unit\test_market_data_processor.py:188:29: error: "DataFrame" has no
attribute "copy"  [attr-defined]
            data_with_anomaly = sample_market_data.copy(deep=True)
                                ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_market_data_processor.py:288:22: error: "DataFrame" has no
attribute "copy"  [attr-defined]
            dirty_data = sample_market_data.copy(deep=True)
                         ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_market_data_processor.py:298:20: error: "DataFrame" has no
attribute "isna"  [attr-defined]
            assert not cleaned_data.isna().any().any()
                       ^~~~~~~~~~~~~~~~~
tests\unit\test_market_data_processor.py:341:25: error: "DataFrame" has no
attribute "copy"  [attr-defined]
            data_with_nan = short_data.copy(deep=True)
                            ^~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:21:34: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.DatetimeIndex(pd.date_range('2023-01-01', periods=1...
                                     ^~~~~~~~~~~~~
tests\unit\test_data_processor.py:31:9: error: Unsupported target for indexed
assignment ("DataFrame")  [index]
            data['high'] = data[['open', 'close']].max(axis=1) + np.random...
            ^~~~~~~~~~~~
tests\unit\test_data_processor.py:32:9: error: Unsupported target for indexed
assignment ("DataFrame")  [index]
            data['low'] = data[['open', 'close']].min(axis=1) - np.random....
            ^~~~~~~~~~~
tests\unit\test_data_processor.py:37:34: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.DatetimeIndex(pd.date_range('2023-01-01', periods=1...
                                     ^~~~~~~~~~~~~
tests\unit\test_data_processor.py:44:18: error: Value of type "DatetimeIndex"
is not indexable  [index]
            }, index=dates[:5])
                     ^~~~~~~~~
tests\unit\test_data_processor.py:62:20: error:
"<subclass of "typing.Coroutine[Any, Any, builtins.dict[builtins.str,
Any]]" and "pandas.DataFrame">" has no attribute "isna"  [attr-defined]
            assert not cleaned_data.isna().all().any()
                       ^~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:68:32: error: Module has no attribute
"concat"  [attr-defined]
            data_with_duplicates = pd.concat([sample_market_data, sample_m...
                                   ^~~~~~~~~
tests\unit\test_data_processor.py:68:63: error: "DataFrame" has no attribute
"iloc"  [attr-defined]
    ...with_duplicates = pd.concat([sample_market_data, sample_market_data.il...
                                                        ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:75:20: error:
"<subclass of "typing.Coroutine[Any, Any, builtins.dict[builtins.str,
Any]]" and "pandas.DataFrame">" has no attribute "duplicated"  [attr-defined]
            assert not deduplicated_data.duplicated().any()
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:85:20: error:
"<subclass of "typing.Coroutine[Any, Any, builtins.dict[builtins.str,
Any]]" and "pandas.DataFrame">" has no attribute "isna"  [attr-defined]
            assert not processed_data.isna().any().any()
                       ^~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:89:30: error: "DataFrame" has no attribute
"copy"  [attr-defined]
            data_with_outliers = sample_market_data.copy(deep=True)
                                 ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:173:16: error: Module has no attribute "isna"
 [attr-defined]
            assert pd.isna(returns.iloc[0])
                   ^~~~~~~
tests\unit\test_data_processor.py:173:24: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert pd.isna(returns.iloc[0])
                           ^~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:175:20: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert not returns.iloc[1:].isna().all()
                       ^~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:186:16: error: Module has no attribute "isna"
 [attr-defined]
            assert pd.isna(volatility.iloc[:19]).all()
                   ^~~~~~~
tests\unit\test_data_processor.py:186:24: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert pd.isna(volatility.iloc[:19]).all()
                           ^~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:188:20: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            assert not volatility.iloc[20:].isna().all()
                       ^~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:221:22: error: "DataFrame" has no attribute
"iloc"  [attr-defined]
            train_data = sample_market_data.iloc[:split_idx]
                         ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:222:21: error: "DataFrame" has no attribute
"iloc"  [attr-defined]
            test_data = sample_market_data.iloc[split_idx:]
                        ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:289:29: error: "DataFrame" has no attribute
"interpolate"  [attr-defined]
            interpolated_data = sample_dirty_data.interpolate()
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:295:20: error: "DataFrame" has no attribute
"isna"  [attr-defined]
            assert not interpolated_data.isna().any().any()
                       ^~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:300:25: error: "DataFrame" has no attribute
"copy"  [attr-defined]
            smoothed_data = sample_market_data.copy(deep=True)
                            ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:314:29: error: "DataFrame" has no attribute
"copy"  [attr-defined]
            data_with_anomaly = sample_market_data.copy(deep=True)
                                ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:328:22: error: "DataFrame" has no attribute
"describe"  [attr-defined]
            statistics = sample_market_data.describe()
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:380:9: error: "DataProcessor" has no
attribute "cleanup"  [attr-defined]
            data_processor.cleanup()
            ^~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:382:16: error: "DataProcessor" has no
attribute "data_cleaners"  [attr-defined]
            assert data_processor.data_cleaners == {}
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:383:16: error: "DataProcessor" has no
attribute "data_normalizers"  [attr-defined]
            assert data_processor.data_normalizers == {}
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:384:16: error: "DataProcessor" has no
attribute "data_filters"  [attr-defined]
            assert data_processor.data_filters == {}
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_data_processor.py:385:16: error: "DataProcessor" has no
attribute "data_aggregators"  [attr-defined]
            assert data_processor.data_aggregators == {} 
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_config_manager.py:321:25: error: "backup_config" of
"ConfigManager" does not return a value (it only ever returns None) 
[func-returns-value]
            backup_result = config_manager.backup_config()
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_config_manager.py:344:9: error: Need type annotation for
"empty_config" (hint: "empty_config: dict[<type>, <type>] = ...") 
[var-annotated]
            empty_config = {}
            ^~~~~~~~~~~~
tests\unit\application_tests\test_risk.py:180:20: error:
"LiquidityGravityResult" has no attribute "gravity_score"  [attr-defined]
            strength = gravity_result.gravity_score
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_risk.py:280:13: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                weighted_sum += price * volume
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_risk.py:281:13: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                total_volume += volume
                ^~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_risk.py:464:29: error: Need type annotation
for "invalid_orderbook"  [var-annotated]
            invalid_orderbook = {"bids": [], "asks": []}
                                ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_risk.py:476:9: error: Need type annotation
for "empty_orderbook" (hint: "empty_orderbook: dict[<type>, <type>] = ...") 
[var-annotated]
            empty_orderbook = {}
            ^~~~~~~~~~~~~~~
tests\unit\application_tests\test_monitoring.py:227:17: error:
"PatternObserver" has no attribute "_calculate_pattern_statistics" 
[attr-defined]
            stats = observer._calculate_pattern_statistics(patterns)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_monitoring.py:241:18: error:
"PatternObserver" has no attribute "_detect_support_resistance_levels" 
[attr-defined]
            levels = observer._detect_support_resistance_levels(sample_mar...
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_monitoring.py:251:27: error:
"PatternObserver" has no attribute "_analyze_volume_patterns"; maybe
"_analyze_volume_profile"?  [attr-defined]
            volume_patterns = observer._analyze_volume_patterns(sample_mar...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_monitoring.py:269:19: error:
"PatternObserver" has no attribute "_get_observation_summary"; maybe
"get_observation_state"?  [attr-defined]
            summary = observer._get_observation_summary(patterns, alerts)
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_market_maker.py:437:29: error: Need type
annotation for "invalid_orderbook"  [var-annotated]
            invalid_orderbook = {"bids": [], "asks": []}
                                ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_market_maker.py:449:9: error: Need type
annotation for "empty_orderbook" (hint:
"empty_orderbook: dict[<type>, <type>] = ...")  [var-annotated]
            empty_orderbook = {}
            ^~~~~~~~~~~~~~~
tests\performance\test_agents_performance.py:21:34: error: Module has no
attribute "date_range"  [attr-defined]
            dates = pd.DatetimeIndex(pd.date_range(start='2024-01-01', per...
                                     ^~~~~~~~~~~~~
tests\integration\test_entity_system_integration.py:51: error: The return type
of a generator function should be "Generator" or one of its supertypes  [misc]
        def temp_codebase(self) -> Path:
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\monitoring\test_performance.py:110:21: error: Argument 3
to "record_metric" has incompatible type "dict[str, int]"; expected "MetricType"
 [arg-type]
                        {"worker": worker_id, "iteration": i}
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\monitoring\test_performance.py:139:21: error: Argument 3
to "create_alert" has incompatible type "str"; expected "AlertSeverity" 
[arg-type]
                        f"worker_{worker_id}"
                        ^~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\monitoring\test_monitoring_tracing.py:21:5: error: Module
"infrastructure.monitoring.monitoring_tracing" has no attribute
"PerformanceMetrics"  [attr-defined]
        from infrastructure.monitoring.monitoring_tracing import Performan...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\infrastructure\monitoring\test_monitoring_tracing.py:21:5: error: Module
"infrastructure.monitoring.monitoring_tracing" has no attribute "TraceContext" 
[attr-defined]
        from infrastructure.monitoring.monitoring_tracing import Performan...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\infrastructure\monitoring\test_monitoring_tracing.py:23:5: error: Name
"PerformanceMetrics" already defined (possibly by an import)  [no-redef]
        class PerformanceMetrics: pass
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\monitoring\test_monitoring_tracing.py:24:5: error: Name
"TraceContext" already defined (possibly by an import)  [no-redef]
        class TraceContext: pass
        ^~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\monitoring\test_monitoring_dashboard.py:14:1: error:
Module "infrastructure.monitoring.monitoring_dashboard" has no attribute
"DashboardConfig"  [attr-defined]
    from infrastructure.monitoring.monitoring_dashboard import (
    ^
tests\infrastructure\monitoring\test_monitoring_dashboard.py:14:1: error:
Module "infrastructure.monitoring.monitoring_dashboard" has no attribute
"ChartConfig"  [attr-defined]
    from infrastructure.monitoring.monitoring_dashboard import (
    ^
tests\infrastructure\monitoring\test_monitoring_dashboard.py:14:1: error:
Module "infrastructure.monitoring.monitoring_dashboard" has no attribute
"MetricData"  [attr-defined]
    from infrastructure.monitoring.monitoring_dashboard import (
    ^
tests\infrastructure\monitoring\test_monitoring_alerts.py:14:1: error: Module
"infrastructure.monitoring.monitoring_alerts" has no attribute "AlertRule" 
[attr-defined]
    from infrastructure.monitoring.monitoring_alerts import (
    ^
tests\infrastructure\monitoring\test_monitoring_alerts.py:14:1: error: Module
"infrastructure.monitoring.monitoring_alerts" has no attribute "AlertHandler" 
[attr-defined]
    from infrastructure.monitoring.monitoring_alerts import (
    ^
tests\infrastructure\monitoring\test_monitoring_alerts.py:27:5: error: Module
"infrastructure.monitoring.monitoring_alerts" has no attribute "AlertRule" 
[attr-defined]
        from infrastructure.monitoring.monitoring_alerts import AlertRule,...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\infrastructure\monitoring\test_monitoring_alerts.py:27:5: error: Module
"infrastructure.monitoring.monitoring_alerts" has no attribute "AlertHandler" 
[attr-defined]
        from infrastructure.monitoring.monitoring_alerts import AlertRule,...
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\infrastructure\monitoring\test_monitoring_alerts.py:29:5: error: Name
"AlertRule" already defined (possibly by an import)  [no-redef]
        class AlertRule: pass
        ^~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\monitoring\test_monitoring_alerts.py:30:5: error: Name
"AlertHandler" already defined (possibly by an import)  [no-redef]
        class AlertHandler: pass
        ^~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\monitoring\test_integration.py:110:71: error: Argument 3
to "record_metric" has incompatible type "dict[str, int]"; expected "MetricType"
 [arg-type]
    ...d_metric(f"worker_{worker_id}_metric", 20.0 + i, {"worker": worker_id}...
                                                        ^~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\monitoring\test_integration.py:118:21: error: Unexpected
keyword argument "source" for "create_alert"  [call-arg]
                        create_alert(
                        ^
infrastructure\monitoring\monitoring_alerts.py:252:1: note: "create_alert" defined here
tests\infrastructure\monitoring\test_integration.py:120:34: error: Argument
"severity" to "create_alert" has incompatible type "str"; expected
"AlertSeverity"  [arg-type]
                            severity="warning",
                                     ^~~~~~~~~
tests\infrastructure\monitoring\test_integration.py:243:72: error: Argument 3
to "record_metric" has incompatible type "dict[str, int]"; expected "MetricType"
 [arg-type]
    ...cord_metric(f"concurrent_metric_{worker_id}", i, {"worker": worker_id}...
                                                        ^~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\monitoring\test_integration.py:249:25: error: Argument 3
to "create_alert" has incompatible type "str"; expected "AlertSeverity" 
[arg-type]
                            f"worker_{worker_id}"
                            ^~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\entity_system\test_memory_modules.py:319:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\infrastructure\entity_system\test_memory_modules.py:349:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\e2e\test_market_profiles_e2e.py:365:39: error: Extra keys
("depth_imbalance", "flow_imbalance") for TypedDict "MarketMicrostructure" 
[typeddict-unknown-key]
                    market_microstructure=MarketMicrostructure({
                                          ^
tests\e2e\test_market_profiles_e2e.py:372:24: error: Argument "symbol" to
"MarketMakerPattern" has incompatible type "str"; expected "Symbol"  [arg-type]
                    symbol="BTCUSDT",
                           ^~~~~~~~~
tests\e2e\test_market_profiles_e2e.py:376:25: error: Extra keys
("market_regime", "session") for TypedDict "PatternContext" 
[typeddict-unknown-key]
                    context={"market_regime": "trending", "session": "asia...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:63:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, SpreadAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:83:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, SpreadAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:97:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, SpreadAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:109:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, SpreadAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:121:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, SpreadAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:133:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, SpreadMovementPrediction)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:149:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, SpreadMovementPrediction)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:160:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, SpreadMovementPrediction)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:169:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, SpreadMovementPrediction)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:316:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, SpreadAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_spread_analyzer.py:350:20: error: Cannot use
isinstance() with TypedDict type  [misc]
                assert isinstance(result, SpreadAnalysisResult)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_liquidity_analyzer.py:64:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, LiquidityAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_liquidity_analyzer.py:85:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, LiquidityAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_liquidity_analyzer.py:95:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, LiquidityAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_liquidity_analyzer.py:106:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, LiquidityAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_liquidity_analyzer.py:156:20: error: Cannot use
isinstance() with TypedDict type  [misc]
                assert isinstance(sweep, LiquiditySweep)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_liquidity_analyzer.py:359:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, LiquidityAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_liquidity_analyzer.py:393:20: error: Cannot use
isinstance() with TypedDict type  [misc]
                assert isinstance(result, LiquidityAnalysisResult)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_liquidity_analyzer.py:417:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(analysis, LiquidityAnalysisResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\entities\test_models.py:10:5: error: Module
"domain.entities.models" has no attribute "MarketData"  [attr-defined]
        from domain.entities.models import MarketData, Model, Prediction
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\entities\test_models.py:10:5: error: Module
"domain.entities.models" has no attribute "Model"  [attr-defined]
        from domain.entities.models import MarketData, Model, Prediction
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\entities\test_models.py:10:5: error: Module
"domain.entities.models" has no attribute "Prediction"  [attr-defined]
        from domain.entities.models import MarketData, Model, Prediction
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\entities\test_models.py:12:5: error: Name "MarketData" already
defined (possibly by an import)  [no-redef]
        class MarketData: pass
        ^~~~~~~~~~~~~~~~~~~~~~
tests\domain\entities\test_models.py:13:5: error: Name "Model" already defined
(possibly by an import)  [no-redef]
        class Model: pass
        ^~~~~~~~~~~~~~~~~
tests\domain\entities\test_models.py:14:5: error: Name "Prediction" already
defined (possibly by an import)  [no-redef]
        class Prediction: pass
        ^~~~~~~~~~~~~~~~~~~~~~
tests\controllers\test_trading_controller.py:8:5: error: Module
"domain.entities.models" has no attribute "Order"  [attr-defined]
        from domain.entities.models import Order, Position
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\controllers\test_trading_controller.py:8:5: error: Module
"domain.entities.models" has no attribute "Position"  [attr-defined]
        from domain.entities.models import Order, Position
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\controllers\test_trading_controller.py:10:5: error: Name "Order" already
defined (possibly by an import)  [no-redef]
        class Order: pass
        ^~~~~~~~~~~~~~~~~
tests\controllers\test_trading_controller.py:11:5: error: Name "Position"
already defined (possibly by an import)  [no-redef]
        class Position: pass
        ^~~~~~~~~~~~~~~~~~~~
tests\controllers\test_risk_controller.py:7:5: error: Module
"domain.entities.models" has no attribute "Position"  [attr-defined]
        from domain.entities.models import Position
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\controllers\test_risk_controller.py:9:5: error: Name "Position" already
defined (possibly by an import)  [no-redef]
        class Position: pass
        ^~~~~~~~~~~~~~~~~~~~
tests\controllers\test_position_controller.py:8:5: error: Module
"domain.entities.models" has no attribute "Order"  [attr-defined]
        from domain.entities.models import Order, Position
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\controllers\test_position_controller.py:8:5: error: Module
"domain.entities.models" has no attribute "Position"  [attr-defined]
        from domain.entities.models import Order, Position
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\controllers\test_position_controller.py:10:5: error: Name "Order" already
defined (possibly by an import)  [no-redef]
        class Order: pass
        ^~~~~~~~~~~~~~~~~
tests\controllers\test_position_controller.py:11:5: error: Name "Position"
already defined (possibly by an import)  [no-redef]
        class Position: pass
        ^~~~~~~~~~~~~~~~~~~~
tests\controllers\test_order_controller.py:8:5: error: Module
"domain.entities.models" has no attribute "Order"  [attr-defined]
        from domain.entities.models import Order
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\controllers\test_order_controller.py:10:5: error: Name "Order" already
defined (possibly by an import)  [no-redef]
        class Order: pass
        ^~~~~~~~~~~~~~~~~
tests\controllers\test_market_controller.py:8:5: error: Module
"domain.entities.models" has no attribute "MarketData"  [attr-defined]
        from domain.entities.models import MarketData
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\controllers\test_market_controller.py:10:5: error: Name "MarketData"
already defined (possibly by an import)  [no-redef]
        class MarketData: pass
        ^~~~~~~~~~~~~~~~~~~~~~
tests\controllers\test_controller.py:274:1: error: Name "TestTradingController"
already defined on line 52  [no-redef]
    class TestTradingController:
    ^
tests\controllers\test_base_controller.py:7:5: error: Module
"domain.entities.models" has no attribute "SystemState"  [attr-defined]
        from domain.entities.models import SystemState
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\controllers\test_base_controller.py:9:5: error: Name "SystemState"
already defined (possibly by an import)  [no-redef]
        class SystemState: pass
        ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\volatility_strategy.py:59:45: error: Incompatible
types in assignment (expression has type "VolatilityConfig", base class
"BaseStrategy" defined the type as "dict[str, Any]")  [assignment]
                self.config: VolatilityConfig = config
                                                ^~~~~~
infrastructure\strategies\volatility_strategy.py:62:13: error: Attribute
"config" already defined on line 59  [no-redef]
                self.config: VolatilityConfig = VolatilityConfig(**config)
                ^~~~~~~~~~~
infrastructure\strategies\volatility_strategy.py:65:13: error: Attribute
"config" already defined on line 59  [no-redef]
                self.config: VolatilityConfig = VolatilityConfig()
                ^~~~~~~~~~~
infrastructure\strategies\volatility_strategy.py:293:46: error: Unsupported
operand types for * ("None" and "float")  [operator]
                                current_price >= self.take_profit * level
                                                 ^
infrastructure\strategies\volatility_strategy.py:293:46: note: Left operand is of type "float | None"
infrastructure\strategies\volatility_strategy.py:325:46: error: Unsupported
operand types for * ("None" and "float")  [operator]
                                current_price <= self.take_profit * level
                                                 ^
infrastructure\strategies\volatility_strategy.py:325:46: note: Left operand is of type "float | None"
infrastructure\strategies\volatility_strategy.py:399:26: error: No overload
variant matches argument types "DataFrame", "int"  [call-overload]
                true_range = np.max(ranges, axis=1)
                             ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\volatility_strategy.py:399:26: note: Possible overload variants:
infrastructure\strategies\volatility_strategy.py:399:26: note:     def [_SCT: generic] amax(a: _SupportsArray[dtype[_SCT]] | _NestedSequence[_SupportsArray[dtype[_SCT]]], axis: None = ..., out: None = ..., keepdims: Literal[False] = ..., initial: int | float | complex | number[Any] | bool_ = ..., where: _SupportsArray[dtype[bool_]] | _NestedSequence[_SupportsArray[dtype[bool_]]] | bool | _NestedSequence[bool] = ...) -> _SCT
infrastructure\strategies\volatility_strategy.py:399:26: note:     def amax(a: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: None = ..., keepdims: bool = ..., initial: int | float | complex | number[Any] | bool_ = ..., where: _SupportsArray[dtype[bool_]] | _NestedSequence[_SupportsArray[dtype[bool_]]] | bool | _NestedSequence[bool] = ...) -> Any
infrastructure\strategies\volatility_strategy.py:399:26: note:     def [_ArrayType: ndarray[Any, dtype[Any]]] amax(a: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: _ArrayType = ..., keepdims: bool = ..., initial: int | float | complex | number[Any] | bool_ = ..., where: _SupportsArray[dtype[bool_]] | _NestedSequence[_SupportsArray[dtype[bool_]]] | bool | _NestedSequence[bool] = ...) -> _ArrayType
infrastructure\strategies\statistical_arbitrage_strategy.py:564:16: error:
Unsupported operand types for >= ("int" and "None")  [operator]
                if signal.volume <= 0:
                   ^
infrastructure\strategies\statistical_arbitrage_strategy.py:564:16: note: Left operand is of type "float | None"
infrastructure\strategies\statistical_arbitrage_strategy.py:640:26: error:
"Series" has no attribute "shift"  [attr-defined]
                spread_lag = spread.shift(1)
                             ^~~~~~~~~~~~
infrastructure\strategies\statistical_arbitrage_strategy.py:936:52: error:
Argument 1 has incompatible type "list[dict[str, Any]]"; expected
"_SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes]"
 [arg-type]
    ...              param_grid = list(np.random.choice(param_grid, 1000, rep...
                                                        ^~~~~~~~~~
infrastructure\strategies\statistical_arbitrage_strategy.py:1059:20: error:
"Series" has no attribute "ewm"  [attr-defined]
                mean = returns.ewm(span=window, adjust=False).mean()
                       ^~~~~~~~~~~
infrastructure\strategies\statistical_arbitrage_strategy.py:1060:19: error:
"Series" has no attribute "ewm"  [attr-defined]
                std = returns.ewm(span=window, adjust=False).std()
                      ^~~~~~~~~~~
infrastructure\strategies\statistical_arbitrage_strategy.py:1062:28: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                z_score = abs((returns.iloc[-1] - mean.iloc[-1]) / std.ilo...
                               ^~~~~~~~~~~~~~~~
infrastructure\strategies\statistical_arbitrage_strategy.py:1083:27: error:
"Series" has no attribute "rolling"  [attr-defined]
                correlation = returns.rolling(window=window).corr(returns....
                              ^~~~~~~~~~~~~~~
infrastructure\strategies\statistical_arbitrage_strategy.py:1083:63: error:
"Series" has no attribute "shift"  [attr-defined]
    ...   correlation = returns.rolling(window=window).corr(returns.shift(1))
                                                            ^~~~~~~~~~~~~
infrastructure\strategies\statistical_arbitrage_strategy.py:1104:26: error:
"Series" has no attribute "ewm"  [attr-defined]
                volatility = returns.ewm(span=window, adjust=False).std()
                             ^~~~~~~~~~~
infrastructure\strategies\statistical_arbitrage_strategy.py:1218:26: error:
"DataFrame" has no attribute "iloc"  [attr-defined]
                    window = data.iloc[i : i + self.arb_config.lookback_pe...
                             ^~~~~~~~~
infrastructure\strategies\statistical_arbitrage_strategy.py:1249:42: error:
Unsupported operand types for > ("int" and "Series")  [operator]
                    returns.mean() / returns[returns < 0].std() * (252**0....
                                             ^
infrastructure\strategies\statistical_arbitrage_strategy.py:1250:32: error:
Unsupported operand types for > ("int" and "Series")  [operator]
                    if len(returns[returns < 0]) > 0
                                   ^
infrastructure\strategies\statistical_arbitrage_strategy.py:1254:29: error:
Unsupported operand types for < ("int" and "Series")  [operator]
                    len(returns[returns > 0]) / len(returns) if len(return...
                                ^
infrastructure\strategies\sideways_strategies.py:70:45: error: "DataFrame" has
no attribute "copy"  [attr-defined]
                df = self._calculate_indicators(data.copy())
                                                ^~~~~~~~~
infrastructure\strategies\sideways_strategies.py:112:30: error:
"type[Timestamp]" has no attribute "now"  [attr-defined]
                    "timestamp": pd.Timestamp.now(),
                                 ^~~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:142:45: error: "DataFrame" has
no attribute "copy"  [attr-defined]
                df = self._calculate_indicators(data.copy())
                                                ^~~~~~~~~
infrastructure\strategies\sideways_strategies.py:143:16: error: "DataFrame" has
no attribute "shape"  [attr-defined]
                if df.shape[0] < max(self.bb_period, self.rsi_period):
                   ^~~~~~~~
infrastructure\strategies\sideways_strategies.py:168:31: error:
"type[Timestamp]" has no attribute "now"  [attr-defined]
                        timestamp=pd.Timestamp.now(),
                                  ^~~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:192:31: error:
"type[Timestamp]" has no attribute "now"  [attr-defined]
                        timestamp=pd.Timestamp.now(),
                                  ^~~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:335:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["bb_upper"] = upper
            ^~~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:336:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["bb_middle"] = middle
            ^~~~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:337:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["bb_lower"] = lower
            ^~~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:339:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["rsi"] = calculate_rsi(data["close"], self.rsi_period)
            ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:344:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["stoch_k"] = k
            ^~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:345:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["stoch_d"] = d
            ^~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:347:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["obv"] = self._calculate_obv(data["close"], data["volume"...
            ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:360:26: error: "Series" has no
attribute "rolling"  [attr-defined]
                lowest_low = low.rolling(k_period).min()
                             ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:361:28: error: "Series" has no
attribute "rolling"  [attr-defined]
                highest_high = high.rolling(k_period).max()
                               ^~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:367:56: error: "Series" has no
attribute "index"  [attr-defined]
    ...      return pd.Series([0.0] * len(close), index=close.index), pd.Seri...
                                                        ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:368:43: error: "Series" has no
attribute "index"  [attr-defined]
                    [0.0] * len(close), index=close.index
                                              ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:374:40: error: "Series" has no
attribute "index"  [attr-defined]
                obv = pd.Series(0.0, index=close.index)
                                           ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:375:13: error: Unsupported
target for indexed assignment ("Callable[[], Any]")  [index]
                obv.iloc[0] = volume.iloc[0]
                ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:375:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                obv.iloc[0] = volume.iloc[0]
                              ^~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:377:20: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    if close.iloc[i] > close.iloc[i - 1]:
                       ^~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:378:21: error: Unsupported
target for indexed assignment ("Callable[[], Any]")  [index]
                        obv.iloc[i] = obv.iloc[i - 1] + volume.iloc[i]
                        ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:378:35: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                        obv.iloc[i] = obv.iloc[i - 1] + volume.iloc[i]
                                      ^~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:379:22: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    elif close.iloc[i] < close.iloc[i - 1]:
                         ^~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:380:21: error: Unsupported
target for indexed assignment ("Callable[[], Any]")  [index]
                        obv.iloc[i] = obv.iloc[i - 1] - volume.iloc[i]
                        ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:380:35: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                        obv.iloc[i] = obv.iloc[i - 1] - volume.iloc[i]
                                      ^~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:382:21: error: Unsupported
target for indexed assignment ("Callable[[], Any]")  [index]
                        obv.iloc[i] = obv.iloc[i - 1]
                        ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:382:35: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                        obv.iloc[i] = obv.iloc[i - 1]
                                      ^~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:386:56: error: "Series" has no
attribute "index"  [attr-defined]
                return pd.Series([0.0] * len(close), index=close.index)
                                                           ^~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:406:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                atr = calculate_atr(data["high"], data["low"], data["close...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\sideways_strategies.py:410:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                rsi = calculate_rsi(data["close"], 14).iloc[-1]
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\sideways_strategies.py:474:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                atr = calculate_atr(data["high"], data["low"], data["close...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\sideways_strategies.py:478:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                rsi = calculate_rsi(data["close"], 14).iloc[-1]
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:69:27: error: Incompatible types
in assignment (expression has type "ScalpingConfig", variable has type
"dict[str, Any]")  [assignment]
                self.config = ScalpingConfig(**config)
                              ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:71:27: error: Incompatible types
in assignment (expression has type "ScalpingConfig", variable has type
"dict[str, Any]")  [assignment]
                self.config = ScalpingConfig()
                              ^~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:166:29: error: "dict[str, Any]"
has no attribute "min_volatility"  [attr-defined]
                if volatility < self.config.min_volatility:
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:169:25: error: "dict[str, Any]"
has no attribute "max_spread"  [attr-defined]
                if spread > self.config.max_spread:
                            ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:172:38: error: "dict[str, Any]"
has no attribute "min_volume"  [attr-defined]
                if liquidity["volume"] < self.config.min_volume:
                                         ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:174:37: error: "dict[str, Any]"
has no attribute "liquidity_threshold"  [attr-defined]
                if liquidity["depth"] < self.config.liquidity_threshold:
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:177:39: error: "dict[str, Any]"
has no attribute "max_position_size"  [attr-defined]
                if self.total_position >= self.config.max_position_size:
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:180:37: error: "dict[str, Any]"
has no attribute "max_daily_trades"  [attr-defined]
                if self.daily_trades >= self.config.max_daily_trades:
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:183:35: error: "dict[str, Any]"
has no attribute "max_daily_loss"  [attr-defined]
                if self.daily_pnl <= -self.config.max_daily_loss:
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:295:34: error: "dict[str, Any]"
has no attribute "price_deviation_threshold"  [attr-defined]
                if price_deviation > self.config.price_deviation_threshold...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:305:35: error: "dict[str, Any]"
has no attribute "volume_deviation_threshold"  [attr-defined]
                if volume_deviation > self.config.volume_deviation_thresho...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:310:46: error: "dict[str, Any]"
has no attribute "stop_loss"  [attr-defined]
                stop_loss = current_price * (1 - self.config.stop_loss)
                                                 ^~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:311:48: error: "dict[str, Any]"
has no attribute "take_profit"  [attr-defined]
                take_profit = current_price * (1 + self.config.take_profit...
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:322:50: error: "dict[str, Any]"
has no attribute "min_volatility"  [attr-defined]
                    confidence=min(1.0, volatility / self.config.min_volat...
                                                     ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\scalping_strategy.py:370:39: error: Cannot determine
type of "take_profit"  [has-type]
                    elif current_price >= self.take_profit:
                                          ^~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:397:39: error: Cannot determine
type of "take_profit"  [has-type]
                    elif current_price <= self.take_profit:
                                          ^~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:411:16: error: "dict[str, Any]"
has no attribute "trailing_stop"  [attr-defined]
                if self.config.trailing_stop:
                   ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:412:64: error: Cannot determine
type of "take_profit"  [has-type]
    ...      if self.position == "long" and current_price > self.take_profit:
                                                            ^~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:413:61: error: "dict[str, Any]"
has no attribute "trailing_step"  [attr-defined]
    ...         self.take_profit = current_price * (1 - self.config.trailing_...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\scalping_strategy.py:415:61: error: "dict[str, Any]"
has no attribute "trailing_step"  [attr-defined]
    ...         self.take_profit = current_price * (1 + self.config.trailing_...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\scalping_strategy.py:448:33: error: Incompatible
types in assignment (expression has type "str", variable has type "None") 
[assignment]
                    self.position = signal.direction
                                    ^~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:451:17: error: Unsupported
operand types for + ("float" and "None")  [operator]
                    self.total_position += signal.volume
                    ^
infrastructure\strategies\scalping_strategy.py:451:17: note: Right operand is of type "float | None"
infrastructure\strategies\scalping_strategy.py:452:35: error: Incompatible
types in assignment (expression has type "datetime", variable has type "None") 
[assignment]
                    self.entry_time = datetime.now()
                                      ^~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:459:50: error:
"ScalpingStrategy" has no attribute "entry_price"; maybe "entry_time"? 
[attr-defined]
                            data["close"].iloc[-1] - self.entry_price
                                                     ^~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:463:25: error:
"ScalpingStrategy" has no attribute "entry_price"; maybe "entry_time"? 
[attr-defined]
                            self.entry_price - data["close"].iloc[-1]
                            ^~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:484:25: error: "dict[str, Any]"
has no attribute "risk_per_trade"  [attr-defined]
                base_size = self.config.risk_per_trade
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\scalping_strategy.py:490:32: error: "dict[str, Any]"
has no attribute "max_position_size"  [attr-defined]
                    position_size, self.config.max_position_size - self.to...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:29:41: error: Incompatible
types in assignment (expression has type "None", variable has type
"list[float]")  [assignment]
        partial_close_levels: List[float] = None
                                            ^~~~
infrastructure\strategies\reversal_strategies.py:47:27: error: Incompatible
types in assignment (expression has type "ReversalConfig", variable has type
"dict[str, Any]")  [assignment]
                self.config = ReversalConfig(**config)
                              ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:49:27: error: Incompatible
types in assignment (expression has type "ReversalConfig", variable has type
"dict[str, Any]")  [assignment]
                self.config = ReversalConfig()
                              ^~~~~~~~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:108:17: error: "Series" has no
attribute "diff"  [attr-defined]
            delta = prices.diff()
                    ^~~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:118:16: error: "Series" has no
attribute "ewm"  [attr-defined]
            exp1 = prices.ewm(span=self.config["macd_fast"], adjust=False)...
                   ^~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:119:16: error: "Series" has no
attribute "ewm"  [attr-defined]
            exp2 = prices.ewm(span=self.config["macd_slow"], adjust=False)...
                   ^~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:133:14: error: Module has no
attribute "concat"  [attr-defined]
            tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
                 ^~~~~~~~~
infrastructure\strategies\reversal_strategies.py:161:22: error: "Series" has no
attribute "rolling"  [attr-defined]
            avg_volume = volume.rolling(window=20).mean()
                         ^~~~~~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:197:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                is_oversold = rsi.iloc[i] < self.config["rsi_oversold"]
                              ^~~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:198:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                is_overbought = rsi.iloc[i] > self.config["rsi_overbought"...
                                ^~~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:201:17: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    macd.iloc[i - 1] < signal.iloc[i - 1] and macd.iloc[i]...
                    ^~~~~~~~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:204:17: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    macd.iloc[i - 1] > signal.iloc[i - 1] and macd.iloc[i]...
                    ^~~~~~~~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:287:25: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                atr_value = atr.iloc[index]
                            ^~~~~~~~~~~~~~~
infrastructure\strategies\reversal_strategies.py:363:31: error:
"type[Timestamp]" has no attribute "now"  [attr-defined]
                        timestamp=pd.Timestamp.now(),
                                  ^~~~~~~~~~~~~~~~
infrastructure\strategies\regime_adaptive_strategy.py:97:13: error:
Incompatible types in assignment (expression has type "RegimeConfig", base class
"BaseStrategy" defined the type as "dict[str, Any]")  [assignment]
                RegimeConfig(**config) if not isinstance(config, RegimeCon...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\regime_adaptive_strategy.py:486:22: error: Module has
no attribute "concat"  [attr-defined]
                ranges = pd.concat([high_low, high_close, low_close], axis...
                         ^~~~~~~~~
infrastructure\strategies\regime_adaptive_strategy.py:567:22: error: Module has
no attribute "concat"  [attr-defined]
                ranges = pd.concat([high_low, high_close, low_close], axis...
                         ^~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:80:13: error: Incompatible
types in assignment (expression has type "RandomForestConfig", base class
"BaseStrategy" defined the type as "dict[str, Any]")  [assignment]
                RandomForestConfig(**config)
                ^
infrastructure\strategies\random_forest_strategy.py:84:26: error: Name "asdict"
is not defined  [name-defined]
            super().__init__(asdict(config))
                             ^~~~~~
infrastructure\strategies\random_forest_strategy.py:247:37: error: "DataFrame"
has no attribute "iloc"  [attr-defined]
                            "features": features.iloc[-1].to_dict(),
                                        ^~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:272:37: error: "DataFrame"
has no attribute "iloc"  [attr-defined]
                            "features": features.iloc[-1].to_dict(),
                                        ^~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:305:41: error: "DataFrame"
has no attribute "iloc"  [attr-defined]
                                "features": features.iloc[-1].to_dict(),
                                            ^~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:318:41: error: "DataFrame"
has no attribute "iloc"  [attr-defined]
                                "features": features.iloc[-1].to_dict(),
                                            ^~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:344:41: error: "DataFrame"
has no attribute "iloc"  [attr-defined]
                                "features": features.iloc[-1].to_dict(),
                                            ^~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:368:45: error: "DataFrame"
has no attribute "iloc"  [attr-defined]
                                    "features": features.iloc[-1].to_dict(...
                                                ^~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:387:45: error: "DataFrame"
has no attribute "iloc"  [attr-defined]
                                    "features": features.iloc[-1].to_dict(...
                                                ^~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:416:44: error: Argument 1
to "append" of "list" has incompatible type "float | None"; expected "float" 
[arg-type]
                    self.partial_closes.append(signal.volume)
                                               ^~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:431:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["open"] = data["open"]
                ^~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:432:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["high"] = data["high"]
                ^~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:433:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["low"] = data["low"]
                ^~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:434:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["close"] = data["close"]
                ^~~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:435:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volume"] = data["volume"]
                ^~~~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:441:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["rsi"] = 100 - (100 / (1 + rs))
                ^~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:445:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["macd"] = ema_fast - ema_slow
                ^~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:446:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["macd_signal"] = features["macd"].ewm(span=9).mea...
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:450:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["bb_upper"] = bb_middle + (bb_std * 2)
                ^~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:451:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["bb_middle"] = bb_middle
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:452:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["bb_lower"] = bb_middle - (bb_std * 2)
                ^~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:457:22: error: Module has
no attribute "concat"  [attr-defined]
                ranges = pd.concat([high_low, high_close, low_close], axis...
                         ^~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:459:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["atr"] = true_range.rolling(window=14).mean()
                ^~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:473:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["adx"] = dx.rolling(window=14).mean()
                ^~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:474:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["plus_di"] = plus_di
                ^~~~~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:475:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["minus_di"] = minus_di
                ^~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\random_forest_strategy.py:477:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[self.config.target_column] = np.where(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\parallel.py:77:37: error: "DataFrame" has no
attribute "values"  [attr-defined]
                chunks = np.array_split(data.values, len(data) // self.con...
                                        ^~~~~~~~~~~
infrastructure\strategies\parallel.py:83:20: error: Module has no attribute
"concat"  [attr-defined]
                return pd.concat(results)
                       ^~~~~~~~~
infrastructure\strategies\parallel.py:99:37: error: "DataFrame" has no
attribute "values"  [attr-defined]
                chunks = np.array_split(data.values, len(data) // self.con...
                                        ^~~~~~~~~~~
infrastructure\strategies\pairs_trading_strategy.py:100:47: error: Incompatible
types in assignment (expression has type "PairsTradingConfig", base class
"BaseStrategy" defined the type as "dict[str, Any]")  [assignment]
                self.config: PairsTradingConfig = config
                                                  ^~~~~~
infrastructure\strategies\pairs_trading_strategy.py:102:13: error: Attribute
"config" already defined on line 100  [no-redef]
                self.config: PairsTradingConfig = PairsTradingConfig(**con...
                ^~~~~~~~~~~
infrastructure\strategies\pairs_trading_strategy.py:104:13: error: Attribute
"config" already defined on line 100  [no-redef]
                self.config: PairsTradingConfig = PairsTradingConfig()
                ^~~~~~~~~~~
infrastructure\strategies\pairs_trading_strategy.py:290:20: error: "Series" has
no attribute "diff"  [attr-defined]
                diff = series.diff().dropna()
                       ^~~~~~~~~~~
infrastructure\strategies\pairs_trading_strategy.py:293:17: error: "Series" has
no attribute "shift"  [attr-defined]
                x = series.shift(1).dropna()
                    ^~~~~~~~~~~~
infrastructure\strategies\pairs_trading_strategy.py:315:20: error: "Series" has
no attribute "diff"  [attr-defined]
                diff = spread.diff().dropna()
                       ^~~~~~~~~~~
infrastructure\strategies\pairs_trading_strategy.py:318:17: error: "Series" has
no attribute "shift"  [attr-defined]
                x = spread.shift(1).dropna()
                    ^~~~~~~~~~~~
infrastructure\strategies\pairs_trading_strategy.py:649:22: error: Module has
no attribute "concat"  [attr-defined]
                ranges = pd.concat([high_low, high_close, low_close], axis...
                         ^~~~~~~~~
infrastructure\strategies\momentum_strategy.py:94:43: error: Incompatible types
in assignment (expression has type "MomentumConfig", base class "BaseStrategy"
defined the type as "dict[str, Any]")  [assignment]
                self.config: MomentumConfig = config
                                              ^~~~~~
infrastructure\strategies\momentum_strategy.py:96:13: error: Attribute "config"
already defined on line 94  [no-redef]
                self.config: MomentumConfig = MomentumConfig(**config)
                ^~~~~~~~~~~
infrastructure\strategies\momentum_strategy.py:98:13: error: Attribute "config"
already defined on line 94  [no-redef]
                self.config: MomentumConfig = MomentumConfig()
                ^~~~~~~~~~~
infrastructure\strategies\mean_reversion_strategy.py:138:48: error:
Incompatible types in assignment (expression has type "MeanReversionConfig",
base class "BaseStrategy" defined the type as "dict[str, Any]")  [assignment]
                self.config: MeanReversionConfig = config
                                                   ^~~~~~
infrastructure\strategies\mean_reversion_strategy.py:140:13: error: Attribute
"config" already defined on line 138  [no-redef]
                self.config: MeanReversionConfig = MeanReversionConfig(**c...
                ^~~~~~~~~~~
infrastructure\strategies\mean_reversion_strategy.py:142:13: error: Attribute
"config" already defined on line 138  [no-redef]
                self.config: MeanReversionConfig = MeanReversionConfig()
                ^~~~~~~~~~~
infrastructure\strategies\mean_reversion_strategy.py:375:25: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                current_z = z_score.iloc[-1]
                            ^~~~~~~~~~~~~~~~
infrastructure\strategies\martingale_strategy.py:96:45: error: Incompatible
types in assignment (expression has type "MartingaleConfig", base class
"BaseStrategy" defined the type as "dict[str, Any]")  [assignment]
                self.config: MartingaleConfig = config
                                                ^~~~~~
infrastructure\strategies\hedging_strategy.py:415:16: error: Unsupported
operand types for >= ("int" and "None")  [operator]
                if signal.volume <= 0:
                   ^
infrastructure\strategies\hedging_strategy.py:415:16: note: Left operand is of type "float | None"
infrastructure\strategies\hedging_strategy.py:613:17: error: "Series" has no
attribute "diff"  [attr-defined]
            delta = prices.diff()
                    ^~~~~~~~~~~
infrastructure\strategies\hedging_strategy.py:621:20: error: "Series" has no
attribute "ewm"  [attr-defined]
            ema_fast = prices.ewm(span=fast).mean()
                       ^~~~~~~~~~
infrastructure\strategies\hedging_strategy.py:622:20: error: "Series" has no
attribute "ewm"  [attr-defined]
            ema_slow = prices.ewm(span=slow).mean()
                       ^~~~~~~~~~
infrastructure\strategies\hedging_strategy.py:629:15: error: "Series" has no
attribute "rolling"  [attr-defined]
            sma = prices.rolling(window=period).mean()
                  ^~~~~~~~~~~~~~
infrastructure\strategies\hedging_strategy.py:630:15: error: "Series" has no
attribute "rolling"  [attr-defined]
            std = prices.rolling(window=period).std()
                  ^~~~~~~~~~~~~~
infrastructure\strategies\hedging_strategy.py:639:22: error: Module has no
attribute "concat"  [attr-defined]
            true_range = pd.concat([high_low, high_close, low_close], axis...
                         ^~~~~~~~~
infrastructure\strategies\hedging_strategy.py:648:22: error: Module has no
attribute "concat"  [attr-defined]
            true_range = pd.concat([high_low, high_close, low_close], axis...
                         ^~~~~~~~~
infrastructure\strategies\hedging_strategy.py:654:19: error: "Series" has no
attribute "rolling"  [attr-defined]
            plus_di = pd.Series(plus_dm, index=data.index).rolling(window=...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\hedging_strategy.py:655:20: error: "Series" has no
attribute "rolling"  [attr-defined]
            minus_di = pd.Series(minus_dm, index=data.index).rolling(windo...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\hedging_strategy.py:657:15: error: "Series" has no
attribute "rolling"  [attr-defined]
            adx = pd.Series(dx, index=data.index).rolling(window=period).m...
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\grid_strategy.py:93:39: error: Incompatible types in
assignment (expression has type "GridConfig", base class "BaseStrategy" defined
the type as "dict[str, Any]")  [assignment]
                self.config: GridConfig = config
                                          ^~~~~~
infrastructure\strategies\grid_strategy.py:95:13: error: Attribute "config"
already defined on line 93  [no-redef]
                self.config: GridConfig = GridConfig(**config)
                ^~~~~~~~~~~
infrastructure\strategies\grid_strategy.py:97:13: error: Attribute "config"
already defined on line 93  [no-redef]
                self.config: GridConfig = GridConfig()
                ^~~~~~~~~~~
infrastructure\strategies\grid_strategy.py:483:17: error: Unsupported operand
types for + ("float" and "None")  [operator]
                    self.total_position += signal.volume
                    ^
infrastructure\strategies\grid_strategy.py:483:17: note: Right operand is of type "float | None"
infrastructure\strategies\deep_learning_strategy.py:110:47: error: Incompatible
types in assignment (expression has type "DeepLearningConfig", base class
"BaseStrategy" defined the type as "dict[str, Any]")  [assignment]
                self.config: DeepLearningConfig = config
                                                  ^~~~~~
infrastructure\strategies\deep_learning_strategy.py:112:13: error: Attribute
"config" already defined on line 110  [no-redef]
                self.config: DeepLearningConfig = DeepLearningConfig(**con...
                ^~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:114:13: error: Attribute
"config" already defined on line 110  [no-redef]
                self.config: DeepLearningConfig = DeepLearningConfig()
                ^~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:253:24: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "rsi": rsi.iloc[-1],
                           ^~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:254:25: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "macd": macd.iloc[-1],
                            ^~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:255:32: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "macd_signal": signal.iloc[-1],
                                   ^~~~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:256:30: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "macd_hist": hist.iloc[-1],
                                 ^~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:258:46: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                        data["close"].iloc[-1] - lower_band.iloc[-1]
                                                 ^~~~~~~~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:259:22: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    ) / (upper_band.iloc[-1] - lower_band.iloc[-1]),
                         ^~~~~~~~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:260:24: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "atr": atr.iloc[-1],
                           ^~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:339:26: error: Module has
no attribute "concat"  [attr-defined]
                true_range = pd.concat([high_low, high_close, low_close], ...
                             ^~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:616:31: error: "DataFrame"
has no attribute "iloc"  [attr-defined]
                    window_data = data.iloc[i : i + self.config.sequence_l...
                                  ^~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:648:24: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "rsi": rsi.iloc[-1] if len(rsi) > 0 else 50.0,
                           ^~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:649:25: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "macd": macd.iloc[-1] if len(macd) > 0 else 0.0,
                            ^~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:650:32: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "macd_signal": signal.iloc[-1] if len(signal) > 0 else...
                                   ^~~~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:651:30: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "macd_hist": hist.iloc[-1] if len(hist) > 0 else 0.0,
                                 ^~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:652:36: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "bollinger_upper": upper_band.iloc[-1] if len(upper_ba...
                                       ^~~~~~~~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:653:36: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "bollinger_lower": lower_band.iloc[-1] if len(lower_ba...
                                       ^~~~~~~~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:654:24: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "atr": atr.iloc[-1] if len(atr) > 0 else 0.0,
                           ^~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:762:31: error: "DataFrame"
has no attribute "iloc"  [attr-defined]
                    window_data = data.iloc[i : i + self.config.sequence_l...
                                  ^~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:773:22: error: Module has
no attribute "get_dummies"  [attr-defined]
                target = pd.get_dummies((future_returns > 0).astype(int))
                         ^~~~~~~~~~~~~~
infrastructure\strategies\deep_learning_strategy.py:775:31: error: "DataFrame"
has no attribute "isna"  [attr-defined]
                valid_indices = ~(features_df.isna().any(axis=1) | target....
                                  ^~~~~~~~~~~~~~~~
infrastructure\strategies\consolidated_strategy.py:365:39: error: Incompatible
types in assignment (expression has type "StrategyConfig", base class
"BaseStrategy" defined the type as "dict[str, Any]")  [assignment]
            self.config: StrategyConfig = config
                                          ^~~~~~
infrastructure\strategies\breakout_strategy.py:91:43: error: Incompatible types
in assignment (expression has type "BreakoutConfig", base class "BaseStrategy"
defined the type as "dict[str, Any]")  [assignment]
                self.config: BreakoutConfig = config
                                              ^~~~~~
infrastructure\strategies\breakout_strategy.py:93:13: error: Attribute "config"
already defined on line 91  [no-redef]
                self.config: BreakoutConfig = BreakoutConfig(**config)
                ^~~~~~~~~~~
infrastructure\strategies\breakout_strategy.py:95:13: error: Attribute "config"
already defined on line 91  [no-redef]
                self.config: BreakoutConfig = BreakoutConfig()
                ^~~~~~~~~~~
infrastructure\strategies\arbitrage_strategy.py:65:44: error: Incompatible
types in assignment (expression has type "ArbitrageConfig", base class
"BaseStrategy" defined the type as "dict[str, Any]")  [assignment]
                self.config: ArbitrageConfig = config
                                               ^~~~~~
infrastructure\strategies\arbitrage_strategy.py:67:13: error: Attribute
"config" already defined on line 65  [no-redef]
                self.config: ArbitrageConfig = ArbitrageConfig(**config)
                ^~~~~~~~~~~
infrastructure\strategies\arbitrage_strategy.py:69:13: error: Attribute
"config" already defined on line 65  [no-redef]
                self.config: ArbitrageConfig = ArbitrageConfig()
                ^~~~~~~~~~~
infrastructure\strategies\arbitrage_strategy.py:229:17: error: "Series" has no
attribute "rolling"  [attr-defined]
                    pd.Series(spread).rolling(window=self.config.spread_wi...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\arbitrage_strategy.py:232:17: error: "Series" has no
attribute "rolling"  [attr-defined]
                    pd.Series(spread).rolling(window=self.config.spread_wi...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\performance_tracker.py:114:47: error:
Argument 1 to "float" has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                rankings.sort(key=lambda x: float(x["avg_performance"]), r...
                                                  ^~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\performance_tracker.py:175:13: error:
"DataFrame" has no attribute "to_csv"  [attr-defined]
                df.to_csv(filepath, index=False)
                ^~~~~~~~~
infrastructure\sessions\session_predictor.py:58:45: error: "DataFrame" has no
attribute "copy"  [attr-defined]
                self._historical_data[symbol] = market_data.copy()
                                                ^~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:65:8: error: "Series" has
no attribute "isna"  [attr-defined]
        if data.isna().all():
           ^~~~~~~~~
infrastructure\services\technical_analysis\utils.py:68:8: error: No overload
variant of "__call__" of "_UFunc_Nin1_Nout1" matches argument type "Series" 
[call-overload]
        if np.isinf(data).any():
           ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:68:8: note: Possible overload variants:
infrastructure\services\technical_analysis\utils.py:68:8: note:     def __call__(self, int | float | complex | str | bytes | generic, /, out: None = ..., *, where: _SupportsArray[dtype[bool_]] | _NestedSequence[_SupportsArray[dtype[bool_]]] | bool | _NestedSequence[bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: dtype[Any] | type[Any] | _SupportsDType[dtype[Any]] | str | tuple[Any, int] | tuple[Any, SupportsIndex | Sequence[SupportsIndex]] | list[Any] | _DTypeDict | tuple[Any, Any] | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None] = ..., extobj: list[Any] = ...) -> Any
infrastructure\services\technical_analysis\utils.py:68:8: note:     def __call__(self, _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], /, out: ndarray[Any, dtype[Any]] | tuple[ndarray[Any, dtype[Any]]] | None = ..., *, where: _SupportsArray[dtype[bool_]] | _NestedSequence[_SupportsArray[dtype[bool_]]] | bool | _NestedSequence[bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: dtype[Any] | type[Any] | _SupportsDType[dtype[Any]] | str | tuple[Any, int] | tuple[Any, SupportsIndex | Sequence[SupportsIndex]] | list[Any] | _DTypeDict | tuple[Any, Any] | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None] = ..., extobj: list[Any] = ...) -> ndarray[Any, dtype[Any]]
infrastructure\services\technical_analysis\utils.py:68:8: note:     def __call__(self, _SupportsArrayUFunc, /, out: ndarray[Any, dtype[Any]] | tuple[ndarray[Any, dtype[Any]]] | None = ..., *, where: _SupportsArray[dtype[bool_]] | _NestedSequence[_SupportsArray[dtype[bool_]]] | bool | _NestedSequence[bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: dtype[Any] | type[Any] | _SupportsDType[dtype[Any]] | str | tuple[Any, int] | tuple[Any, SupportsIndex | Sequence[SupportsIndex]] | list[Any] | _DTypeDict | tuple[Any, Any] | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None] = ..., extobj: list[Any] = ...) -> Any
infrastructure\services\technical_analysis\utils.py:219:20: error: Incompatible
return value type (got "float", expected "Series")  [return-value]
                return (data - min_val) / (max_val - min_val)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:219:21: error: Unsupported
operand types for - ("Series" and "float")  [operator]
                return (data - min_val) / (max_val - min_val)
                        ^
infrastructure\services\technical_analysis\utils.py:226:20: error: Incompatible
return value type (got "float", expected "Series")  [return-value]
                return (data - mean_val) / std_val
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:226:21: error: Unsupported
operand types for - ("Series" and "float")  [operator]
                return (data - mean_val) / std_val
                        ^
infrastructure\services\technical_analysis\utils.py:238:16: error: "DataFrame"
has no attribute "dropna"  [attr-defined]
        clean_df = returns_df.dropna()
                   ^~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:255:14: error: "Series" has
no attribute "quantile"  [attr-defined]
            q1 = data.quantile(0.25)
                 ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:256:14: error: "Series" has
no attribute "quantile"  [attr-defined]
            q3 = data.quantile(0.75)
                 ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:261:64: error: "Series" has
no attribute "index"  [attr-defined]
    ...         (data < lower_bound) | (data > upper_bound), index=data.index
                                                                   ^~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:264:28: error: Unsupported
operand types for - ("Series" and "float")  [operator]
            z_scores = np.abs((data - data.mean()) / data.std())
                               ^
infrastructure\services\technical_analysis\utils.py:267:43: error: "Series" has
no attribute "index"  [attr-defined]
            outliers = pd.Series(False, index=data.index)
                                              ^~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:276:16: error: "Series" has
no attribute "rolling"  [attr-defined]
            return data.rolling(window=window).mean()
                   ^~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:278:16: error: "Series" has
no attribute "ewm"  [attr-defined]
            return data.ewm(span=window).mean()
                   ^~~~~~~~
infrastructure\services\technical_analysis\utils.py:280:16: error: "Series" has
no attribute "rolling"  [attr-defined]
            return data.rolling(window=window).median()
                   ^~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:292:18: error: "Series" has
no attribute "rolling"  [attr-defined]
        volatility = returns.rolling(window=window).std() * np.sqrt(annual...
                     ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:300:19: error: "Series" has
no attribute "expanding"  [attr-defined]
        rolling_max = data.expanding().max()
                      ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:317:22: error: Unsupported
operand types for - ("Series" and "float")  [operator]
        excess_returns = returns - risk_free_rate / periods_per_year
                         ^
infrastructure\services\technical_analysis\utils.py:318:18: error: "float" has
no attribute "mean"  [attr-defined]
        return float(excess_returns.mean() / returns.std() * np.sqrt(perio...
                     ^~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:327:22: error: Unsupported
operand types for - ("Series" and "float")  [operator]
        excess_returns = returns - risk_free_rate / periods_per_year
                         ^
infrastructure\services\technical_analysis\utils.py:328:32: error: Unsupported
operand types for > ("int" and "Series")  [operator]
        downside_returns = returns[returns < 0]
                                   ^
infrastructure\services\technical_analysis\utils.py:334:18: error: "float" has
no attribute "mean"  [attr-defined]
        return float(excess_returns.mean() / downside_deviation * np.sqrt(...
                     ^~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:343:43: error: "Series" has
no attribute "cumsum"  [attr-defined]
        max_drawdown = calculate_max_drawdown(returns.cumsum())
                                              ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:357:20: error: "Series" has
no attribute "index"  [attr-defined]
        common_index = returns.index.intersection(benchmark_returns.index)
                       ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:360:23: error: "Series" has
no attribute "loc"; maybe "iloc"?  [attr-defined]
        returns_aligned = returns.loc[common_index]
                          ^~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:361:25: error: "Series" has
no attribute "loc"; maybe "iloc"?  [attr-defined]
        benchmark_aligned = benchmark_returns.loc[common_index]
                            ^~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:374:20: error: "Series" has
no attribute "index"  [attr-defined]
        common_index = returns.index.intersection(market_returns.index)
                       ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:377:23: error: "Series" has
no attribute "loc"; maybe "iloc"?  [attr-defined]
        returns_aligned = returns.loc[common_index]
                          ^~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:378:22: error: "Series" has
no attribute "loc"; maybe "iloc"?  [attr-defined]
        market_aligned = market_returns.loc[common_index]
                         ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:394:20: error: "Series" has
no attribute "index"  [attr-defined]
        common_index = returns.index.intersection(market_returns.index)
                       ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:397:23: error: "Series" has
no attribute "loc"; maybe "iloc"?  [attr-defined]
        returns_aligned = returns.loc[common_index]
                          ^~~~~~~~~~~
infrastructure\services\technical_analysis\utils.py:398:22: error: "Series" has
no attribute "loc"; maybe "iloc"?  [attr-defined]
        market_aligned = market_returns.loc[common_index]
                         ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:59:17: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                    macd_line.iloc[-2] < signal_line.iloc[-2]
                    ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:60:21: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                    and macd_line.iloc[-1] > signal_line.iloc[-1]
                        ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:67:49: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                            price=Decimal(str(float(close.iloc[-1]))),
                                                    ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:68:35: error:
"Series" has no attribute "index"  [attr-defined]
                            timestamp=close.index[-1],
                                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:75:17: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                    macd_line.iloc[-2] > signal_line.iloc[-2]
                    ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:76:21: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                    and macd_line.iloc[-1] < signal_line.iloc[-1]
                        ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:83:49: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                            price=Decimal(str(float(close.iloc[-1]))),
                                                    ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:84:35: error:
"Series" has no attribute "index"  [attr-defined]
                            timestamp=close.index[-1],
                                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:95:16: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                if adx.iloc[-1] > 25:
                   ^~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:96:20: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                    if di_plus.iloc[-1] > di_minus.iloc[-1]:
                       ^~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:102:53: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                                price=Decimal(str(float(close.iloc[-1]))),
                                                        ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:103:39: error:
"Series" has no attribute "index"  [attr-defined]
                                timestamp=close.index[-1],
                                          ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:114:53: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                                price=Decimal(str(float(close.iloc[-1]))),
                                                        ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:115:39: error:
"Series" has no attribute "index"  [attr-defined]
                                timestamp=close.index[-1],
                                          ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:125:12: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            if sma_20.iloc[-2] < sma_50.iloc[-2] and sma_20.iloc[-1] > sma...
               ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:131:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:132:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:138:14: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            elif sma_20.iloc[-2] > sma_50.iloc[-2] and sma_20.iloc[-1] < s...
                 ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:144:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:145:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:165:12: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            if rsi.iloc[-1] < 30:
               ^~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:171:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:172:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:178:14: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            elif rsi.iloc[-1] > 70:
                 ^~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:184:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:185:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:196:16: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                if k_percent.iloc[-1] < 20 and d_percent.iloc[-1] < 20:
                   ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:202:49: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                            price=Decimal(str(float(close.iloc[-1]))),
                                                    ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:203:35: error:
"Series" has no attribute "index"  [attr-defined]
                            timestamp=close.index[-1],
                                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:209:18: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                elif k_percent.iloc[-1] > 80 and d_percent.iloc[-1] > 80:
                     ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:215:49: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                            price=Decimal(str(float(close.iloc[-1]))),
                                                    ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:216:35: error:
"Series" has no attribute "index"  [attr-defined]
                            timestamp=close.index[-1],
                                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:224:12: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            if williams_r.iloc[-1] < -80:
               ^~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:230:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:231:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:236:14: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            elif williams_r.iloc[-1] > -20:
                 ^~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:242:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:243:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:265:16: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                if close.iloc[-1] > upper_band.iloc[-1]:
                   ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:271:49: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                            price=Decimal(str(float(close.iloc[-1]))),
                                                    ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:272:35: error:
"Series" has no attribute "index"  [attr-defined]
                            timestamp=close.index[-1],
                                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:278:18: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                elif close.iloc[-1] < lower_band.iloc[-1]:
                     ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:284:49: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                            price=Decimal(str(float(close.iloc[-1]))),
                                                    ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:285:35: error:
"Series" has no attribute "index"  [attr-defined]
                            timestamp=close.index[-1],
                                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:295:16: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                if close.iloc[-1] > kc_upper.iloc[-1]:
                   ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:301:49: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                            price=Decimal(str(float(close.iloc[-1]))),
                                                    ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:302:35: error:
"Series" has no attribute "index"  [attr-defined]
                            timestamp=close.index[-1],
                                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:307:18: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                elif close.iloc[-1] < kc_lower.iloc[-1]:
                     ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:313:49: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                            price=Decimal(str(float(close.iloc[-1]))),
                                                    ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:314:35: error:
"Series" has no attribute "index"  [attr-defined]
                            timestamp=close.index[-1],
                                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:340:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:341:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:352:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:353:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:370:49: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                            price=Decimal(str(float(close.iloc[-1]))),
                                                    ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:371:35: error:
"Series" has no attribute "index"  [attr-defined]
                            timestamp=close.index[-1],
                                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:382:49: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                            price=Decimal(str(float(close.iloc[-1]))),
                                                    ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:383:35: error:
"Series" has no attribute "index"  [attr-defined]
                            timestamp=close.index[-1],
                                      ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:405:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:406:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:417:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:418:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:429:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:430:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:441:45: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        price=Decimal(str(float(close.iloc[-1]))),
                                                ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:442:31: error:
"Series" has no attribute "index"  [attr-defined]
                        timestamp=close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\signal_generation.py:514:15: error:
Argument "price" to "TradingSignal" has incompatible type "Decimal | float";
expected "Decimal"  [arg-type]
            price=avg_price,
                  ^~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:53:13: error:
"Series" has no attribute "rolling"  [attr-defined]
        highs = high.rolling(window=window, center=True).max()
                ^~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:54:12: error:
"Series" has no attribute "rolling"  [attr-defined]
        lows = low.rolling(window=window, center=True).min()
               ^~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:56:35: error:
"Series" has no attribute "index"  [attr-defined]
        swing_highs = pd.Series(index=high.index, dtype=float)
                                      ^~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:57:34: error:
"Series" has no attribute "index"  [attr-defined]
        swing_lows = pd.Series(index=low.index, dtype=float)
                                     ^~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:59:12: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            if high.iloc[i] == highs.iloc[i]:
               ^~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:60:13: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                swing_highs.iloc[i] = high.iloc[i]
                ^~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:60:35: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                swing_highs.iloc[i] = high.iloc[i]
                                      ^~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:61:12: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            if low.iloc[i] == lows.iloc[i]:
               ^~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:62:13: error:
Unsupported target for indexed assignment ("Callable[[], Any]")  [index]
                swing_lows.iloc[i] = low.iloc[i]
                ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:62:34: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                swing_lows.iloc[i] = low.iloc[i]
                                     ^~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:113:21: error:
"Series" has no attribute "sort_values"  [attr-defined]
        sorted_prices = price_series.sort_values()
                        ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:154:8: error:
Value of type "Callable[[], Any]" is not indexable  [index]
        if sma_short.iloc[-1] > sma_long.iloc[-1]:
           ^~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:160:20: error:
"Series" has no attribute "tail"  [attr-defined]
        recent_highs = swing_highs.dropna().tail(3)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:161:19: error:
"Series" has no attribute "tail"  [attr-defined]
        recent_lows = swing_lows.dropna().tail(3)
                      ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:179:12: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            if adx.iloc[-1] > 25:  # —ильный тренд
               ^~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:180:16: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                if di_plus.iloc[-1] > di_minus.iloc[-1]:
                   ^~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:207:23: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            start_price = swing_lows.dropna().iloc[-1]
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:208:21: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            end_price = swing_highs.dropna().iloc[-1]
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:211:23: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            start_price = swing_highs.dropna().iloc[-1]
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:212:21: error:
Value of type "Callable[[], Any]" is not indexable  [index]
            end_price = swing_lows.dropna().iloc[-1]
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:270:20: error:
"Series" has no attribute "tail"  [attr-defined]
        recent_highs = swing_highs.dropna().tail(5)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:280:24: error:
"Series" has no attribute "loc"; maybe "iloc"?  [attr-defined]
            valley_price = low.loc[valley_idx : recent_highs.index[-1]].mi...
                           ^~~~~~~
infrastructure\services\technical_analysis\market_structure.py:298:19: error:
"Series" has no attribute "tail"  [attr-defined]
        recent_lows = swing_lows.dropna().tail(5)
                      ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:308:22: error:
"Series" has no attribute "loc"; maybe "iloc"?  [attr-defined]
            peak_price = high.loc[peak_idx : recent_lows.index[-1]].max()
                         ^~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:326:20: error:
"Series" has no attribute "tail"  [attr-defined]
        recent_highs = swing_highs.dropna().tail(7)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:343:30: error:
"Series" has no attribute "loc"; maybe "iloc"?  [attr-defined]
                neckline_start = low.loc[peak_indices[-5]]
                                 ^~~~~~~
infrastructure\services\technical_analysis\market_structure.py:344:28: error:
"Series" has no attribute "loc"; maybe "iloc"?  [attr-defined]
                neckline_end = low.loc[peak_indices[-1]]
                               ^~~~~~~
infrastructure\services\technical_analysis\market_structure.py:363:19: error:
"Series" has no attribute "tail"  [attr-defined]
        recent_lows = swing_lows.dropna().tail(7)
                      ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:380:30: error:
"Series" has no attribute "loc"; maybe "iloc"?  [attr-defined]
                neckline_start = high.loc[bottom_indices[-5]]
                                 ^~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:381:28: error:
"Series" has no attribute "loc"; maybe "iloc"?  [attr-defined]
                neckline_end = high.loc[bottom_indices[-1]]
                               ^~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:401:20: error:
"Series" has no attribute "tail"  [attr-defined]
        recent_highs = high.tail(20)
                       ^~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:402:19: error:
"Series" has no attribute "tail"  [attr-defined]
        recent_lows = low.tail(20)
                      ^~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:449:12: error:
Argument 1 to "len" has incompatible type "Index"; expected "Sized"  [arg-type]
        if len(x) < 2:
               ^
infrastructure\services\technical_analysis\market_structure.py:451:31: error:
Argument 1 to "len" has incompatible type "Index"; expected "Sized"  [arg-type]
        x_numeric = np.arange(len(x))
                                  ^
infrastructure\services\technical_analysis\market_structure.py:462:20: error:
"Series" has no attribute "tail"  [attr-defined]
        recent_highs = high.tail(15)
                       ^~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:463:19: error:
"Series" has no attribute "tail"  [attr-defined]
        recent_lows = low.tail(15)
                      ^~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:505:21: error:
Value of type "Callable[[], Any]" is not indexable  [index]
        current_price = close.iloc[-1]
                        ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:506:22: error:
Value of type "Callable[[], Any]" is not indexable  [index]
        current_volume = volume.iloc[-1] if volume is not None else None
                         ^~~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:520:34: error:
"Series" has no attribute "index"  [attr-defined]
                        "timestamp": close.index[-1],
                                     ^~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:536:34: error:
"Series" has no attribute "index"  [attr-defined]
                        "timestamp": close.index[-1],
                                     ^~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:551:17: error:
Value of type "Callable[[], Any]" is not indexable  [index]
        prev_high = high.iloc[-2]
                    ^~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:552:16: error:
Value of type "Callable[[], Any]" is not indexable  [index]
        prev_low = low.iloc[-2]
                   ^~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:553:18: error:
Value of type "Callable[[], Any]" is not indexable  [index]
        prev_close = close.iloc[-2]
                     ^~~~~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:578:24: error:
Unsupported left operand type for / ("Series")  [operator]
            atr_percent = (atr / close) * 100
                           ^~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:590:33: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        zone_high = high.iloc[consolidation_start:consolid...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis\market_structure.py:591:32: error:
Value of type "Callable[[], Any]" is not indexable  [index]
                        zone_low = low.iloc[consolidation_start:consolidat...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis\market_structure.py:640:31: error:
"Series" has no attribute "index"  [attr-defined]
            "analysis_timestamp": close.index[-1],
                                  ^~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:697:30: error:
"Series" has no attribute "index"  [attr-defined]
                    "timestamp": price.index[-1],
                                 ^~~~~~~~~~~
infrastructure\services\technical_analysis\market_structure.py:708:30: error:
"Series" has no attribute "index"  [attr-defined]
                    "timestamp": price.index[-1],
                                 ^~~~~~~~~~~
infrastructure\services\risk_analysis\utils.py:36:8: error: "Series" has no
attribute "isna"  [attr-defined]
        if returns.isna().all():
           ^~~~~~~~~~~~
infrastructure\services\risk_analysis\utils.py:39:8: error: No overload variant
of "__call__" of "_UFunc_Nin1_Nout1" matches argument type "Series" 
[call-overload]
        if np.isinf(returns).any():
           ^~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\utils.py:39:8: note: Possible overload variants:
infrastructure\services\risk_analysis\utils.py:39:8: note:     def __call__(self, int | float | complex | str | bytes | generic, /, out: None = ..., *, where: _SupportsArray[dtype[bool_]] | _NestedSequence[_SupportsArray[dtype[bool_]]] | bool | _NestedSequence[bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: dtype[Any] | type[Any] | _SupportsDType[dtype[Any]] | str | tuple[Any, int] | tuple[Any, SupportsIndex | Sequence[SupportsIndex]] | list[Any] | _DTypeDict | tuple[Any, Any] | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None] = ..., extobj: list[Any] = ...) -> Any
infrastructure\services\risk_analysis\utils.py:39:8: note:     def __call__(self, _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], /, out: ndarray[Any, dtype[Any]] | tuple[ndarray[Any, dtype[Any]]] | None = ..., *, where: _SupportsArray[dtype[bool_]] | _NestedSequence[_SupportsArray[dtype[bool_]]] | bool | _NestedSequence[bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: dtype[Any] | type[Any] | _SupportsDType[dtype[Any]] | str | tuple[Any, int] | tuple[Any, SupportsIndex | Sequence[SupportsIndex]] | list[Any] | _DTypeDict | tuple[Any, Any] | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None] = ..., extobj: list[Any] = ...) -> ndarray[Any, dtype[Any]]
infrastructure\services\risk_analysis\utils.py:39:8: note:     def __call__(self, _SupportsArrayUFunc, /, out: ndarray[Any, dtype[Any]] | tuple[ndarray[Any, dtype[Any]]] | None = ..., *, where: _SupportsArray[dtype[bool_]] | _NestedSequence[_SupportsArray[dtype[bool_]]] | bool | _NestedSequence[bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: dtype[Any] | type[Any] | _SupportsDType[dtype[Any]] | str | tuple[Any, int] | tuple[Any, SupportsIndex | Sequence[SupportsIndex]] | list[Any] | _DTypeDict | tuple[Any, Any] | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None] = ..., extobj: list[Any] = ...) -> Any
infrastructure\services\risk_analysis\utils.py:204:12: error: "DataFrame" has
no attribute "mean"  [attr-defined]
        return returns_df.mean(axis=1)
               ^~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\stress_testing.py:120:68: error:
"Decimal" has no attribute "value"  [attr-defined]
    ...(position, 'contribution_to_portfolio_risk') and position.contribution...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\risk_analysis\stress_testing.py:122:17: error: "object"
has no attribute "append"  [attr-defined]
                    impact['affected_positions'].append(position.symbol)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\stress_testing.py:125:8: error: "object"
has no attribute "value"  [attr-defined]
        if impact['portfolio_value_change'].value < 0:
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\stress_testing.py:127:33: error: "object"
has no attribute "value"  [attr-defined]
            recovery_days = int(abs(impact['portfolio_value_change'].value...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:115:26: error: Module has no
attribute "date_range"  [attr-defined]
                timestamps = pd.date_range(start=start_time, end=end_time,...
                             ^~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:161:18: error: "DataFrame" has no
attribute "copy"  [attr-defined]
                df = data.copy()
                     ^~~~~~~~~
infrastructure\ml_services\dataset_manager.py:179:18: error: "DataFrame" has no
attribute "dropna"  [attr-defined]
                df = df.dropna()
                     ^~~~~~~~~
infrastructure\ml_services\dataset_manager.py:195:27: error: "DataFrame" has no
attribute "select_dtypes"  [attr-defined]
            numeric_columns = df.select_dtypes(include=[np.number]).column...
                              ^~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:198:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    df[col] = df[col].fillna(df[col].mean())
                    ^~~~~~~
infrastructure\ml_services\dataset_manager.py:204:31: error: "DataFrame" has no
attribute "select_dtypes"  [attr-defined]
                numeric_columns = df.select_dtypes(include=[np.number]).co...
                                  ^~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:212:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    df[col] = df[col].clip(lower=lower_bound, upper=upper_...
                    ^~~~~~~
infrastructure\ml_services\dataset_manager.py:228:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df["rsi"] = 100 - (100 / (1 + rs))
            ^~~~~~~~~
infrastructure\ml_services\dataset_manager.py:233:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                df[f"bb_upper_{window}"] = sma + (std * 2)
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:234:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                df[f"bb_lower_{window}"] = sma - (std * 2)
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:238:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df["macd"] = ema12 - ema26
            ^~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:242:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df["volume_ratio"] = df["volume"] / df["volume_sma"]
            ^~~~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:249:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df[self.preprocessing_config["target_column"]] = (
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:266:27: error: "DataFrame" has no
attribute "select_dtypes"  [attr-defined]
            numeric_columns = df.select_dtypes(include=[np.number]).column...
                              ^~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:276:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                df["hour"] = df.index.hour
                ^~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:276:26: error: "DatetimeIndex"
has no attribute "hour"  [attr-defined]
                df["hour"] = df.index.hour
                             ^~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:277:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                df["day_of_week"] = df.index.dayofweek
                ^~~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:277:33: error: "DatetimeIndex"
has no attribute "dayofweek"  [attr-defined]
                df["day_of_week"] = df.index.dayofweek
                                    ^~~~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:278:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                df["day_of_month"] = df.index.day
                ^~~~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:278:34: error: "DatetimeIndex"
has no attribute "day"  [attr-defined]
                df["day_of_month"] = df.index.day
                                     ^~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:279:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                df["month"] = df.index.month
                ^~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:279:27: error: "DatetimeIndex"
has no attribute "month"  [attr-defined]
                df["month"] = df.index.month
                              ^~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:280:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                df["quarter"] = df.index.quarter
                ^~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:280:29: error: "DatetimeIndex"
has no attribute "quarter"  [attr-defined]
                df["quarter"] = df.index.quarter
                                ^~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:345:13: error: Unsupported target
for indexed assignment ("object")  [index]
                validation_results["missing_values"][col] = missing_count
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:350:27: error: "DataFrame" has no
attribute "select_dtypes"  [attr-defined]
            numeric_columns = df.select_dtypes(include=[np.number]).column...
                              ^~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:352:13: error: Unsupported target
for indexed assignment ("object")  [index]
                validation_results["numeric_stats"][col] = {
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\dataset_manager.py:360:29: error: "object" has no
attribute "values"  [attr-defined]
            missing_cells = sum(validation_results["missing_values"].value...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:134:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["price_range"] = data["high"] - data["low"]
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:135:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["body_size"] = abs(data["close"] - data["open"])
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:136:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["upper_shadow"] = data["high"] - np.maximum(
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:139:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["lower_shadow"] = (
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:143:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["price_change"] = data["close"].pct_change()
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:144:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["price_change_abs"] = abs(features["price_change"...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:145:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["volume_change"] = data["volume"].pct_change()
                ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:147:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["log_return"] = np.log(data["close"] / data["clos...
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:178:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["macd_cross"] = np.where(
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:179:17: error: Unsupported left
operand type for > ("Series")  [operator]
                    macd_result.macd > macd_result.signal, 1, -1
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:188:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    features[f"bb_position_{period}"] = (close - bb_lower)...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:189:21: error: Unsupported left
operand type for - ("Series")  [operator]
                        bb_upper - bb_lower
                        ^~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:213:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    features[f"volatility_annualized_{window}"] = features...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:220:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    features[f"quantile_25_{window}"] = returns.rolling(wi...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:223:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    features[f"quantile_75_{window}"] = returns.rolling(wi...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:226:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    features[f"iqr_{window}"] = (
                    ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:231:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    features[f"zscore_{window}"] = (
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:239:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    features[f"range_return_{window}"] = (
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:293:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    features[f"relative_volume_{window}"] = (
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:298:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["volume_spike"] = (volume > volume.rolling(20).me...
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:301:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["volume_drought"] = (
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:318:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["doji"] = (
                ^~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:332:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["price_momentum_divergence"] = self._calculate_mo...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:350:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                features["intraday_volatility"] = (data["high"] - data["lo...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:388:21: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                        features[col] = features[col].clip(
                        ^~~~~~~~~~~~~
infrastructure\core\feature_engineering.py:456:31: error: "Series" has no
attribute "index"  [attr-defined]
            obv = pd.Series(index=close.index, dtype=float)
                                  ^~~~~~~~~~~
infrastructure\agents\base_agent.py:484:38: error: TypedDict key must be a
string literal; expected one of ("name", "agent_type", "max_position_size",
"max_portfolio_risk", "max_risk_per_trade", ...)  [literal-required]
                    value = self._config[key]
                                         ^~~
infrastructure\agents\base_agent.py:541:25: error: Item "str" of
"Literal['market_maker', 'whale_analyzer', 'risk_manager', 'portfolio_optimizer', 'order_executor', 'news_analyzer', 'market_regime', 'strategy_agent', 'meta_controller', 'evolutionary_agent', 'social_media', 'entanglement_detector']"
has no attribute "value"  [union-attr]
                    "type": self._agent_type.value,
                            ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\base_agent.py:688:30: error: Argument 1 to "len" has
incompatible type "CacheManager"; expected "Sized"  [arg-type]
                cache_size = len(self._cache_manager) * 0.1  # ѕримерно 0....
                                 ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\market_regime\indicators.py:59:39: error: Incompatible
types in assignment (expression has type "dict[str, Any]", target has type
"Series")  [assignment]
                result["wave_clusters"] = wave_clusters_result[0] if isins...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\strategies\utils.py:91:39: error: Unsupported operand types for -
("float" and "Decimal")  [operator]
            risk_adjusted = (avg_return - risk_free_rate) / volatility
                                          ^~~~~~~~~~~~~~
domain\strategies\utils.py:91:39: note: Left operand is of type "Decimal | float"
domain\strategies\utils.py:100:32: error: Generator has incompatible item type
"Decimal | Any"; expected "bool"  [misc]
            squared_diff_sum = sum((r - mean_return) ** 2 for r in returns...
                                   ^~~~~~~~~~~~~~~~~~~~~~
domain\strategies\utils.py:100:33: error: Unsupported operand types for -
("Decimal" and "float")  [operator]
            squared_diff_sum = sum((r - mean_return) ** 2 for r in returns...
                                    ^
domain\strategies\utils.py:100:33: note: Right operand is of type "Decimal | float"
domain\strategies\utils.py:350:39: error: Incompatible types in assignment
(expression has type "str", target has type "Decimal")  [assignment]
                        normalized[key] = value
                                          ^~~~~
domain\strategies\utils.py:352:35: error: Incompatible types in assignment
(expression has type "str", target has type "Decimal")  [assignment]
                    normalized[key] = value
                                      ^~~~~
domain\strategies\utils.py:890:12: error: Incompatible return value type (got
"tuple[list[floating[Any]], list[float], list[floating[Any]]]", expected
"tuple[list[float], list[float], list[float]]")  [return-value]
        return upper_band, sma_values, lower_band
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\session_manager.py:193:16: error: Incompatible return value
type (got "dict[str, object]", expected "dict[str, str | float | int]") 
[return-value]
            return self.session_marker.get_session_context(timestamp).to_d...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\sessions\session_manager.py:227:17: error:
"SessionConfigurationRepository" has no attribute "update_session_profile";
maybe "delete_session_profile", "save_session_profile", or
"get_session_profile"?  [attr-defined]
                    self.config_repository.update_session_profile(session_...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\session_manager.py:247:24: error: Incompatible return value
type (got "dict[str, float]", expected "dict[str, str | float | int]") 
[return-value]
                    return self.data_repository.get_session_statistics(
                           ^
domain\sessions\session_manager.py:247:24: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
domain\sessions\session_manager.py:247:24: note: Consider using "Mapping" instead, which is covariant in the value type
domain\sessions\session_manager.py:265:21: error: Dict entry 2 has incompatible
type "str": "dict[str, str | float | int | bool | None]"; expected "str":
"str | float | int | None"  [dict-item]
                        "config": self.config.to_dict(),
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\session_manager.py:268:20: error: Incompatible return value
type (got "dict[str, str | float | int | bool | None]", expected
"dict[str, str | float | int | bool | dict[str, str | float | int | bool | None] | None]")
 [return-value]
                return stats
                       ^~~~~
domain\sessions\session_manager.py:268:20: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
domain\sessions\session_manager.py:268:20: note: Consider using "Mapping" instead, which is covariant in the value type
domain\sessions\session_manager.py:268:20: note: Perhaps you need a type annotation for "stats"? Suggestion: "dict[str, str | float | int | bool | dict[str, str | float | int | bool | None] | None]"
domain\sessions\session_influence_analyzer.py:443:25: error: "Series" has no
attribute "tail"  [attr-defined]
            recent_volume = volume_series.tail(10).mean()
                            ^~~~~~~~~~~~~~~~~~
domain\sessions\session_influence_analyzer.py:444:29: error: "Series" has no
attribute "head"  [attr-defined]
            historical_volume = volume_series.head(-10).mean()
                                ^~~~~~~~~~~~~~~~~~
domain\sessions\session_influence_analyzer.py:463:29: error: "Series" has no
attribute "tail"  [attr-defined]
            recent_volatility = returns.tail(10).std()
                                ^~~~~~~~~~~~
domain\sessions\session_influence_analyzer.py:464:33: error: "Series" has no
attribute "head"  [attr-defined]
            historical_volatility = returns.head(-10).std()
                                    ^~~~~~~~~~~~
domain\sessions\session_influence_analyzer.py:482:25: error: "Series" has no
attribute "tail"  [attr-defined]
            recent_prices = close_series.tail(20)
                            ^~~~~~~~~~~~~~~~~
domain\sessions\session_influence_analyzer.py:510:17: error: "Series" has no
attribute "diff"  [attr-defined]
            delta = close_series.diff()
                    ^~~~~~~~~~~~~~~~~
domain\sessions\session_influence_analyzer.py:517:12: error: Module has no
attribute "isna"  [attr-defined]
            if pd.isna(current_rsi):
               ^~~~~~~
domain\sessions\repositories.py:198:17: error: Dict entry 3 has incompatible
type "str": "dict[str, dict[str, str | float | int]]"; expected "str":
"str | float | int | dict[str, str | float | int | dict[str, str | float | int]]"
 [dict-item]
                    "phases": phases,
                    ^~~~~~~~~~~~~~~~
domain\sessions\repositories.py:199:17: error: Dict entry 4 has incompatible
type "str": "dict[str, str | float | int]"; expected "str":
"str | float | int | dict[str, str | float | int | dict[str, str | float | int]]"
 [dict-item]
                    "risk_factors": risk_factors,
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\implementations.py:126:25: error: Unsupported left operand type
for / ("Series")  [operator]
            rs: pd.Series = gain / loss
                            ^~~~~~~~~~~
domain\sessions\implementations.py:127:26: error: Incompatible types in
assignment (expression has type "float", variable has type "Series") 
[assignment]
            rsi: pd.Series = 100 - (100 / (1 + rs))
                             ^~~~~~~~~~~~~~~~~~~~~~
domain\sessions\implementations.py:127:44: error: Unsupported operand types for
+ ("int" and "Series")  [operator]
            rsi: pd.Series = 100 - (100 / (1 + rs))
                                               ^~
domain\sessions\implementations.py:129:23: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            current_rsi = rsi.iloc[-1]
                          ^~~~~~~~~~~~
domain\evolution\strategy_fitness.py:668:17: error: Argument 1 to
"_evaluate_conditions" of "StrategyFitnessEvaluator" has incompatible type
"list[ExitCondition]"; expected "list[dict[str, Any] | ExitCondition]" 
[arg-type]
                    rule.conditions, current_data, current_index, full_dat...
                    ^~~~~~~~~~~~~~~
domain\evolution\strategy_fitness.py:668:17: note: "list" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
domain\evolution\strategy_fitness.py:668:17: note: Consider using "Sequence" instead, which is covariant
domain\evolution\strategy_fitness.py:685:56: error: Argument 1 to
"_evaluate_single_condition" of "StrategyFitnessEvaluator" has incompatible type
"dict[str, Any] | ExitCondition"; expected "dict[str, Any]"  [arg-type]
    ...          if not self._evaluate_single_condition(condition, current_da...
                                                        ^~~~~~~~~
tests\unit\test_feature_engineering.py:195:20: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            features = features.iloc[:-1]  # ”бираем последнюю строку дл€ ...
                       ^~~~~~~~~~~~~
tests\unit\test_feature_engineering.py:209:20: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            features = features.iloc[:-1]  # ”бираем последнюю строку дл€ ...
                       ^~~~~~~~~~~~~
tests\unit\test_feature_engineering.py:230:20: error: "DataFrame" has no
attribute "isna"  [attr-defined]
            assert not preprocessed_features.isna().any().any()
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_feature_engineering.py:278:18: error: Module has no attribute
"date_range"  [attr-defined]
            }, index=pd.date_range('2023-01-01', periods=10000, freq='1H')...
                     ^~~~~~~~~~~~~
infrastructure\sessions\session_repository.py:933:18: error: Item "None" of
"Engine | None" has no attribute "connect"  [union-attr]
                with self.engine.connect() as conn:
                     ^~~~~~~~~~~~~~~~~~~
infrastructure\sessions\session_repository.py:942:21: error: Argument 2 to
"execute" of "Connection" has incompatible type
"tuple[str, float, bool, str | None]"; expected
"Sequence[Mapping[str, Any]] | Mapping[str, Any] | None"  [arg-type]
                        (operation_type, execution_time_ms, success, error...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\sessions\session_repository.py:1010:28: error: Name
"ConfidenceScore" is not defined  [name-defined]
                    confidence=ConfidenceScore(row[5]),
                               ^~~~~~~~~~~~~~~
infrastructure\sessions\session_repository.py:1011:25: error: Argument
"metrics" to "SessionAnalysisResult" has incompatible type "dict[str, float]";
expected "SessionMetrics"  [arg-type]
                    metrics=metrics,
                            ^~~~~~~
infrastructure\sessions\session_repository.py:1012:35: error: Argument
"market_conditions" to "SessionAnalysisResult" has incompatible type
"dict[str, object]"; expected "MarketConditions"  [arg-type]
                    market_conditions=market_conditions,
                                      ^~~~~~~~~~~~~~~~~
infrastructure\sessions\session_repository.py:1014:30: error: Argument
"risk_factors" to "SessionAnalysisResult" has incompatible type
"dict[Never, Never]"; expected "list[str]"  [arg-type]
                    risk_factors={},
                                 ^~
infrastructure\sessions\session_repository.py:1030:35: error: Argument
"influence_metrics" to "SessionInfluenceResult" has incompatible type
"dict[Never, Never]"; expected "SessionInfluenceMetrics"  [arg-type]
                    influence_metrics={},
                                      ^~
infrastructure\sessions\session_repository.py:1036:37: error: Argument
"historical_patterns" to "SessionInfluenceResult" has incompatible type
"dict[Never, Never]"; expected "list[dict[str, str | float | int]]"  [arg-type]
                    historical_patterns={},
                                        ^~
infrastructure\sessions\session_repository.py:1047:20: error: Missing
positional arguments "influence_strength", "market_conditions",
"predicted_impact" in call to "SessionInfluenceSignal"  [call-arg]
                return SessionInfluenceSignal(
                       ^
infrastructure\sessions\session_repository.py:1111:24: error: Incompatible
return value type (got "dict[Any | str, dict[str, Any | float | int]]", expected
"dict[str, str | float | int]")  [return-value]
                    return metrics
                           ^~~~~~~
infrastructure\external_services\market_data.py:392:22: error: Module has no
attribute "concat"  [attr-defined]
                result = pd.concat(data).drop_duplicates()
                         ^~~~~~~~~
infrastructure\evolution\cache.py:91:28: error: Invalid index type "str" for
"dict[UUID, dict[Any, Any]]"; expected type "UUID"  [index]
                        result[k] = dict(v)
                               ^
infrastructure\evolution\cache.py:93:24: error: Invalid index type "str" for
"dict[UUID, dict[Any, Any]]"; expected type "UUID"  [index]
                    result[k] = dict(v)
                           ^
infrastructure\evolution\cache.py:258:21: error: Argument 1 to "delete" of
"EvolutionCache" has incompatible type "str"; expected "CacheKey"  [arg-type]
            self.delete(oldest_key)
                        ^~~~~~~~~~
infrastructure\evolution\cache.py:267:21: error: Argument 1 to "delete" of
"EvolutionCache" has incompatible type "str"; expected "CacheKey"  [arg-type]
            self.delete(fifo_key)
                        ^~~~~~~~
infrastructure\evolution\cache.py:287:25: error: Argument 1 to "delete" of
"EvolutionCache" has incompatible type "str"; expected "CacheKey"  [arg-type]
                self.delete(key)
                            ^~~
infrastructure\entity_system\evolution\optimization\genetic_optimizer.py:96:21: error:
Unsupported operand types for + ("float" and "str")  [operator]
                        total_score += parameters["performance_weight"]
                        ^
infrastructure\entity_system\evolution\optimization\genetic_optimizer.py:96:21: note: Right operand is of type "int | float | bool | str"
infrastructure\entity_system\evolution\optimization\genetic_optimizer.py:99:21: error:
Unsupported operand types for + ("float" and "str")  [operator]
                        total_score += parameters["maintainability_weight"...
                        ^
infrastructure\entity_system\evolution\optimization\genetic_optimizer.py:99:21: note: Right operand is of type "int | float | bool | str"
infrastructure\core\ml_integration.py:201:26: error: "DataFrame" has no
attribute "max"  [attr-defined]
                true_range = ranges.max(axis=1)
                             ^~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:44:20: error: Argument
"config" to "__init__" of "BaseAgent" has incompatible type "dict[str, Any]";
expected "AgentConfig | None"  [arg-type]
                config=config
                       ^~~~~~
infrastructure\agents\social_media\agent_social_media.py:71:13: error: Property
"status" defined in "AgentState" is read-only  [misc]
                self.state.status = AgentStatus.HEALTHY
                ^~~~~~~~~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:80:5: error: Return
type "Coroutine[Any, Any, dict[str, Any]]" of "process" incompatible with return
type "Coroutine[Any, Any, ProcessingResult]" in supertype "BaseAgent" 
[override]
        async def process(self, data: Any) -> Dict[str, Any]:
        ^
infrastructure\agents\social_media\agent_social_media.py:98:35: error:
"ISocialMediaProvider" has no attribute "platform"  [attr-defined]
                        "platforms": [p.platform.value for p in self.provi...
                                      ^~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:136:37: error:
TypedDict key must be a string literal; expected one of ("name", "agent_type",
"max_position_size", "max_portfolio_risk", "max_risk_per_trade", ...) 
[literal-required]
                    value = self.config[key]
                                        ^~~
infrastructure\agents\social_media\agent_social_media.py:154:16: error:
Unsupported right operand type for in ("object")  [operator]
                if "reddit" in platforms:
                   ^~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:156:55: error:
Argument 1 to "RedditProvider" has incompatible type "object"; expected
"dict[str, Any]"  [arg-type]
                    self._providers.append(RedditProvider(reddit_config))
                                                          ^~~~~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:158:16: error:
Unsupported right operand type for in ("object")  [operator]
                if "telegram" in platforms:
                   ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:160:57: error:
Argument 1 to "TelegramProvider" has incompatible type "object"; expected
"dict[str, Any]"  [arg-type]
    ...             self._providers.append(TelegramProvider(telegram_config))
                                                            ^~~~~~~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:162:16: error:
Unsupported right operand type for in ("object")  [operator]
                if "discord" in platforms:
                   ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:164:56: error:
Argument 1 to "DiscordProvider" has incompatible type "object"; expected
"dict[str, Any]"  [arg-type]
    ...               self._providers.append(DiscordProvider(discord_config))
                                                             ^~~~~~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:188:40: error:
TypedDict "AgentConfig" has no key "cache_ttl"  [typeddict-item]
                if cache_age > self.config["cache_ttl"]:
                                           ^~~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:213:44: error:
TypedDict "AgentConfig" has no key "cache_ttl"  [typeddict-item]
                    if cache_age > self.config["cache_ttl"]:
                                               ^~~~~~~~~~~
infrastructure\agents\social_media\agent_social_media.py:237:45: error:
TypedDict "AgentConfig" has no key "max_posts_per_request"  [typeddict-item]
                            symbol, self.config["max_posts_per_request"]
                                                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\brokers.py:175:5: error: Missing return
statement  [return]
        async def place_order(self, request: OrderRequest) -> OrderRespons...
        ^
infrastructure\agents\order_executor\brokers.py:187:5: error: Missing return
statement  [return]
        async def cancel_order(self, order_id: str, symbol: Symbol) -> boo...
        ^
infrastructure\agents\order_executor\brokers.py:201:5: error: Missing return
statement  [return]
        async def get_order_status(self, order_id: str, symbol: Symbol) ->...
        ^
infrastructure\agents\order_executor\agent_order_executor.py:29:44: error:
Argument 2 to "__init__" of "BaseAgent" has incompatible type
"dict[str, Any] | None"; expected
"Literal['market_maker', 'whale_analyzer', 'risk_manager', 'portfolio_optimizer', 'order_executor', 'news_analyzer', 'market_regime', 'strategy_agent', 'meta_controller', 'evolutionary_agent', 'social_media', 'entanglement_detector']"
 [arg-type]
            super().__init__("order_executor", config)
                                               ^~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:31:9: error:
Property "config" defined in "BaseAgent" is read-only  [misc]
            self.config = config or {
            ^~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:31:23: error:
Incompatible types in assignment (expression has type "dict[str, Any]", variable
has type "AgentConfig")  [assignment]
            self.config = config or {
                          ^
infrastructure\agents\order_executor\agent_order_executor.py:65:13: error:
Property "status" defined in "AgentState" is read-only  [misc]
                self.state.status = AgentStatus.HEALTHY
                ^~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:91:24: error:
Unexpected keyword argument "processing_time" for "ProcessingResult"; did you
mean "processing_time_ms"?  [call-arg]
                    return ProcessingResult(
                           ^
infrastructure\agents\order_executor\agent_order_executor.py:107:20: error:
Unexpected keyword argument "error" for "ProcessingResult"; did you mean
"errors"?  [call-arg]
                return ProcessingResult(
                       ^
infrastructure\agents\order_executor\agent_order_executor.py:107:20: error:
Unexpected keyword argument "processing_time" for "ProcessingResult"; did you
mean "processing_time_ms"?  [call-arg]
                return ProcessingResult(
                       ^
infrastructure\agents\order_executor\agent_order_executor.py:140:37: error:
TypedDict key must be a string literal; expected one of ("name", "agent_type",
"max_position_size", "max_portfolio_risk", "max_risk_per_trade", ...) 
[literal-required]
                    value = self.config[key]
                                        ^~~
infrastructure\agents\order_executor\agent_order_executor.py:166:16: error:
"dict[str, Any]" has no attribute "order_type"  [attr-defined]
                if order.order_type == OrderType.MARKET:
                   ^~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:168:18: error:
"dict[str, Any]" has no attribute "order_type"  [attr-defined]
                elif order.order_type == OrderType.LIMIT:
                     ^~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:170:18: error:
"dict[str, Any]" has no attribute "order_type"  [attr-defined]
                elif order.order_type == OrderType.STOP:
                     ^~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:224:20: error:
"OrderRequestDict" has no attribute "symbol"  [attr-defined]
                if not order_params.symbol or order_params.quantity <= 0:
                       ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:224:43: error:
"OrderRequestDict" has no attribute "quantity"  [attr-defined]
                if not order_params.symbol or order_params.quantity <= 0:
                                              ^~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:228:17: error:
"OrderRequestDict" has no attribute "order_type"  [attr-defined]
                    order_params.order_type == OrderType.LIMIT
                    ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:229:21: error:
"OrderRequestDict" has no attribute "price"  [attr-defined]
                    and order_params.price is None
                        ^~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:234:17: error:
"OrderRequestDict" has no attribute "order_type"  [attr-defined]
                    order_params.order_type == OrderType.STOP
                    ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:235:21: error:
"OrderRequestDict" has no attribute "stop_price"  [attr-defined]
                    and order_params.stop_price is None
                        ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:251:32: error:
"OrderRequestDict" has no attribute "client_order_id"  [attr-defined]
                "client_order_id": order_params.client_order_id,
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:252:23: error:
"OrderRequestDict" has no attribute "symbol"  [attr-defined]
                "symbol": order_params.symbol,
                          ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:253:21: error:
"OrderRequestDict" has no attribute "side"  [attr-defined]
                "side": order_params.side,
                        ^~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:254:27: error:
"OrderRequestDict" has no attribute "order_type"  [attr-defined]
                "order_type": order_params.order_type,
                              ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:255:25: error:
"OrderRequestDict" has no attribute "quantity"  [attr-defined]
                "quantity": order_params.quantity,
                            ^~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:256:22: error:
"OrderRequestDict" has no attribute "price"  [attr-defined]
                "price": order_params.price,
                         ^~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:257:27: error:
"OrderRequestDict" has no attribute "stop_price"  [attr-defined]
                "stop_price": order_params.stop_price,
                              ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:258:30: error:
"OrderRequestDict" has no attribute "time_in_force"  [attr-defined]
                "time_in_force": order_params.time_in_force,
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:259:25: error:
"OrderRequestDict" has no attribute "metadata"  [attr-defined]
                "metadata": order_params.metadata,
                            ^~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:290:31: error:
Unsupported operand types for > ("float" and "object")  [operator]
                    if slippage > self.config.get("max_slippage", 0.001):
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:303:35: error:
Name "ExecutionType" is not defined  [name-defined]
                    "execution_type": ExecutionType.MARKET,
                                      ^~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:340:39: error:
Name "ExecutionType" is not defined  [name-defined]
                        "execution_type": ExecutionType.LIMIT,
                                          ^~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:366:39: error:
Name "ExecutionType" is not defined  [name-defined]
                        "execution_type": ExecutionType.LIMIT,
                                          ^~~~~~~~~~~~~
infrastructure\agents\order_executor\agent_order_executor.py:456:59: error:
Argument 1 to "float" has incompatible type "str | int | None"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
    ...                self.stats["total_fees"] += float(trade.get("fee", 0))
                                                         ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\market_regime\agent_backup.py:157:30: error: Value of
type "Callable[[], Any]" is not indexable  [index]
                    "rsi": float(rsi.iloc[-1]) if not rsi.empty else 50.0,
                                 ^~~~~~~~~~~~
infrastructure\agents\market_regime\agent_backup.py:166:17: error: "Series" has
no attribute "diff"  [attr-defined]
            delta = prices.diff()
                    ^~~~~~~~~~~
infrastructure\agents\market_regime\agent_backup.py:204:23: error: "DataFrame"
has no attribute "tail"  [attr-defined]
            recent_data = data.tail(20)
                          ^~~~~~~~~
infrastructure\agents\market_regime\agent_backup.py:363:13: error: Unsupported
target for indexed assignment ("object")  [index]
                summary["symbols"][str(symbol)] = {
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:77:20: error: Incompatible
return value type (got "Price", expected "Decimal | None")  [return-value]
                return best_ask - best_bid
                       ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:207:69: error: Argument 2
to "Decimal" has incompatible type "Currency"; expected "Context | None" 
[arg-type]
    ...ice(Decimal(str(base_price * (1 + abs(change))), Currency.USDT), Curre...
                                                        ^~~~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:208:68: error: Argument 2
to "Decimal" has incompatible type "Currency"; expected "Context | None" 
[arg-type]
    ...ice(Decimal(str(base_price * (1 - abs(change))), Currency.USDT), Curre...
                                                        ^~~~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:209:65: error: Argument 2
to "Decimal" has incompatible type "Currency"; expected "Context | None" 
[arg-type]
    ...se=Price(Decimal(str(base_price * (1 + change)), Currency.USDT), Curre...
                                                        ^~~~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:279:16: error: "Series" has
no attribute "rolling"  [attr-defined]
            return prices.rolling(window=window).mean()
                   ^~~~~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:284:16: error: "Series" has
no attribute "ewm"  [attr-defined]
            return prices.ewm(span=window).mean()
                   ^~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:289:17: error: "Series" has
no attribute "diff"  [attr-defined]
            delta = prices.diff()
                    ^~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:301:15: error: "Series" has
no attribute "rolling"  [attr-defined]
            sma = prices.rolling(window=window).mean()
                  ^~~~~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:302:15: error: "Series" has
no attribute "rolling"  [attr-defined]
            std = prices.rolling(window=window).std()
                  ^~~~~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:314:15: error: Unsupported
left operand type for - ("Series")  [operator]
            tr1 = high - low
                  ^~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:315:26: error: "Series" has
no attribute "shift"  [attr-defined]
            tr2 = abs(high - close.shift())
                             ^~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:316:25: error: "Series" has
no attribute "shift"  [attr-defined]
            tr3 = abs(low - close.shift())
                            ^~~~~~~~~~~
infrastructure\agents\market_maker\data_provider.py:317:14: error: Module has
no attribute "concat"  [attr-defined]
            tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
                 ^~~~~~~~~
examples\fixed_components_usage.py:17:1: error: Module
"infrastructure.entity_system.perception.dependency_resolver" has no attribute
"DependencyResolver"  [attr-defined]
    from infrastructure.entity_system.perception.dependency_resolver impor...
    ^
examples\fixed_components_usage.py:17:1: error: Module
"infrastructure.entity_system.perception.dependency_resolver" has no attribute
"DependencyResolution"  [attr-defined]
    from infrastructure.entity_system.perception.dependency_resolver impor...
    ^
domain\symbols\opportunity_score.py:487:32: error: Item "None" of
"dict[MarketPhase, float] | None" has no attribute "get"  [union-attr]
                phase_multiplier = self.config.phase_multipliers.get(marke...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\symbols\opportunity_score.py:560:39: error: No overload variant of
"polyfit" matches argument types "ndarray[Any, dtype[signedinteger[Any]]]",
"Callable[[], ndarray[Any, Any]]", "int", "bool"  [call-overload]
                slope, _, r_value, _, _ = np.polyfit(x, volume.values, 1, ...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\symbols\opportunity_score.py:560:39: note: Possible overload variants:
domain\symbols\opportunity_score.py:560:39: note:     def polyfit(x: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], y: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], deg: SupportsIndex | SupportsInt, rcond: float | None = ..., full: Literal[False] = ..., w: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float] | None = ..., cov: Literal[False] = ...) -> ndarray[Any, dtype[floating[_64Bit]]]
domain\symbols\opportunity_score.py:560:39: note:     def polyfit(x: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], y: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], deg: SupportsIndex | SupportsInt, rcond: float | None = ..., full: Literal[False] = ..., w: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float] | None = ..., cov: Literal[False] = ...) -> ndarray[Any, dtype[complexfloating[_64Bit, _64Bit]]]
domain\symbols\opportunity_score.py:560:39: note:     def polyfit(x: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], y: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], deg: SupportsIndex | SupportsInt, rcond: float | None = ..., full: Literal[False] = ..., w: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float] | None = ..., cov: Literal[True, 'unscaled'] = ...) -> tuple[ndarray[Any, dtype[floating[_64Bit]]], ndarray[Any, dtype[floating[_64Bit]]]]
domain\symbols\opportunity_score.py:560:39: note:     def polyfit(x: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], y: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], deg: SupportsIndex | SupportsInt, rcond: float | None = ..., full: Literal[False] = ..., w: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float] | None = ..., cov: Literal[True, 'unscaled'] = ...) -> tuple[ndarray[Any, dtype[complexfloating[_64Bit, _64Bit]]], ndarray[Any, dtype[complexfloating[_64Bit, _64Bit]]]]
domain\symbols\opportunity_score.py:560:39: note:     def polyfit(x: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], y: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], deg: SupportsIndex | SupportsInt, rcond: float | None = ..., full: Literal[True] = ..., w: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float] | None = ..., cov: bool | Literal['unscaled'] = ...) -> tuple[ndarray[Any, dtype[floating[_64Bit]]], ndarray[Any, dtype[floating[_64Bit]]], ndarray[Any, dtype[signedinteger[_32Bit]]], ndarray[Any, dtype[floating[_64Bit]]], ndarray[Any, dtype[floating[_64Bit]]]]
domain\symbols\opportunity_score.py:560:39: note:     def polyfit(x: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], y: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], deg: SupportsIndex | SupportsInt, rcond: float | None = ..., full: Literal[True] = ..., w: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float] | None = ..., cov: bool | Literal['unscaled'] = ...) -> tuple[ndarray[Any, dtype[complexfloating[_64Bit, _64Bit]]], ndarray[Any, dtype[floating[_64Bit]]], ndarray[Any, dtype[signedinteger[_32Bit]]], ndarray[Any, dtype[floating[_64Bit]]], ndarray[Any, dtype[floating[_64Bit]]]]
domain\symbols\opportunity_score.py:578:30: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                current_volume = volume.iloc[-1]
                                 ^~~~~~~~~~~~~~~
domain\sessions\session_analyzer_factory.py:22:35: error: Incompatible types in
assignment (expression has type "None", variable has type "list[str]") 
[assignment]
        enabled_features: List[str] = None
                                      ^~~~
domain\sessions\session_analyzer_factory.py:154:28: error: Missing positional
argument "registry" in call to "BaseSessionAnalyzer"  [call-arg]
                    analyzer = analyzer_class()
                               ^~~~~~~~~~~~~~~~
domain\sessions\session_analyzer_factory.py:156:28: error: Missing positional
argument "registry" in call to "BaseSessionAnalyzer"  [call-arg]
                    analyzer = analyzer_class()
                               ^~~~~~~~~~~~~~~~
domain\sessions\session_analyzer_factory.py:159:28: error: Missing positional
argument "registry" in call to "BaseSessionAnalyzer"  [call-arg]
                    analyzer = analyzer_class()
                               ^~~~~~~~~~~~~~~~
domain\sessions\services.py:118:24: error: Incompatible return value type (got
"object", expected "SessionContext")  [return-value]
                    return cached_context
                           ^~~~~~~~~~~~~~
domain\sessions\services.py:133:20: error: Incompatible return value type (got
"dict[str, object]", expected "SessionContext")  [return-value]
                return context_dict
                       ^~~~~~~~~~~~
domain\sessions\services.py:162:24: error: Incompatible return value type (got
"object", expected "SessionAnalysisResult | None")  [return-value]
                    return cached_analysis
                           ^~~~~~~~~~~~~~~
domain\sessions\services.py:196:24: error: Incompatible return value type (got
"object", expected "SessionPrediction")  [return-value]
                    return cached_prediction
                           ^~~~~~~~~~~~~~~~~
domain\sessions\services.py:230:41: error: "SessionMetrics" has no attribute
"volatility_change_percent"  [attr-defined]
                    "predicted_volatility": base_metrics.volatility_change...
                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\sessions\services.py:231:37: error: "SessionMetrics" has no attribute
"volume_change_percent"  [attr-defined]
                    "predicted_volume": base_metrics.volume_change_percent...
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\services.py:232:45: error: "SessionMetrics" has no attribute
"price_direction_bias"  [attr-defined]
                    "predicted_direction_bias": base_metrics.price_directi...
                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\sessions\services.py:233:39: error: "SessionMetrics" has no attribute
"momentum_strength"  [attr-defined]
                    "predicted_momentum": base_metrics.momentum_strength,
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\services.py:234:41: error: "SessionMetrics" has no attribute
"reversal_probability"  [attr-defined]
                    "reversal_probability": base_metrics.reversal_probabil...
                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\services.py:235:45: error: "SessionMetrics" has no attribute
"trend_continuation_probability"  [attr-defined]
                    "continuation_probability": base_metrics.trend_continu...
                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\sessions\services.py:236:47: error: "SessionMetrics" has no attribute
"false_breakout_probability"  [attr-defined]
                    "false_breakout_probability": base_metrics.false_break...
                                                  ^~~~~~~~~~~~~~~~~~~~~~~~...
domain\sessions\services.py:256:24: error: Incompatible return value type (got
"object", expected "list[str]")  [return-value]
                    return cached_recommendations
                           ^~~~~~~~~~~~~~~~~~~~~~
domain\sessions\services.py:278:24: error: Incompatible return value type (got
"object", expected "dict[str, Any]")  [return-value]
                    return cached_statistics
                           ^~~~~~~~~~~~~~~~~
domain\sessions\services.py:295:33: error: "SessionProfile" has no attribute
"last_updated"  [attr-defined]
                    "last_updated": profile.last_updated.isoformat() if pr...
                                    ^~~~~~~~~~~~~~~~~~~~
domain\sessions\services.py:307:65: error: Argument 1 to "is_transition_period"
of "BaseSessionTransitionManager" has incompatible type "Timestamp | None";
expected "Timestamp"  [arg-type]
    ...        return self.transition_manager.is_transition_period(timestamp)
                                                                   ^~~~~~~~~
domain\sessions\services.py:317:74: error: Argument 1 to
"get_active_transitions" of "BaseSessionTransitionManager" has incompatible type
"Timestamp | None"; expected "Timestamp"  [arg-type]
    ...ransitions = self.transition_manager.get_active_transitions(timestamp)
                                                                   ^~~~~~~~~
domain\sessions\services.py:319:21: error: "SessionTransition" has no attribute
"to_dict"  [attr-defined]
                return [transition.to_dict() if hasattr(transition, 'to_di...
                        ^~~~~~~~~~~~~~~~~~
domain\sessions\services.py:394:35: error: Argument 1 to "len" has incompatible
type "SessionCache"; expected "Sized"  [arg-type]
                    "cache_size": len(self.cache) if hasattr(self.cache, '...
                                      ^~~~~~~~~~
domain\services\signal_service.py:131:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\services\signal_service.py:134:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\evolution\strategy_selection.py:170:32: error: Incompatible types in
assignment (expression has type "list[Any]", variable has type
"ndarray[Any, dtype[signedinteger[Any]]]")  [assignment]
                tournament_pairs = [pairs[i] for i in tournament_pairs]
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\entities\market.py:694:58: error: "<typing special form>" not callable 
[operator]
    ...stamp: Timestamp = field(default_factory=lambda: Timestamp(datetime.no...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
application\signal\session_signal_engine.py:279:16: error:
"SessionInfluenceResult" has no attribute "score"  [attr-defined]
                if influence_result.score > 0.1:
                   ^~~~~~~~~~~~~~~~~~~~~~
application\signal\session_signal_engine.py:281:18: error:
"SessionInfluenceResult" has no attribute "score"  [attr-defined]
                elif influence_result.score < -0.1:
                     ^~~~~~~~~~~~~~~~~~~~~~
application\signal\session_signal_engine.py:304:20: error: Incompatible return
value type (got "None", expected "SessionInfluenceSignal")  [return-value]
                return None
                       ^~~~
application\signal\session_signal_engine.py:352:20: error: Incompatible return
value type (got "None", expected "SessionInfluenceResult")  [return-value]
                return None
                       ^~~~
application\entanglement\stream_manager.py:302:43: error: Argument 1 to "len"
has incompatible type "Callable[[str, Any], None]"; expected "Sized"  [arg-type]
                "aggregator_buffer_size": len(self.aggregator.update_buffe...
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_agents_integration.py:30:17: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.date_range(start='2024-01-01', periods=100, freq='1...
                    ^~~~~~~~~~~~~
tests\unit\domain\sessions\test_session_components.py:331:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(metrics, SessionMetrics)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\domain\sessions\test_session_components.py:340:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(conditions, MarketConditions)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\domain\sessions\test_session_components.py:369:26: error: Module has
no attribute "date_range"  [attr-defined]
                'timestamp': pd.date_range(start='2024-01-01', periods=100...
                             ^~~~~~~~~~~~~
tests\unit\domain\sessions\test_session_components.py:417:26: error: Module has
no attribute "date_range"  [attr-defined]
                'timestamp': pd.date_range(start='2024-01-01', periods=100...
                             ^~~~~~~~~~~~~
tests\unit\domain\sessions\test_session_components.py:513:26: error: Module has
no attribute "date_range"  [attr-defined]
                'timestamp': pd.date_range(start='2024-01-01', periods=100...
                             ^~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:66:30: error: Argument 1 to
"set_evaluation" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_evaluation(CacheKey(sample_evaluation.id), sample_ev...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:66:39: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_evaluation(CacheKey(sample_evaluation.id), sample_ev...
                                          ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:67:42: error: Argument 1 to
"get_evaluation" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            retrieved = cache.get_evaluation(CacheKey(sample_evaluation.id...
                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:67:51: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
    ...       retrieved = cache.get_evaluation(CacheKey(sample_evaluation.id)...
                                                        ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:74:42: error: Argument 1 to
"get_evaluation" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            retrieved = cache.get_evaluation(CacheKey(uuid4()))
                                             ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:74:51: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            retrieved = cache.get_evaluation(CacheKey(uuid4()))
                                                      ^~~~~~~
tests\infrastructure\evolution\test_cache.py:78:27: error: Argument 1 to
"set_context" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_context(CacheKey(sample_context.id), sample_context)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:78:36: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_context(CacheKey(sample_context.id), sample_context)
                                       ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:79:39: error: Argument 1 to
"get_context" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            retrieved = cache.get_context(CacheKey(sample_context.id))
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:79:48: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            retrieved = cache.get_context(CacheKey(sample_context.id))
                                                   ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:86:39: error: Argument 1 to
"get_context" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            retrieved = cache.get_context(CacheKey(uuid4()))
                                          ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:86:48: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            retrieved = cache.get_context(CacheKey(uuid4()))
                                                   ^~~~~~~
tests\infrastructure\evolution\test_cache.py:101:29: error: Argument 1 to
"set_candidate" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_candidate(CacheKey(sample_candidate.id), sample_cand...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:101:38: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_candidate(CacheKey(sample_candidate.id), sample_cand...
                                         ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:102:25: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            assert CacheKey(sample_candidate.id) in cache._cache
                            ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:103:32: error: Argument 1 to
"delete_candidate" of "EvolutionCache" has incompatible type "CacheKey";
expected "UUID"  [arg-type]
            cache.delete_candidate(CacheKey(sample_candidate.id))
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:103:41: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.delete_candidate(CacheKey(sample_candidate.id))
                                            ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:104:25: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            assert CacheKey(sample_candidate.id) not in cache._cache
                            ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:107:30: error: Argument 1 to
"set_evaluation" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_evaluation(CacheKey(sample_evaluation.id), sample_ev...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:107:39: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_evaluation(CacheKey(sample_evaluation.id), sample_ev...
                                          ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:108:25: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            assert CacheKey(sample_evaluation.id) in cache._cache
                            ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:109:33: error: Argument 1 to
"delete_evaluation" of "EvolutionCache" has incompatible type "CacheKey";
expected "UUID"  [arg-type]
            cache.delete_evaluation(CacheKey(sample_evaluation.id))
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:109:42: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.delete_evaluation(CacheKey(sample_evaluation.id))
                                             ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:110:25: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            assert CacheKey(sample_evaluation.id) not in cache._cache
                            ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:113:27: error: Argument 1 to
"set_context" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_context(CacheKey(sample_context.id), sample_context)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:113:36: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_context(CacheKey(sample_context.id), sample_context)
                                       ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:114:25: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            assert CacheKey(sample_context.id) in cache._cache
                            ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:115:30: error: Argument 1 to
"delete_context" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.delete_context(CacheKey(sample_context.id))
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:115:39: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.delete_context(CacheKey(sample_context.id))
                                          ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:116:25: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            assert CacheKey(sample_context.id) not in cache._cache
                            ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:129:29: error: Argument 1 to
"set_candidate" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_candidate(CacheKey(sample_candidate.id), sample_cand...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:129:38: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_candidate(CacheKey(sample_candidate.id), sample_cand...
                                         ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:130:30: error: Argument 1 to
"set_evaluation" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_evaluation(CacheKey(sample_evaluation.id), sample_ev...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:130:39: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_evaluation(CacheKey(sample_evaluation.id), sample_ev...
                                          ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:131:27: error: Argument 1 to
"set_context" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_context(CacheKey(sample_context.id), sample_context)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:131:36: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_context(CacheKey(sample_context.id), sample_context)
                                       ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:140:29: error: Argument 1 to
"set_candidate" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_candidate(CacheKey(sample_candidate.id), sample_cand...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:140:38: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_candidate(CacheKey(sample_candidate.id), sample_cand...
                                         ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:141:30: error: Argument 1 to
"set_evaluation" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_evaluation(CacheKey(sample_evaluation.id), sample_ev...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:141:39: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_evaluation(CacheKey(sample_evaluation.id), sample_ev...
                                          ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:142:27: error: Argument 1 to
"set_context" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_context(CacheKey(sample_context.id), sample_context)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:142:36: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_context(CacheKey(sample_context.id), sample_context)
                                       ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:241:23: error: Argument 1 to "set"
of "EvolutionCache" has incompatible type "None"; expected "CacheKey" 
[arg-type]
                cache.set(None, "value")
                          ^~~~
tests\infrastructure\evolution\test_cache.py:263:29: error: Argument 1 to
"set_candidate" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_candidate(CacheKey(sample_candidate.id), sample_cand...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:263:38: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_candidate(CacheKey(sample_candidate.id), sample_cand...
                                         ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:265:45: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cached_data = cache._cache[CacheKey(sample_candidate.id)]["dat...
                                                ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:272:29: error: Argument 1 to
"set_candidate" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            cache.set_candidate(CacheKey(sample_candidate.id), sample_cand...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:272:38: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            cache.set_candidate(CacheKey(sample_candidate.id), sample_cand...
                                         ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:274:41: error: Argument 1 to
"get_candidate" of "EvolutionCache" has incompatible type "CacheKey"; expected
"UUID"  [arg-type]
            retrieved = cache.get_candidate(CacheKey(sample_candidate.id))
                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_cache.py:274:50: error: Argument 1 to
"CacheKey" has incompatible type "UUID"; expected "str"  [arg-type]
            retrieved = cache.get_candidate(CacheKey(sample_candidate.id))
                                                     ^~~~~~~~~~~~~~~~~~~
infrastructure\simulation\types.py:322:23: error: Argument "timestamp" to
"MarketData" has incompatible type "domain.types.base_types.TimestampValue";
expected "domain.types.TimestampValue"  [arg-type]
                timestamp=TimestampValue(self.timestamp.value),
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\types.py:366:16: error: Unexpected keyword argument
"strategy_id" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\types.py:366:16: error: Unexpected keyword argument
"trading_pair" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\types.py:366:16: error: Unexpected keyword argument
"quantity" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\types.py:366:16: error: Unexpected keyword argument
"stop_loss" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\types.py:366:16: error: Unexpected keyword argument
"take_profit" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\types.py:367:16: error: Argument "id" to "Signal" has
incompatible type "SignalId"; expected "str"  [arg-type]
                id=self.id,
                   ^~~~~~~
infrastructure\simulation\types.py:370:25: error: Argument "signal_type" to
"Signal" has incompatible type "domain.entities.signal.SignalType"; expected
"domain.entities.trading.SignalType"  [arg-type]
                signal_type=signal_type,
                            ^~~~~~~~~~~
infrastructure\simulation\types.py:371:24: error: Argument "confidence" to
"Signal" has incompatible type "Decimal"; expected "float"  [arg-type]
                confidence=Decimal(str(self.confidence)),
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\types.py:372:19: error: "SimulationPrice" has no
attribute "to_domain_money"  [attr-defined]
                price=self.price.to_domain_money() if self.price else None...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\types.py:374:23: error: "SimulationPrice" has no
attribute "to_domain_money"  [attr-defined]
                stop_loss=self.stop_loss.to_domain_money() if self.stop_lo...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\types.py:375:25: error: "SimulationPrice" has no
attribute "to_domain_money"  [attr-defined]
                take_profit=self.take_profit.to_domain_money() if self.tak...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\types.py:419:9: error: Module
"domain.value_objects.volume" has no attribute "VolumeValue"  [attr-defined]
            from domain.value_objects.volume import VolumeValue
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\types.py:476:16: error: Incompatible return value
type (got "domain.entities.trade.Trade", expected
"domain.entities.trading.Trade")  [return-value]
            return Trade(
                   ^
infrastructure\simulation\types.py:479:18: error: Argument "side" to "Trade"
has incompatible type "OrderSide"; expected
"Literal['buy', 'sell', 'hold', 'close', 'strong_buy', 'strong_sell']" 
[arg-type]
                side=self.side,
                     ^~~~~~~~~
infrastructure\simulation\types.py:482:25: error: Argument "executed_at" to
"Trade" has incompatible type "domain.types.base_types.TimestampValue"; expected
"domain.types.TimestampValue"  [arg-type]
                executed_at=TimestampValue(self.timestamp.value),
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\types.py:193:23: error: Argument
"timeframe" to "MarketData" has incompatible type "str"; expected "Timeframe" 
[arg-type]
                timeframe=self.timeframe,  # ѕроста€ строка
                          ^~~~~~~~~~~~~~
infrastructure\simulation\backtester\types.py:194:23: error: Argument
"timestamp" to "MarketData" has incompatible type "Timestamp"; expected
"TimestampValue"  [arg-type]
                timestamp=DomainTimestamp(self.timestamp),
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\types.py:225:16: error: Unexpected keyword
argument "entry_price" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\backtester\types.py:225:16: error: Unexpected keyword
argument "stop_loss" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\backtester\types.py:225:16: error: Unexpected keyword
argument "take_profit" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\backtester\types.py:225:16: error: Unexpected keyword
argument "volume" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\backtester\types.py:225:16: error: Unexpected keyword
argument "leverage" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\backtester\types.py:225:16: error: Unexpected keyword
argument "tags" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\backtester\types.py:225:16: error: Unexpected keyword
argument "timeframe" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\backtester\types.py:225:16: error: Unexpected keyword
argument "risk" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\backtester\types.py:225:16: error: Unexpected keyword
argument "generated_by" for "Signal"  [call-arg]
            return DomainSignal(
                   ^
infrastructure\simulation\backtester\trade_executor.py:132:62: error: "Trade"
has no attribute "fee"  [attr-defined]
    ...            return closed_trade, balance - float(closed_trade.fee.valu...
                                                        ^~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\trade_executor.py:153:25: error:
Unexpected keyword argument "volume" for "Trade"  [call-arg]
                    trade = Trade(
                            ^
infrastructure\simulation\backtester\trade_executor.py:153:25: error:
Unexpected keyword argument "executed_at" for "Trade"  [call-arg]
                    trade = Trade(
                            ^
infrastructure\simulation\backtester\trade_executor.py:153:25: error:
Unexpected keyword argument "fee" for "Trade"  [call-arg]
                    trade = Trade(
                            ^
infrastructure\simulation\backtester\trade_executor.py:153:25: error:
Unexpected keyword argument "realized_pnl" for "Trade"  [call-arg]
                    trade = Trade(
                            ^
infrastructure\simulation\backtester\trade_executor.py:153:25: error:
Unexpected keyword argument "metadata" for "Trade"  [call-arg]
                    trade = Trade(
                            ^
infrastructure\simulation\backtester\trade_executor.py:154:32: error: Argument
1 to "TradeId" has incompatible type "str"; expected "UUID"  [arg-type]
                        id=TradeId(str(uuid4())),
                                   ^~~~~~~~~~~~
infrastructure\simulation\backtester\trade_executor.py:317:21: error:
Unexpected keyword argument "volume" for "Trade"  [call-arg]
                trade = Trade(
                        ^
infrastructure\simulation\backtester\trade_executor.py:317:21: error:
Unexpected keyword argument "executed_at" for "Trade"  [call-arg]
                trade = Trade(
                        ^
infrastructure\simulation\backtester\trade_executor.py:317:21: error:
Unexpected keyword argument "fee" for "Trade"  [call-arg]
                trade = Trade(
                        ^
infrastructure\simulation\backtester\trade_executor.py:317:21: error:
Unexpected keyword argument "realized_pnl" for "Trade"  [call-arg]
                trade = Trade(
                        ^
infrastructure\simulation\backtester\trade_executor.py:317:21: error:
Unexpected keyword argument "metadata" for "Trade"  [call-arg]
                trade = Trade(
                        ^
infrastructure\simulation\backtester\trade_executor.py:318:28: error: Argument
1 to "TradeId" has incompatible type "str"; expected "UUID"  [arg-type]
                    id=TradeId(str(uuid4())),  # √енерируем новый UUID
                               ^~~~~~~~~~~~
infrastructure\simulation\backtester\trade_executor.py:452:17: error: "object"
has no attribute "append"  [attr-defined]
                    summary["positions"].append(position_data)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:295:20: error: Incompatible
return value type (got "float", expected "Series")  [return-value]
                return (data - min_val) / (max_val - min_val)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:295:21: error: Unsupported
operand types for - ("Series" and "float")  [operator]
                return (data - min_val) / (max_val - min_val)
                        ^
infrastructure\services\enhanced_trading\utils.py:302:20: error: Incompatible
return value type (got "float", expected "Series")  [return-value]
                return (data - mean_val) / std_val
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:302:21: error: Unsupported
operand types for - ("Series" and "float")  [operator]
                return (data - mean_val) / std_val
                        ^
infrastructure\services\enhanced_trading\utils.py:321:12: error: "Series" has
no attribute "rolling"  [attr-defined]
        return returns.rolling(window=window).std()
               ^~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:328:22: error: Unsupported
operand types for - ("Series" and "float")  [operator]
        excess_returns = returns - risk_free_rate / 252  # ƒневна€ безриск...
                         ^
infrastructure\services\enhanced_trading\utils.py:330:22: error: "float" has no
attribute "mean"  [attr-defined]
            return float(excess_returns.mean() / returns.std() * np.sqrt(2...
                         ^~~~~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:339:26: error: "int" has no
attribute "cumprod"  [attr-defined]
        cumulative_returns = (1 + returns).cumprod()
                             ^~~~~~~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:339:31: error: Unsupported
operand types for + ("int" and "Series")  [operator]
        cumulative_returns = (1 + returns).cumprod()
                                  ^~~~~~~
infrastructure\services\enhanced_trading\utils.py:350:16: error: "DataFrame"
has no attribute "dropna"  [attr-defined]
        clean_df = returns_df.dropna()
                   ^~~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:367:14: error: "Series" has
no attribute "quantile"  [attr-defined]
            q1 = data.quantile(0.25)
                 ^~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:368:14: error: "Series" has
no attribute "quantile"  [attr-defined]
            q3 = data.quantile(0.75)
                 ^~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:374:28: error: Unsupported
operand types for - ("Series" and "float")  [operator]
            z_scores = np.abs((data - data.mean()) / data.std())
                               ^
infrastructure\services\enhanced_trading\utils.py:377:43: error: "Series" has
no attribute "index"  [attr-defined]
            outliers = pd.Series(False, index=data.index)
                                              ^~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:386:16: error: "Series" has
no attribute "rolling"  [attr-defined]
            return data.rolling(window=window).mean()
                   ^~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:388:16: error: "Series" has
no attribute "ewm"  [attr-defined]
            return data.ewm(span=window).mean()
                   ^~~~~~~~
infrastructure\services\enhanced_trading\utils.py:390:16: error: "Series" has
no attribute "rolling"  [attr-defined]
            return data.rolling(window=window).median()
                   ^~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:402:16: error: "Series" has
no attribute "rolling"  [attr-defined]
            return prices.rolling(window=window).mean()
                   ^~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:404:16: error: "Series" has
no attribute "ewm"  [attr-defined]
            return prices.ewm(span=window).mean()
                   ^~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:407:16: error: "Series" has
no attribute "rolling"  [attr-defined]
            return prices.rolling(window=window).apply(
                   ^~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:411:16: error: "Series" has
no attribute "rolling"  [attr-defined]
            return prices.rolling(window=window).mean()
                   ^~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:421:11: error: "Series" has
no attribute "rolling"  [attr-defined]
        std = prices.rolling(window=window).std()
              ^~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:431:13: error: "Series" has
no attribute "diff"  [attr-defined]
        delta = prices.diff()
                ^~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:452:17: error: Unsupported
left operand type for - ("Series")  [operator]
        macd_line = ema_fast - ema_slow
                    ^~~~~~~~~~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:464:11: error: Unsupported
left operand type for - ("Series")  [operator]
        tr1 = high - low
              ^~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:465:22: error: "Series" has
no attribute "shift"  [attr-defined]
        tr2 = abs(high - close.shift(1))
                         ^~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:466:21: error: "Series" has
no attribute "shift"  [attr-defined]
        tr3 = abs(low - close.shift(1))
                        ^~~~~~~~~~~
infrastructure\services\enhanced_trading\utils.py:467:10: error: Module has no
attribute "concat"  [attr-defined]
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
             ^~~~~~~~~
infrastructure\repositories\trading\analyzers.py:56:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\core\strategy.py:84:24: error: Argument 1 to "len" has
incompatible type "Price"; expected "Sized"  [arg-type]
                    or len(market_data.close) < 20
                           ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:88:35: error: "Price" has no attribute "iloc" 
[attr-defined]
                current_price = float(market_data.close.iloc[-1])
                                      ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:91:39: error: "Price" has no attribute "tolist"
 [attr-defined]
                ema = self._calculate_ema(market_data.close.tolist(), ema_...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:338:29: error: Argument 1 to "append" of "list"
has incompatible type "Price"; expected "float"  [arg-type]
            self.fast_ma.append(market_data.close)
                                ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:339:29: error: Argument 1 to "append" of "list"
has incompatible type "Price"; expected "float"  [arg-type]
            self.slow_ma.append(market_data.close)
                                ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:340:31: error: Argument 1 to "append" of "list"
has incompatible type "Price"; expected "float"  [arg-type]
            self.signal_ma.append(market_data.close)
                                  ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:360:34: error: "MarketData" has no attribute
"pair"  [attr-defined]
                                pair=market_data.pair,
                                     ^~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:362:35: error: Argument "price" to "Signal" has
incompatible type "Price"; expected "float"  [arg-type]
                                price=market_data.close,
                                      ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:364:39: error: Argument "stop_loss" to "Signal"
has incompatible type "Price"; expected "float | None"  [arg-type]
                                stop_loss=market_data.close * 0.95,
                                          ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:365:41: error: Argument "take_profit" to
"Signal" has incompatible type "Price"; expected "float | None"  [arg-type]
                                take_profit=market_data.close * 1.05,
                                            ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:373:34: error: "MarketData" has no attribute
"pair"  [attr-defined]
                                pair=market_data.pair,
                                     ^~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:375:35: error: Argument "price" to "Signal" has
incompatible type "Price"; expected "float"  [arg-type]
                                price=market_data.close,
                                      ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:377:39: error: Argument "stop_loss" to "Signal"
has incompatible type "Price"; expected "float | None"  [arg-type]
                                stop_loss=market_data.close * 1.05,
                                          ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:378:41: error: Argument "take_profit" to
"Signal" has incompatible type "Price"; expected "float | None"  [arg-type]
                                take_profit=market_data.close * 0.95,
                                            ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:438:28: error: Argument 1 to "append" of "list"
has incompatible type "Price"; expected "float"  [arg-type]
            self.prices.append(market_data.close)
                               ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:449:30: error: "MarketData" has no attribute
"pair"  [attr-defined]
                            pair=market_data.pair,
                                 ^~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:451:31: error: Argument "price" to "Signal" has
incompatible type "Price"; expected "float"  [arg-type]
                            price=market_data.close,
                                  ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:453:35: error: Argument "stop_loss" to "Signal"
has incompatible type "Price"; expected "float | None"  [arg-type]
                            stop_loss=market_data.close * 0.95,
                                      ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:454:37: error: Argument "take_profit" to
"Signal" has incompatible type "Price"; expected "float | None"  [arg-type]
                            take_profit=market_data.close * 1.05,
                                        ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:460:30: error: "MarketData" has no attribute
"pair"  [attr-defined]
                            pair=market_data.pair,
                                 ^~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:462:31: error: Argument "price" to "Signal" has
incompatible type "Price"; expected "float"  [arg-type]
                            price=market_data.close,
                                  ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:464:35: error: Argument "stop_loss" to "Signal"
has incompatible type "Price"; expected "float | None"  [arg-type]
                            stop_loss=market_data.close * 1.05,
                                      ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:465:37: error: Argument "take_profit" to
"Signal" has incompatible type "Price"; expected "float | None"  [arg-type]
                            take_profit=market_data.close * 0.95,
                                        ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:538:28: error: Argument 1 to "append" of "list"
has incompatible type "Price"; expected "float"  [arg-type]
            self.prices.append(market_data.close)
                               ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:552:30: error: "MarketData" has no attribute
"pair"  [attr-defined]
                            pair=market_data.pair,
                                 ^~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:554:31: error: Argument "price" to "Signal" has
incompatible type "Price"; expected "float"  [arg-type]
                            price=market_data.close,
                                  ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:556:35: error: Argument "stop_loss" to "Signal"
has incompatible type "Price"; expected "float | None"  [arg-type]
                            stop_loss=market_data.close * 0.95,
                                      ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:557:37: error: Argument "take_profit" to
"Signal" has incompatible type "Price"; expected "float | None"  [arg-type]
                            take_profit=market_data.close * 1.05,
                                        ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:567:30: error: "MarketData" has no attribute
"pair"  [attr-defined]
                            pair=market_data.pair,
                                 ^~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:569:31: error: Argument "price" to "Signal" has
incompatible type "Price"; expected "float"  [arg-type]
                            price=market_data.close,
                                  ^~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:571:35: error: Argument "stop_loss" to "Signal"
has incompatible type "Price"; expected "float | None"  [arg-type]
                            stop_loss=market_data.close * 1.05,
                                      ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\strategy.py:572:37: error: Argument "take_profit" to
"Signal" has incompatible type "Price"; expected "float | None"  [arg-type]
                            take_profit=market_data.close * 0.95,
                                        ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\optimized_database.py:324:51: error: Unsupported operand
types for + ("object" and "int")  [operator]
            self.performance_metrics["query_count"] = query_count + 1
                                                      ^
infrastructure\core\optimized_database.py:325:56: error: Unsupported operand
types for + ("object" and "float")  [operator]
    ...  self.performance_metrics["total_query_time"] = total_query_time + ex...
                                                        ^
infrastructure\core\optimized_database.py:355:50: error: Unsupported operand
types for + ("object" and "int")  [operator]
            self.performance_metrics["cache_hits"] = cache_hits + 1
                                                     ^
infrastructure\core\optimized_database.py:361:52: error: Unsupported operand
types for + ("object" and "int")  [operator]
            self.performance_metrics["cache_misses"] = cache_misses + 1
                                                       ^
infrastructure\core\optimized_database.py:387:34: error: Argument "side" to
"Trade" has incompatible type "str"; expected
"Literal['buy', 'sell', 'hold', 'close', 'strong_buy', 'strong_sell']" 
[arg-type]
                                side=side,
                                     ^~~~
infrastructure\core\optimized_database.py:390:56: error: Argument 1 to
"TimestampValue" has incompatible type "Timestamp | DatetimeIndex | Any";
expected "datetime"  [arg-type]
    ...                      executed_at=TimestampValue(pd.to_datetime(row[5]...
                                                        ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\optimized_database.py:459:12: error: Unsupported operand
types for < ("int" and "object")  [operator]
            if query_count > 0:
               ^
infrastructure\core\optimized_database.py:463:41: error: Unsupported left
operand type for / ("object")  [operator]
                metrics["avg_query_time"] = total_query_time / query_count
                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\optimized_database.py:464:55: error: Unsupported left
operand type for + ("object")  [operator]
    ...       metrics["cache_hit_rate"] = cache_hits / (cache_hits + cache_mi...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\database.py:96:18: error: Item "None" of "Engine | None"
has no attribute "connect"  [union-attr]
                with self.engine.connect() as connection:
                     ^~~~~~~~~~~~~~~~~~~
infrastructure\core\database.py:168:18: error: Item "None" of "Engine | None"
has no attribute "connect"  [union-attr]
                with self.engine.connect() as connection:
                     ^~~~~~~~~~~~~~~~~~~
infrastructure\core\database.py:272:30: error: Argument "side" to "Trade" has
incompatible type "str"; expected
"Literal['buy', 'sell', 'hold', 'close', 'strong_buy', 'strong_sell']" 
[arg-type]
                            side=str(row[2]) if str(row[2]) in ["buy", "se...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\database.py:275:52: error: Argument 1 to "TimestampValue"
has incompatible type "Timestamp | DatetimeIndex | Any"; expected "datetime" 
[arg-type]
    ...                      executed_at=TimestampValue(pd.to_datetime(row[5]...
                                                        ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\database.py:316:25: error: "TimestampValue" has no
attribute "to_iso"  [attr-defined]
                            trade.executed_at.to_iso(),
                            ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\backtest_manager.py:24:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\core\backtest_manager.py:25:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\core\backtest_manager.py:158:17: error: Unexpected keyword
argument "volume" for "Order"  [call-arg]
            order = Order(
                    ^
infrastructure\core\backtest_manager.py:172:18: error: Argument "side" to
"Trade" has incompatible type "OrderSide"; expected
"Literal['buy', 'sell', 'hold', 'close', 'strong_buy', 'strong_sell']" 
[arg-type]
                side=order.side,
                     ^~~~~~~~~~
infrastructure\core\backtest_manager.py:173:20: error: "Order" has no attribute
"volume"  [attr-defined]
                volume=order.volume,
                       ^~~~~~~~~~~~
infrastructure\core\backtest_manager.py:174:19: error: Argument "price" to
"Trade" has incompatible type "Price | None"; expected "Price"  [arg-type]
                price=order.price,
                      ^~~~~~~~~~~
infrastructure\core\backtest_manager.py:182:20: error: "Order" has no attribute
"volume"  [attr-defined]
                cost = order.volume.value * order.price.value
                       ^~~~~~~~~~~~
infrastructure\core\backtest_manager.py:182:41: error: Item "None" of
"Price | None" has no attribute "value"  [union-attr]
                cost = order.volume.value * order.price.value
                                            ^~~~~~~~~~~~~~~~~
infrastructure\core\backtest_manager.py:188:23: error: "Order" has no attribute
"volume"  [attr-defined]
                revenue = order.volume.value * order.price.value
                          ^~~~~~~~~~~~
infrastructure\core\backtest_manager.py:188:44: error: Item "None" of
"Price | None" has no attribute "value"  [union-attr]
                revenue = order.volume.value * order.price.value
                                               ^~~~~~~~~~~~~~~~~
infrastructure\agents\portfolio\services.py:11:1: error: Module
"domain.entities.portfolio" has no attribute "PortfolioState"; maybe
"PortfolioStatus" or "Portfolio"?  [attr-defined]
    from domain.entities.portfolio import PortfolioState
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\portfolio\services.py:13:10: error: Incompatible types in
assignment (expression has type "logging.Logger", variable has type
"loguru.Logger")  [assignment]
    logger = setup_logger(__name__)
             ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\portfolio\services.py:74:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\agents\order_executor\services.py:380:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\base_strategy.py:15:1: error: Module "domain.types" has no
attribute "StrategyType"  [attr-defined]
    from domain.types import StrategyId, StrategyType, TradingPair
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\session_service.py:9:1: error: Module
"domain.types.session_types" has no attribute "SessionPrediction"; maybe
"SessionTransition"?  [attr-defined]
    from domain.types.session_types import (
    ^
domain\sessions\session_service.py:135:13: error: Dict entry 6 has incompatible
type "str": "str | None"; expected "str": "str | float | int"  [dict-item]
                "last_analysis_time": (
                ^
domain\sessions\session_service.py:138:13: error: Dict entry 7 has incompatible
type "str": "str | None"; expected "str": "str | float | int"  [dict-item]
                "last_optimization_time": (
                ^
domain\sessions\session_service.py:143:13: error: Dict entry 8 has incompatible
type "str": "str | None"; expected "str": "str | float | int"  [dict-item]
                "last_prediction_time": (
                ^
domain\sessions\session_service.py:151:13: error: Dict entry 12 has
incompatible type "str": "str | None"; expected "str": "str | float | int" 
[dict-item]
                "last_error": self.last_error,
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\session_service.py:305:45: error: Trying to read deleted
variable "e"  [misc]
                    self.state.last_error = str(e)
                                                ^
domain\sessions\session_service.py:305:45: error: Name "e" is used before
definition  [used-before-def]
                    self.state.last_error = str(e)
                                                ^
domain\sessions\session_service.py:355:45: error: Trying to read deleted
variable "e"  [misc]
                    self.state.last_error = str(e)
                                                ^
domain\sessions\session_service.py:355:45: error: Name "e" is used before
definition  [used-before-def]
                    self.state.last_error = str(e)
                                                ^
domain\sessions\session_service.py:378:16: error: Incompatible return value
type (got "dict[str, object]", expected "dict[str, str | float | int]") 
[return-value]
            return self.session_marker.get_session_context(timestamp).to_d...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\sessions\session_service.py:439:24: error: Incompatible return value
type (got "dict[str, float]", expected "dict[str, str | float | int]") 
[return-value]
                    return self.data_repository.get_session_statistics(
                           ^
domain\sessions\session_service.py:439:24: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
domain\sessions\session_service.py:439:24: note: Consider using "Mapping" instead, which is covariant in the value type
domain\sessions\session_service.py:453:17: error: Dict entry 0 has incompatible
type "str": "dict[str, str | float | int | bool]"; expected "str":
"str | float | int | None"  [dict-item]
                    "service_state": self.state.to_dict(),
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\session_service.py:454:17: error: Dict entry 1 has incompatible
type "str": "dict[str, str | float | int | bool | None]"; expected "str":
"str | float | int | None"  [dict-item]
                    "config": self.config.to_dict(),
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\session_service.py:455:17: error: Dict entry 2 has incompatible
type "str": "dict[str, bool]"; expected "str": "str | float | int | None" 
[dict-item]
                    "components": {
                    ^
domain\sessions\session_service.py:501:30: error: Cannot instantiate abstract
class "BaseSessionAnalyzer" with abstract attributes "analyze_session" and
"get_session_context"  [abstract]
                dummy_analyzer = BaseSessionAnalyzer()
                                 ^~~~~~~~~~~~~~~~~~~~~
domain\sessions\session_service.py:501:30: error: Missing positional argument
"registry" in call to "BaseSessionAnalyzer"  [call-arg]
                dummy_analyzer = BaseSessionAnalyzer()
                                 ^~~~~~~~~~~~~~~~~~~~~
domain\sessions\factories.py:44:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\sessions\factories.py:45:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\sessions\factories.py:46:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\sessions\factories.py:51:30: error: Incompatible types in assignment
(expression has type "SessionProfileRegistry", variable has type
"SessionRegistry | None")  [assignment]
                self._registry = SessionProfileRegistry()
                                 ^~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\factories.py:53:16: error: Incompatible return value type (got
"SessionRegistry | None", expected "SessionRegistry")  [return-value]
            return self._registry
                   ^~~~~~~~~~~~~~
domain\sessions\factories.py:95:24: error: Incompatible types in assignment
(expression has type "SessionProfileRegistry", variable has type
"SessionRegistry | None")  [assignment]
                registry = SessionProfileRegistry()
                           ^~~~~~~~~~~~~~~~~~~~~~~~
domain\sessions\factories.py:96:30: error: Argument 1 to "SessionMarker" has
incompatible type "SessionRegistry"; expected "SessionProfileRegistry | None" 
[arg-type]
            return SessionMarker(registry)
                                 ^~~~~~~~
domain\services\market_metrics.py:71:31: error: "DataFrame" has no attribute
"get"  [attr-defined]
            closes = _safe_series(data.get("close", pd.Series(dtype=float)...
                                  ^~~~~~~~
domain\services\market_metrics.py:73:12: error: "Series" has no attribute
"dtype"  [attr-defined]
            if closes.dtype == "object":
               ^~~~~~~~~~~~
domain\services\market_metrics.py:74:22: error: Module has no attribute
"to_numeric"  [attr-defined]
                closes = pd.to_numeric(closes, errors="coerce").fillna(0.0...
                         ^~~~~~~~~~~~~
domain\services\market_metrics.py:104:31: error: "DataFrame" has no attribute
"get"  [attr-defined]
            closes = _safe_series(data.get("close", pd.Series(dtype=float)...
                                  ^~~~~~~~
domain\services\market_metrics.py:106:12: error: "Series" has no attribute
"dtype"  [attr-defined]
            if closes.dtype == "object":
               ^~~~~~~~~~~~
domain\services\market_metrics.py:107:22: error: Module has no attribute
"to_numeric"  [attr-defined]
                closes = pd.to_numeric(closes, errors="coerce").fillna(0.0...
                         ^~~~~~~~~~~~~
domain\services\market_metrics.py:113:20: error: "Series" has no attribute
"rolling"  [attr-defined]
            ma_short = closes.rolling(window=window // 2).mean()
                       ^~~~~~~~~~~~~~
domain\services\market_metrics.py:114:19: error: "Series" has no attribute
"rolling"  [attr-defined]
            ma_long = closes.rolling(window=window).mean()
                      ^~~~~~~~~~~~~~
domain\services\market_metrics.py:133:17: error: "Series" has no attribute
"diff"  [attr-defined]
                    closes.diff().apply(np.sign)
                    ^~~~~~~~~~~
domain\services\market_metrics.py:159:32: error: "DataFrame" has no attribute
"get"  [attr-defined]
            volumes = _safe_series(data.get("volume", pd.Series(dtype=floa...
                                   ^~~~~~~~
domain\services\market_metrics.py:161:12: error: "Series" has no attribute
"dtype"  [attr-defined]
            if volumes.dtype == "object":
               ^~~~~~~~~~~~~
domain\services\market_metrics.py:162:23: error: Module has no attribute
"to_numeric"  [attr-defined]
                volumes = pd.to_numeric(volumes, errors="coerce").fillna(0...
                          ^~~~~~~~~~~~~
domain\services\market_metrics.py:164:19: error: "Series" has no attribute
"rolling"  [attr-defined]
                float(volumes.rolling(window=window).mean().iloc[-1])
                      ^~~~~~~~~~~~~~~
domain\services\market_metrics.py:169:19: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                float(volumes.iloc[-1] / (volume_ma + 1e-8)) if volume_ma ...
                      ^~~~~~~~~~~~~~~~
domain\services\market_metrics.py:173:29: error: "Series" has no attribute
"rolling"  [attr-defined]
                prev_ma = float(volumes.rolling(window=window).mean().iloc...
                                ^~~~~~~~~~~~~~~
domain\services\market_metrics.py:183:40: error: Argument 1 to "histogram" has
incompatible type "Callable[[], ndarray[Any, Any]]"; expected
"_SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes]"
 [arg-type]
            hist, bin_edges = np.histogram(volumes.values, bins=10)
                                           ^~~~~~~~~~~~~~
domain\services\market_metrics.py:208:32: error: "DataFrame" has no attribute
"get"  [attr-defined]
            closes1 = _safe_series(data1.get("close", pd.Series(dtype=floa...
                                   ^~~~~~~~~
domain\services\market_metrics.py:209:32: error: "DataFrame" has no attribute
"get"  [attr-defined]
            closes2 = _safe_series(data2.get("close", pd.Series(dtype=floa...
                                   ^~~~~~~~~
domain\services\market_metrics.py:211:12: error: "Series" has no attribute
"dtype"  [attr-defined]
            if closes1.dtype == "object":
               ^~~~~~~~~~~~~
domain\services\market_metrics.py:212:23: error: Module has no attribute
"to_numeric"  [attr-defined]
                closes1 = pd.to_numeric(closes1, errors="coerce").fillna(0...
                          ^~~~~~~~~~~~~
domain\services\market_metrics.py:213:12: error: "Series" has no attribute
"dtype"  [attr-defined]
            if closes2.dtype == "object":
               ^~~~~~~~~~~~~
domain\services\market_metrics.py:214:23: error: Module has no attribute
"to_numeric"  [attr-defined]
                closes2 = pd.to_numeric(closes2, errors="coerce").fillna(0...
                          ^~~~~~~~~~~~~
domain\services\market_metrics.py:266:31: error: "DataFrame" has no attribute
"get"  [attr-defined]
            closes = _safe_series(data.get("close", pd.Series(dtype=float)...
                                  ^~~~~~~~
domain\services\market_metrics.py:268:12: error: "Series" has no attribute
"dtype"  [attr-defined]
            if closes.dtype == "object":
               ^~~~~~~~~~~~
domain\services\market_metrics.py:269:22: error: Module has no attribute
"to_numeric"  [attr-defined]
                closes = pd.to_numeric(closes, errors="coerce").fillna(0.0...
                         ^~~~~~~~~~~~~
domain\services\market_metrics.py:278:22: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            change = abs(closes.iloc[-1] - closes.iloc[0])
                         ^~~~~~~~~~~~~~~
domain\services\market_metrics.py:279:36: error: No overload variant of "diff"
matches argument type "Series"  [call-overload]
            volatility = np.sum(np.abs(np.diff(closes)))
                                       ^~~~~~~~~~~~~~~
domain\services\market_metrics.py:279:36: note: Possible overload variants:
domain\services\market_metrics.py:279:36: note:     def [_T] diff(a: _T, n: Literal[0], axis: SupportsIndex = ..., prepend: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] = ..., append: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] = ...) -> _T
domain\services\market_metrics.py:279:36: note:     def diff(a: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], n: int = ..., axis: SupportsIndex = ..., prepend: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] = ..., append: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] = ...) -> ndarray[Any, dtype[Any]]
domain\services\market_metrics.py:286:15: error: Unsupported operand types for
- ("Series" and "float")  [operator]
            dev = closes - mean
                  ^
domain\services\market_metrics.py:287:13: error: "float" has no attribute
"cumsum"  [attr-defined]
            Z = dev.cumsum()
                ^~~~~~~~~~
domain\services\market_metrics.py:368:31: error: "DataFrame" has no attribute
"get"  [attr-defined]
            closes = _safe_series(data.get("close", pd.Series(dtype=float)...
                                  ^~~~~~~~
domain\services\market_metrics.py:369:32: error: "DataFrame" has no attribute
"get"  [attr-defined]
            volumes = _safe_series(data.get("volume", pd.Series(dtype=floa...
                                   ^~~~~~~~
domain\services\market_metrics.py:371:12: error: "Series" has no attribute
"dtype"  [attr-defined]
            if closes.dtype == "object":
               ^~~~~~~~~~~~
domain\services\market_metrics.py:372:22: error: Module has no attribute
"to_numeric"  [attr-defined]
                closes = pd.to_numeric(closes, errors="coerce").fillna(0.0...
                         ^~~~~~~~~~~~~
domain\services\market_metrics.py:373:12: error: "Series" has no attribute
"dtype"  [attr-defined]
            if volumes.dtype == "object":
               ^~~~~~~~~~~~~
domain\services\market_metrics.py:374:23: error: Module has no attribute
"to_numeric"  [attr-defined]
                volumes = pd.to_numeric(volumes, errors="coerce").fillna(0...
                          ^~~~~~~~~~~~~
domain\services\market_metrics.py:377:21: error: "Series" has no attribute
"diff"  [attr-defined]
                delta = closes.diff()
                        ^~~~~~~~~~~
domain\services\market_metrics.py:386:21: error: "Series" has no attribute
"ewm"  [attr-defined]
                ema12 = closes.ewm(span=12).mean()
                        ^~~~~~~~~~
domain\services\market_metrics.py:387:21: error: "Series" has no attribute
"ewm"  [attr-defined]
                ema26 = closes.ewm(span=26).mean()
                        ^~~~~~~~~~
domain\services\market_metrics.py:393:22: error: "Series" has no attribute
"rolling"  [attr-defined]
                low_14 = closes.rolling(window=14).min()
                         ^~~~~~~~~~~~~~
domain\services\market_metrics.py:394:23: error: "Series" has no attribute
"rolling"  [attr-defined]
                high_14 = closes.rolling(window=14).max()
                          ^~~~~~~~~~~~~~
domain\services\market_metrics.py:395:26: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                last_close = closes.iloc[-1] if len(closes) > 0 else 0.0
                             ^~~~~~~~~~~~~~~
domain\services\market_metrics.py:405:23: error: "Series" has no attribute
"rolling"  [attr-defined]
                high_14 = closes.rolling(window=14).max()
                          ^~~~~~~~~~~~~~
domain\services\market_metrics.py:406:22: error: "Series" has no attribute
"rolling"  [attr-defined]
                low_14 = closes.rolling(window=14).min()
                         ^~~~~~~~~~~~~~
domain\services\market_metrics.py:407:26: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                last_close = closes.iloc[-1] if len(closes) > 0 else 0.0
                             ^~~~~~~~~~~~~~~
domain\services\market_metrics.py:417:21: error: "Series" has no attribute
"diff"  [attr-defined]
            price_mom = closes.diff().mean() if len(closes) > 1 else 0.0
                        ^~~~~~~~~~~
domain\services\market_metrics.py:418:22: error: "Series" has no attribute
"diff"  [attr-defined]
            volume_mom = volumes.diff().mean() if len(volumes) > 1 else 0....
                         ^~~~~~~~~~~~
domain\services\market_metrics.py:444:31: error: "DataFrame" has no attribute
"get"  [attr-defined]
            closes = _safe_series(data.get("close", pd.Series(dtype=float)...
                                  ^~~~~~~~
domain\services\market_metrics.py:446:12: error: "Series" has no attribute
"dtype"  [attr-defined]
            if closes.dtype == "object":
               ^~~~~~~~~~~~
domain\services\market_metrics.py:447:22: error: Module has no attribute
"to_numeric"  [attr-defined]
                closes = pd.to_numeric(closes, errors="coerce").fillna(0.0...
                         ^~~~~~~~~~~~~
domain\protocols\utils.py:214:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\utils.py:215:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\utils.py:216:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\utils.py:217:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\security.py:243:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\security.py:244:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\security.py:245:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\security.py:376:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\security.py:377:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\security.py:378:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\security.py:432:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\security.py:433:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\security.py:530:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\monitoring.py:148:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\monitoring.py:149:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\monitoring.py:150:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\monitoring.py:151:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\monitoring.py:294:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\monitoring.py:295:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\monitoring.py:380:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\monitoring.py:381:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\monitoring.py:436:40: error: Incompatible types in assignment
(expression has type "None", target has type "HealthCheck")  [assignment]
                    health_results[name] = None
                                           ^~~~
domain\protocols\monitoring.py:464:16: error: No overload variant of "str"
matches argument type "str"  [call-overload]
            return HealthStatus(status="healthy")
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\protocols\monitoring.py:464:16: note: Possible overload variants:
domain\protocols\monitoring.py:464:16: note:     def __new__(cls, object: object = ...) -> str
domain\protocols\monitoring.py:464:16: note:     def __new__(cls, object: Buffer, encoding: str = ..., errors: str = ...) -> str
domain\protocols\monitoring.py:469:16: error: No overload variant of "str"
matches argument type "str"  [call-overload]
            return HealthStatus(status=overall_health.value)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\protocols\monitoring.py:469:16: note: Possible overload variants:
domain\protocols\monitoring.py:469:16: note:     def __new__(cls, object: object = ...) -> str
domain\protocols\monitoring.py:469:16: note:     def __new__(cls, object: Buffer, encoding: str = ..., errors: str = ...) -> str
domain\protocols\monitoring.py:477:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\monitoring.py:815:16: error: No overload variant of "str"
matches argument type "Any"  [call-overload]
            return HealthStatus(status=overall_health.value)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\protocols\monitoring.py:815:16: note: Possible overload variants:
domain\protocols\monitoring.py:815:16: note:     def __new__(cls, object: object = ...) -> str
domain\protocols\monitoring.py:815:16: note:     def __new__(cls, object: Buffer, encoding: str = ..., errors: str = ...) -> str
domain\protocols\decorators.py:151:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\decorators.py:152:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\decorators.py:153:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\decorators.py:154:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\decorators.py:228:34: error: Incompatible types in assignment
(expression has type "float", variable has type "None")  [assignment]
            self.last_success_time = time.time()
                                     ^~~~~~~~~~~
domain\protocols\decorators.py:235:34: error: Incompatible types in assignment
(expression has type "float", variable has type "None")  [assignment]
            self.last_failure_time = time.time()
                                     ^~~~~~~~~~~
domain\protocols\decorators.py:257:27: error: Incompatible types in assignment
(expression has type "float", variable has type "int")  [assignment]
                self.tokens = min(self.config.max_calls, self.tokens + tok...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\protocols\decorators.py:590:16: error: Incompatible return value type
(got "_Wrapped[[VarArg(Any), KwArg(Any)], Any, [VarArg(Any), KwArg(Any)], Any]",
expected "F")  [return-value]
            return async_wrapper if asyncio.iscoroutinefunction(func) else...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\protocols\decorators.py:705:16: error: Incompatible return value type
(got "_Wrapped[[VarArg(Any), KwArg(Any)], Any, [VarArg(Any), KwArg(Any)], Any]",
expected "F")  [return-value]
            return async_wrapper if asyncio.iscoroutinefunction(func) else...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\entities\portfolio_fixed.py:510:83: error: "bool" not callable 
[operator]
    ...r in self.orders if hasattr(order, 'is_filled') and order.is_filled()]
                                                           ^~~~~~~~~~~~~~~~~
domain\entities\portfolio_fixed.py:514:86: error: "bool" not callable 
[operator]
    ...elf.orders if hasattr(order, 'is_cancelled') and order.is_cancelled()]
                                                        ^~~~~~~~~~~~~~~~~~~~
application\analysis\entanglement_monitor.py:361:13: error: Need type
annotation for "history" (hint: "history: list[<type>] = ...")  [var-annotated]
                history = []
                ^~~~~~~
tests\unit\test_protocols_monitoring.py:32:16: error: Extra key
"health_check_interval" for TypedDict "MonitoringConfig" 
[typeddict-unknown-key]
            return MonitoringConfig(
                   ^
tests\unit\test_protocols_monitoring.py:149:18: error: Incompatible types in
"await" (actual type "str", expected type "Awaitable[Any]")  [misc]
            status = await health_checker.perform_health_check()
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_monitoring.py:155:9: error: Cannot assign to a method
 [method-assign]
            health_checker.perform_health_check = AsyncMock(
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_monitoring.py:203:23: error: Extra key "timestamp"
for TypedDict "SystemMetrics"  [typeddict-unknown-key]
            sys_metrics = SystemMetrics(
                          ^
tests\unit\test_backtest_manager.py:29:34: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.DatetimeIndex(pd.date_range('2023-01-01', periods=1...
                                     ^~~~~~~~~~~~~
tests\unit\test_backtest_manager.py:39:9: error: "DataFrame" has no attribute
"loc"  [attr-defined]
            data.loc[:, 'high'] = data[['open', 'close']].max(axis=1) + np...
            ^~~~~~~~
tests\unit\test_backtest_manager.py:40:9: error: "DataFrame" has no attribute
"loc"  [attr-defined]
            data.loc[:, 'low'] = data[['open', 'close']].min(axis=1) - np....
            ^~~~~~~~
tests\performance\test_sessions_performance.py:317:34: error: Module has no
attribute "date_range"  [attr-defined]
            dates = pd.DatetimeIndex(pd.date_range('2023-01-01', periods=1...
                                     ^~~~~~~~~~~~~
tests\integration\test_sessions_integration.py:282:34: error: Module has no
attribute "date_range"  [attr-defined]
            dates = pd.DatetimeIndex(pd.date_range('2023-01-01', periods=1...
                                     ^~~~~~~~~~~~~
tests\e2e\test_sessions_e2e.py:311:39: error: Module has no attribute
"date_range"  [attr-defined]
            timestamps = pd.DatetimeIndex(pd.date_range('2024-01-01', peri...
                                          ^~~~~~~~~~~~~
tests\e2e\test_sessions_e2e.py:339:44: error: Argument 1 has incompatible type
"list[MarketRegime]"; expected
"_SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes]"
 [arg-type]
                market_regime=np.random.choice(list(MarketRegime)),
                                               ^~~~~~~~~~~~~~~~~~
tests\e2e\test_sessions_e2e.py:340:48: error: Argument 1 has incompatible type
"list[SessionIntensity]"; expected
"_SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes]"
 [arg-type]
                session_intensity=np.random.choice(list(SessionIntensity))
                                                   ^~~~~~~~~~~~~~~~~~~~~~
shared\abstractions\base_service.py:18:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\abstractions\base_service.py:19:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\simulation\simulator.py:93:40: error: "SimulationConfig" has no
attribute "initial_price"  [attr-defined]
                    "current_price": float(self.config.initial_price),
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:96:31: error: "SimulationConfig" has no
attribute "volatility"  [attr-defined]
                    "volatility": self.config.volatility,
                                  ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:97:35: error: "SimulationConfig" has no
attribute "trend_strength"  [attr-defined]
                    "trend_strength": self.config.trend_strength,
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:98:35: error: "SimulationConfig" has no
attribute "mean_reversion"  [attr-defined]
                    "mean_reversion": self.config.mean_reversion,
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:99:32: error: "SimulationConfig" has no
attribute "noise_level"  [attr-defined]
                    "noise_level": self.config.noise_level,
                                   ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:157:16: error: "SimulationConfig" has no
attribute "regime_switching"  [attr-defined]
                if self.config.regime_switching:
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:181:40: error: "SimulationConfig" has no
attribute "initial_price"  [attr-defined]
                    "current_price": float(self.config.initial_price),
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:184:31: error: "SimulationConfig" has no
attribute "volatility"  [attr-defined]
                    "volatility": self.config.volatility,
                                  ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:185:35: error: "SimulationConfig" has no
attribute "trend_strength"  [attr-defined]
                    "trend_strength": self.config.trend_strength,
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:186:35: error: "SimulationConfig" has no
attribute "mean_reversion"  [attr-defined]
                    "mean_reversion": self.config.mean_reversion,
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:187:32: error: "SimulationConfig" has no
attribute "noise_level"  [attr-defined]
                    "noise_level": self.config.noise_level,
                                   ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:189:41: error: "SimulationConfig" has no
attribute "initial_price"  [attr-defined]
                    "price_history": [float(self.config.initial_price)],
                                            ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:201:40: error: "SimulationConfig" has no
attribute "initial_price"  [attr-defined]
                    "current_price": float(self.config.initial_price),
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:204:31: error: "SimulationConfig" has no
attribute "volatility"  [attr-defined]
                    "volatility": self.config.volatility,
                                  ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:205:35: error: "SimulationConfig" has no
attribute "trend_strength"  [attr-defined]
                    "trend_strength": self.config.trend_strength,
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:206:35: error: "SimulationConfig" has no
attribute "mean_reversion"  [attr-defined]
                    "mean_reversion": self.config.mean_reversion,
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:207:32: error: "SimulationConfig" has no
attribute "noise_level"  [attr-defined]
                    "noise_level": self.config.noise_level,
                                   ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:247:32: error: "SimulationConfig" has no
attribute "initial_price"  [attr-defined]
                mean_price = float(self.config.initial_price)
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:288:59: error: "SimulationConfig" has no
attribute "regime_duration"  [attr-defined]
    ...f self.market_state[symbol]["regime_counter"] >= self.config.regime_du...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\simulation\simulator.py:294:30: error: "SimulationConfig" has no
attribute "regime_probability"  [attr-defined]
            if random.random() < self.config.regime_probability:
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\simulator.py:322:13: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                cumulative_prob += prob
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:81:35: error: Argument
"timestamp" to "MarketData" has incompatible type
"str | int | float | bool | datetime"; expected "datetime"  [arg-type]
                            timestamp=idx,
                                      ^~~
infrastructure\simulation\backtester\data_processor.py:87:56: error: "Series"
has no attribute "to_dict"  [attr-defined]
                            metadata={"index": idx, "row": row.to_dict()},
                                                           ^~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:112:24: error: Module
has no attribute "is_numeric_dtype"  [attr-defined]
                    if not pd.api.types.is_numeric_dtype(data[col]):
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:114:16: error:
"DataFrame" has no attribute "isnull"  [attr-defined]
                if data.isnull().any().any():
                   ^~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:115:52: error:
"DataFrame" has no attribute "isnull"  [attr-defined]
    ...              self.metrics.missing_values += int(data.isnull().sum().s...
                                                        ^~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:143:30: error:
"DataFrame" has no attribute "copy"  [attr-defined]
                processed_data = data.copy()
                                 ^~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:169:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["sma_20"] = data["close"].rolling(window=20).mean()
                ^~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:170:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["sma_50"] = data["close"].rolling(window=50).mean()
                ^~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:171:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["sma_200"] = data["close"].rolling(window=200).mean()
                ^~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:173:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["ema_20"] = data["close"].ewm(span=20, adjust=False)....
                ^~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:174:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["ema_50"] = data["close"].ewm(span=50, adjust=False)....
                ^~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:176:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["volatility"] = data["close"].rolling(window=20).std(...
                ^~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:182:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["rsi"] = 100 - (100 / (1 + rs))
                ^~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:186:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["macd"] = exp1 - exp2
                ^~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:187:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["signal"] = data["macd"].ewm(span=9, adjust=False).me...
                ^~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:189:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["bb_middle"] = data["close"].rolling(window=20).mean(...
                ^~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:190:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["bb_std"] = data["close"].rolling(window=20).std()
                ^~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:191:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["bb_upper"] = data["bb_middle"] + (data["bb_std"] * 2...
                ^~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:192:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["bb_lower"] = data["bb_middle"] - (data["bb_std"] * 2...
                ^~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:194:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["tr"] = np.maximum.reduce(
                ^~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:201:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["atr_14"] = data["tr"].rolling(window=14).mean()
                ^~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:210:19: error: "Series"
has no attribute "rolling"  [attr-defined]
                    * pd.Series(plus_dm).rolling(window=14).sum()
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:215:19: error: "Series"
has no attribute "rolling"  [attr-defined]
                    * pd.Series(minus_dm).rolling(window=14).sum()
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:219:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["adx_14"] = dx.rolling(window=14).mean()
                ^~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:221:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["obv"] = (
                ^~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:226:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["cci_20"] = (tp - tp.rolling(20).mean()) / (
                ^~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:230:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["stoch_k"] = (
                ^~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:235:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["stoch_d"] = data["stoch_k"].rolling(3).mean()
                ^~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:237:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["vwap"] = (data["close"] * data["volume"]).cumsum() /...
                ^~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:241:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data["momentum_10"] = data["close"].diff(10)
                ^~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:252:28: error:
"DataFrame" has no attribute "select_dtypes"  [attr-defined]
                numeric_cols = data.select_dtypes(include=[np.number]).col...
                               ^~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:253:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data[numeric_cols] = (data[numeric_cols] - data[numeric_co...
                ^~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:263:28: error:
"DataFrame" has no attribute "select_dtypes"  [attr-defined]
                numeric_cols = data.select_dtypes(include=[np.number]).col...
                               ^~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:264:13: error:
Unsupported target for indexed assignment ("DataFrame")  [index]
                data[numeric_cols] = (data[numeric_cols] - data[numeric_co...
                ^~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:280:13: error:
"DataFrame" has no attribute "dropna"  [attr-defined]
                processed_data.dropna(inplace=True)
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\data_processor.py:281:24: error:
"DataFrame" has no attribute "drop"  [attr-defined]
                features = processed_data.drop(
                           ^~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\services.py:27:31: error: "TradingPair" has
no attribute "symbol"  [attr-defined]
                    "symbol": str(order.trading_pair.symbol),
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\services.py:134:36: error: "TradingPair"
has no attribute "symbol"  [attr-defined]
                "trading_pair_id": str(order.trading_pair.symbol),
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\events.py:169:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\trading\events.py:170:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\trading\events.py:276:31: error: "TradingPair" has
no attribute "symbol"  [attr-defined]
                    "symbol": str(order.trading_pair.symbol),
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\events.py:295:33: error: "TradingPair" has
no attribute "symbol"  [attr-defined]
                data={"symbol": str(order.trading_pair.symbol), "changes":...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\events.py:308:31: error: "TradingPair" has
no attribute "symbol"  [attr-defined]
                    "symbol": str(order.trading_pair.symbol),
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:41:20: error: Unexpected
keyword argument "portfolio_id" for "OrderModel"  [call-arg]
                return OrderModel(
                       ^
infrastructure\repositories\trading\converters.py:43:37: error: "TradingPair"
has no attribute "symbol"  [attr-defined]
                    trading_pair_id=str(order.trading_pair.symbol),
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:207:47: error: "OrderModel"
has no attribute "portfolio_id"  [attr-defined]
                    portfolio_id=PortfolioId(UUID(model.portfolio_id)),
                                                  ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:208:30: error: Argument
"trading_pair" to "Order" has incompatible type
"domain.entities.trading_pair.TradingPair"; expected "domain.types.TradingPair" 
[arg-type]
                    trading_pair=trading_pair,
                                 ^~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:211:26: error: Argument
"quantity" to "Order" has incompatible type "Volume"; expected "VolumeValue" 
[arg-type]
                    quantity=Volume(Decimal(model.quantity), Currency.USD)...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:215:28: error: Argument
"updated_at" to "Order" has incompatible type "Timestamp | None"; expected
"Timestamp"  [arg-type]
                    updated_at=Timestamp.from_iso(model.updated_at) if mod...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\repositories\trading\converters.py:224:20: error: Unexpected
keyword argument "portfolio_id" for "PositionModel"  [call-arg]
                return PositionModel(
                       ^
infrastructure\repositories\trading\converters.py:345:47: error:
"PositionModel" has no attribute "portfolio_id"  [attr-defined]
                    portfolio_id=PortfolioId(UUID(model.portfolio_id)),
                                                  ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:347:22: error: Argument
"side" to "Position" has incompatible type
"domain.types.infrastructure_types.PositionSide"; expected
"domain.entities.position.PositionSide"  [arg-type]
                    side=PositionSide(model.side),
                         ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:349:43: error: Argument 1 to
"Decimal" has incompatible type "str | None"; expected
"Decimal | float | str | tuple[int, Sequence[int], int]"  [arg-type]
                    entry_price=Price(Decimal(model.average_price), Curren...
                                              ^~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:350:45: error: Argument 1 to
"Decimal" has incompatible type "str | None"; expected
"Decimal | float | str | tuple[int, Sequence[int], int]"  [arg-type]
                    current_price=Price(Decimal(model.average_price), Curr...
                                                ^~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:362:28: error: Argument
"updated_at" to "Position" has incompatible type "Timestamp | None"; expected
"Timestamp"  [arg-type]
                    updated_at=Timestamp.from_iso(model.updated_at) if mod...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\repositories\trading\converters.py:377:21: error: Argument
"status" to "TradingPairModel" has incompatible type "PairStatus | str";
expected "str"  [arg-type]
                        trading_pair.status
                        ^
infrastructure\repositories\trading\converters.py:455:31: error: Argument
"base_currency" to "TradingPair" has incompatible type "Currency | None";
expected "Currency"  [arg-type]
                    base_currency=Currency.from_string(model.base_asset),
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:456:32: error: Argument
"quote_currency" to "TradingPair" has incompatible type "Currency | None";
expected "Currency"  [arg-type]
                    quote_currency=Currency.from_string(model.quote_asset)...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\converters.py:459:21: error: Argument
"updated_at" to "TradingPair" has incompatible type "datetime | None"; expected
"datetime"  [arg-type]
                        datetime.fromisoformat(model.updated_at)
                        ^
infrastructure\repositories\trading\converters.py:549:21: error: Argument
"updated_at" to "Account" has incompatible type "datetime | None"; expected
"datetime"  [arg-type]
                        datetime.fromisoformat(model.updated_at)
                        ^
infrastructure\external_services\metrics.py:62:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\external_services\metrics.py:63:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\external_services\metrics.py:64:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\external_services\exchanges\base_exchange_service.py:111:42: error:
Incompatible types in assignment (expression has type "str", target has type
"float | int | None")  [assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\exchanges\base_exchange_service.py:133:42: error:
Incompatible types in assignment (expression has type "str", target has type
"float | int | None")  [assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\exchanges\base_exchange_service.py:197:47: error:
Unsupported operand types for + ("None" and "int")  [operator]
                self.metrics["failed_requests"] = self.metrics.get("failed...
                                                  ^
infrastructure\external_services\exchanges\base_exchange_service.py:197:47: note: Left operand is of type "float | int | None"
infrastructure\external_services\exchanges\base_exchange_service.py:198:42: error:
Incompatible types in assignment (expression has type "str", target has type
"float | int | None")  [assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\exchanges\base_exchange_service.py:242:17: error:
Unsupported target for indexed assignment
("dict[str, Literal['GTC', 'IOC', 'FOK'] | bool] | float | str | None")  [index]
                    order_params["params"]["stopPrice"] = float(request.st...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\exchanges\base_exchange_service.py:242:55: error:
Incompatible types in assignment (expression has type "float", target has type
"Literal['GTC', 'IOC', 'FOK'] | bool")  [assignment]
    ...           order_params["params"]["stopPrice"] = float(request.stop_pr...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\external_services\exchanges\base_exchange_service.py:265:47: error:
Unsupported operand types for + ("None" and "int")  [operator]
                self.metrics["failed_requests"] = self.metrics.get("failed...
                                                  ^
infrastructure\external_services\exchanges\base_exchange_service.py:265:47: note: Left operand is of type "float | int | None"
infrastructure\external_services\exchanges\base_exchange_service.py:266:42: error:
Incompatible types in assignment (expression has type "str", target has type
"float | int | None")  [assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\exchanges\base_exchange_service.py:301:47: error:
Unsupported operand types for + ("None" and "int")  [operator]
                self.metrics["failed_requests"] = self.metrics.get("failed...
                                                  ^
infrastructure\external_services\exchanges\base_exchange_service.py:301:47: note: Left operand is of type "float | int | None"
infrastructure\external_services\exchanges\base_exchange_service.py:302:42: error:
Incompatible types in assignment (expression has type "str", target has type
"float | int | None")  [assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\exchanges\base_exchange_service.py:338:47: error:
Unsupported operand types for + ("None" and "int")  [operator]
                self.metrics["failed_requests"] = self.metrics.get("failed...
                                                  ^
infrastructure\external_services\exchanges\base_exchange_service.py:338:47: note: Left operand is of type "float | int | None"
infrastructure\external_services\exchanges\base_exchange_service.py:339:42: error:
Incompatible types in assignment (expression has type "str", target has type
"float | int | None")  [assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\exchanges\base_exchange_service.py:371:47: error:
Unsupported operand types for + ("None" and "int")  [operator]
                self.metrics["failed_requests"] = self.metrics.get("failed...
                                                  ^
infrastructure\external_services\exchanges\base_exchange_service.py:371:47: note: Left operand is of type "float | int | None"
infrastructure\external_services\exchanges\base_exchange_service.py:372:42: error:
Incompatible types in assignment (expression has type "str", target has type
"float | int | None")  [assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\exchanges\base_exchange_service.py:432:47: error:
Unsupported operand types for + ("None" and "int")  [operator]
                self.metrics["failed_requests"] = self.metrics.get("failed...
                                                  ^
infrastructure\external_services\exchanges\base_exchange_service.py:432:47: note: Left operand is of type "float | int | None"
infrastructure\external_services\exchanges\base_exchange_service.py:433:42: error:
Incompatible types in assignment (expression has type "str", target has type
"float | int | None")  [assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\core\optimizer.py:304:36: error: Unsupported operand types for <
("int" and "Series")  [operator]
                win_rate = len(returns[returns > 0]) / n_trades if n_trade...
                                       ^
infrastructure\core\exchange.py:205:30: error: Argument "trading_pair" to
"Order" has incompatible type "domain.value_objects.trading_pair.TradingPair";
expected "domain.types.TradingPair"  [arg-type]
                    trading_pair=TradingPair(base_currency, quote_currency...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\exchange.py:205:42: error: Argument 1 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
                    trading_pair=TradingPair(base_currency, quote_currency...
                                             ^~~~~~~~~~~~~
infrastructure\core\exchange.py:205:57: error: Argument 2 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...              trading_pair=TradingPair(base_currency, quote_currency),
                                                             ^~~~~~~~~~~~~~
infrastructure\core\exchange.py:287:30: error: Argument "trading_pair" to
"Order" has incompatible type "domain.value_objects.trading_pair.TradingPair";
expected "domain.types.TradingPair"  [arg-type]
                    trading_pair=TradingPair(base_currency, quote_currency...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\exchange.py:287:42: error: Argument 1 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
                    trading_pair=TradingPair(base_currency, quote_currency...
                                             ^~~~~~~~~~~~~
infrastructure\core\exchange.py:287:57: error: Argument 2 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...              trading_pair=TradingPair(base_currency, quote_currency),
                                                             ^~~~~~~~~~~~~~
infrastructure\core\exchange.py:342:34: error: Argument "trading_pair" to
"Order" has incompatible type "domain.value_objects.trading_pair.TradingPair";
expected "domain.types.TradingPair"  [arg-type]
                        trading_pair=TradingPair(base_currency, quote_curr...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\exchange.py:342:46: error: Argument 1 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
                        trading_pair=TradingPair(base_currency, quote_curr...
                                                 ^~~~~~~~~~~~~
infrastructure\core\exchange.py:342:61: error: Argument 2 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...              trading_pair=TradingPair(base_currency, quote_currency),
                                                             ^~~~~~~~~~~~~~
infrastructure\core\exchange.py:416:25: error: Missing positional argument
"portfolio_id" in call to "Position"  [call-arg]
                            Position(
                            ^
infrastructure\core\exchange.py:418:42: error: Argument "trading_pair" to
"Position" has incompatible type
"domain.value_objects.trading_pair.TradingPair"; expected
"domain.entities.trading_pair.TradingPair"  [arg-type]
                                trading_pair=TradingPair(base_currency, qu...
                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\exchange.py:418:54: error: Argument 1 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...                        trading_pair=TradingPair(base_currency, quote_...
                                                        ^~~~~~~~~~~~~
infrastructure\core\exchange.py:418:69: error: Argument 2 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...              trading_pair=TradingPair(base_currency, quote_currency),
                                                             ^~~~~~~~~~~~~~
infrastructure\core\exchange.py:469:38: error: Argument "trading_pair" to
"Trade" has incompatible type "domain.value_objects.trading_pair.TradingPair";
expected "domain.types.TradingPair"  [arg-type]
                            trading_pair=TradingPair(base_currency, quote_...
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\exchange.py:469:50: error: Argument 1 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
                            trading_pair=TradingPair(base_currency, quote_...
                                                     ^~~~~~~~~~~~~
infrastructure\core\exchange.py:469:65: error: Argument 2 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...              trading_pair=TradingPair(base_currency, quote_currency),
                                                             ^~~~~~~~~~~~~~
infrastructure\core\exchange.py:471:29: error: Argument "side" to "Trade" has
incompatible type "domain.entities.order.OrderSide"; expected
"domain.entities.trading.OrderSide"  [arg-type]
                                OrderSide.BUY
                                ^
infrastructure\core\exchange.py:872:30: error: Argument "trading_pair" to
"Order" has incompatible type "domain.value_objects.trading_pair.TradingPair";
expected "domain.types.TradingPair"  [arg-type]
                    trading_pair=TradingPair(base_currency, quote_currency...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\exchange.py:872:42: error: Argument 1 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
                    trading_pair=TradingPair(base_currency, quote_currency...
                                             ^~~~~~~~~~~~~
infrastructure\core\exchange.py:872:57: error: Argument 2 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...              trading_pair=TradingPair(base_currency, quote_currency),
                                                             ^~~~~~~~~~~~~~
infrastructure\core\exchange.py:939:30: error: Argument "trading_pair" to
"Order" has incompatible type "domain.value_objects.trading_pair.TradingPair";
expected "domain.types.TradingPair"  [arg-type]
                    trading_pair=TradingPair(base_currency, quote_currency...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\exchange.py:939:42: error: Argument 1 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
                    trading_pair=TradingPair(base_currency, quote_currency...
                                             ^~~~~~~~~~~~~
infrastructure\core\exchange.py:939:57: error: Argument 2 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...              trading_pair=TradingPair(base_currency, quote_currency),
                                                             ^~~~~~~~~~~~~~
infrastructure\core\exchange.py:994:34: error: Argument "trading_pair" to
"Order" has incompatible type "domain.value_objects.trading_pair.TradingPair";
expected "domain.types.TradingPair"  [arg-type]
                        trading_pair=TradingPair(base_currency, quote_curr...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\exchange.py:994:46: error: Argument 1 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
                        trading_pair=TradingPair(base_currency, quote_curr...
                                                 ^~~~~~~~~~~~~
infrastructure\core\exchange.py:994:61: error: Argument 2 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...              trading_pair=TradingPair(base_currency, quote_currency),
                                                             ^~~~~~~~~~~~~~
infrastructure\core\exchange.py:1068:25: error: Missing positional argument
"portfolio_id" in call to "Position"  [call-arg]
                            Position(
                            ^
infrastructure\core\exchange.py:1070:42: error: Argument "trading_pair" to
"Position" has incompatible type
"domain.value_objects.trading_pair.TradingPair"; expected
"domain.entities.trading_pair.TradingPair"  [arg-type]
                                trading_pair=TradingPair(base_currency, qu...
                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\exchange.py:1070:54: error: Argument 1 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...                        trading_pair=TradingPair(base_currency, quote_...
                                                        ^~~~~~~~~~~~~
infrastructure\core\exchange.py:1070:69: error: Argument 2 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...              trading_pair=TradingPair(base_currency, quote_currency),
                                                             ^~~~~~~~~~~~~~
infrastructure\core\exchange.py:1118:38: error: Argument "trading_pair" to
"Trade" has incompatible type "domain.value_objects.trading_pair.TradingPair";
expected "domain.types.TradingPair"  [arg-type]
                            trading_pair=TradingPair(base_currency, quote_...
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\exchange.py:1118:50: error: Argument 1 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
                            trading_pair=TradingPair(base_currency, quote_...
                                                     ^~~~~~~~~~~~~
infrastructure\core\exchange.py:1118:65: error: Argument 2 to "TradingPair" has
incompatible type "str"; expected "Currency"  [arg-type]
    ...              trading_pair=TradingPair(base_currency, quote_currency),
                                                             ^~~~~~~~~~~~~~
infrastructure\core\exchange.py:1120:29: error: Argument "side" to "Trade" has
incompatible type "domain.entities.order.OrderSide"; expected
"domain.entities.trading.OrderSide"  [arg-type]
                                OrderSide.BUY
                                ^
infrastructure\agents\market_regime\agent_corrupted.py:217:50: error: Argument
"key" to "max" has incompatible type overloaded function; expected
"Callable[[MarketRegime], SupportsDunderLT[Any] | SupportsDunderGT[Any]]" 
[arg-type]
                best_regime = max(regime_scores, key=regime_scores.get)
                                                     ^~~~~~~~~~~~~~~~~
infrastructure\agents\market_regime\agent_corrupted.py:381:31: error: Argument
1 to "Signal" has incompatible type "**dict[str, object]"; expected "str" 
[arg-type]
                signal = Signal(**signal_data)
                                  ^~~~~~~~~~~
infrastructure\agents\market_regime\agent_corrupted.py:381:31: error: Argument
1 to "Signal" has incompatible type "**dict[str, object]"; expected "float" 
[arg-type]
                signal = Signal(**signal_data)
                                  ^~~~~~~~~~~
infrastructure\agents\market_regime\agent_corrupted.py:381:31: error: Argument
1 to "Signal" has incompatible type "**dict[str, object]"; expected
"float | None"  [arg-type]
                signal = Signal(**signal_data)
                                  ^~~~~~~~~~~
infrastructure\agents\market_regime\agent_corrupted.py:381:31: error: Argument
1 to "Signal" has incompatible type "**dict[str, object]"; expected
"dict[str, Any]"  [arg-type]
                signal = Signal(**signal_data)
                                  ^~~~~~~~~~~
infrastructure\agents\market_regime\agent_corrupted.py:381:31: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
infrastructure\agents\market_regime\agent_corrupted.py:381:31: note: Consider using "Mapping" instead, which is covariant in the value type
examples\extended_entanglement_example.py:34:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
examples\base_example.py:285:22: error: Module has no attribute "date_range" 
[attr-defined]
            timestamps = pd.date_range(
                         ^~~~~~~~~~~~~
examples\base_example.py:286:19: error: "type[Timestamp]" has no attribute
"now"  [attr-defined]
                start=pd.Timestamp.now() - pd.Timedelta(days=periods),
                      ^~~~~~~~~~~~~~~~
examples\base_example.py:286:40: error: Module has no attribute "Timedelta" 
[attr-defined]
                start=pd.Timestamp.now() - pd.Timedelta(days=periods),
                                           ^~~~~~~~~~~~
examples\base_example.py:300:9: error: Unsupported target for indexed
assignment ("DataFrame")  [index]
            df['symbol'] = symbol
            ^~~~~~~~~~~~
examples\base_example.py:301:16: error: "DataFrame" has no attribute
"set_index"  [attr-defined]
            return df.set_index('timestamp')
                   ^~~~~~~~~~~~
domain\services\technical_analysis.py:93:13: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\services\technical_analysis.py:94:13: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\services\technical_analysis.py:248:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\services\technical_analysis.py:367:37: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                            value=float(rsi_values.iloc[-1]) if not rsi_va...
                                        ^~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:368:59: error: "Series" has no attribute
"tolist"  [attr-defined]
    ...               metadata={"period": 14, "values": rsi_values.tolist()},
                                                        ^~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:374:37: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                            value=float(macd_result["macd"].iloc[-1])
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:378:37: error: "Series" has no attribute
"tolist"  [attr-defined]
                                "macd": macd_result["macd"].tolist(),
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:379:39: error: "Series" has no attribute
"tolist"  [attr-defined]
                                "signal": macd_result["signal"].tolist(),
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:380:42: error: "Series" has no attribute
"tolist"  [attr-defined]
                                "histogram": macd_result["histogram"].toli...
                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:387:37: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                            value=float(bb_result.percent_b.iloc[-1])
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:391:38: error: "Series" has no attribute
"tolist"  [attr-defined]
                                "upper": bb_result.upper.tolist(),
                                         ^~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:392:39: error: "Series" has no attribute
"tolist"  [attr-defined]
                                "middle": bb_result.middle.tolist(),
                                          ^~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:393:38: error: "Series" has no attribute
"tolist"  [attr-defined]
                                "lower": bb_result.lower.tolist(),
                                         ^~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:394:42: error: "Series" has no attribute
"tolist"  [attr-defined]
                                "bandwidth": bb_result.bandwidth.tolist(),
                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:395:42: error: "Series" has no attribute
"tolist"  [attr-defined]
                                "percent_b": bb_result.percent_b.tolist(),
                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:402:37: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                            value=float(atr_values.iloc[-1]) if not atr_va...
                                        ^~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:403:59: error: "Series" has no attribute
"tolist"  [attr-defined]
    ...               metadata={"period": 14, "values": atr_values.tolist()},
                                                        ^~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:409:37: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                            value=float(stoch_result["k"].iloc[-1])
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:413:34: error: "Series" has no attribute
"tolist"  [attr-defined]
                                "k": stoch_result["k"].tolist(),
                                     ^~~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:414:34: error: "Series" has no attribute
"tolist"  [attr-defined]
                                "d": stoch_result["d"].tolist(),
                                     ^~~~~~~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:421:37: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                            value=float(wr_values.iloc[-1]) if not wr_valu...
                                        ^~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:422:59: error: "Series" has no attribute
"tolist"  [attr-defined]
    ...                metadata={"period": 14, "values": wr_values.tolist()},
                                                         ^~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:428:37: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                            value=float(cci_values.iloc[-1]) if not cci_va...
                                        ^~~~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:429:59: error: "Series" has no attribute
"tolist"  [attr-defined]
    ...               metadata={"period": 20, "values": cci_values.tolist()},
                                                        ^~~~~~~~~~~~~~~~~
domain\services\technical_analysis.py:563:17: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                    cumulative_volume += volume
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\strategy_service.py:67:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\services\portfolio_analysis.py:115:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\services\market_analysis.py:105:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\order_repository.py:244:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\ml_protocol.py:236:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\ml_protocol.py:237:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\ml_protocol.py:238:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\ml_protocol.py:239:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
application\services\risk_assessor.py:94:71: error: Argument 2 to
"_calculate_liquidation_risk" of "RiskAssessor" has incompatible type
"Decimal | Price"; expected "Decimal"  [arg-type]
    ...ation_risk = self._calculate_liquidation_risk(position, current_price)
                                                               ^~~~~~~~~~~~~
application\services\risk_assessor.py:104:27: error: Argument 2 to
"_generate_position_recommendations" of "RiskAssessor" has incompatible type
"Decimal | Price"; expected "Decimal"  [arg-type]
                    position, current_price, portfolio
                              ^~~~~~~~~~~~~
application\services\risk_assessor.py:181:24: error: Unsupported left operand
type for - ("Never")  [operator]
                    ret = ([][i] - [][i - 1]) / [][i - 1]
                           ^~~~~~~~~~~~~~~~~
application\services\position_creator.py:67:23: error: Missing positional
argument "available" in call to "InsufficientFundsError"  [call-arg]
                    raise InsufficientFundsError(
                          ^
application\services\position_creator.py:68:21: error: Argument 1 to
"InsufficientFundsError" has incompatible type "str"; expected "float" 
[arg-type]
                        f"Insufficient funds for margin. Required: {requir...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\position_creator.py:96:29: error: Unexpected keyword
argument "amount" for "Price"  [call-arg]
                    entry_price=Price(
                                ^
application\services\position_creator.py:96:29: error: Unexpected keyword
argument "base_currency" for "Price"; did you mean "currency"?  [call-arg]
                    entry_price=Price(
                                ^
application\services\position_creator.py:101:31: error: Unexpected keyword
argument "amount" for "Price"  [call-arg]
                    current_price=Price(
                                  ^
application\services\position_creator.py:101:31: error: Unexpected keyword
argument "base_currency" for "Price"; did you mean "currency"?  [call-arg]
                    current_price=Price(
                                  ^
application\services\position_creator.py:108:21: error: Unexpected keyword
argument "amount" for "Price"  [call-arg]
                        Price(
                        ^
application\services\position_creator.py:108:21: error: Unexpected keyword
argument "base_currency" for "Price"; did you mean "currency"?  [call-arg]
                        Price(
                        ^
application\services\position_creator.py:117:21: error: Unexpected keyword
argument "amount" for "Price"  [call-arg]
                        Price(
                        ^
application\services\position_creator.py:117:21: error: Unexpected keyword
argument "base_currency" for "Price"; did you mean "currency"?  [call-arg]
                        Price(
                        ^
tests\unit\test_protocols_ml.py:35:16: error: Unexpected keyword argument
"parameters" for "ModelConfig"; did you mean "hyperparameters"?  [call-arg]
            return ModelConfig(
                   ^
tests\unit\test_protocols_ml.py:38:24: error: Argument "model_type" to
"ModelConfig" has incompatible type "str"; expected "ModelType"  [arg-type]
                model_type="random_forest",
                           ^~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:47:16: error: Unexpected keyword argument
"validation_size" for "TrainingConfig"; did you mean "validation_split"? 
[call-arg]
            return TrainingConfig(
                   ^
tests\unit\test_protocols_ml.py:47:16: error: Unexpected keyword argument
"test_size" for "TrainingConfig"  [call-arg]
            return TrainingConfig(
                   ^
tests\unit\test_protocols_ml.py:47:16: error: Unexpected keyword argument
"model_checkpoint_path" for "TrainingConfig"  [call-arg]
            return TrainingConfig(
                   ^
tests\unit\test_protocols_ml.py:47:16: error: Unexpected keyword argument
"log_path" for "TrainingConfig"  [call-arg]
            return TrainingConfig(
                   ^
tests\unit\test_protocols_ml.py:65:59: error: Unexpected keyword argument
"state" for "Model"  [call-arg]
            ml_protocol.create_model = AsyncMock(return_value=Model(
                                                              ^
tests\unit\test_protocols_ml.py:66:16: error: Argument "id" to "Model" has
incompatible type "str"; expected "UUID"  [arg-type]
                id="model_123",
                   ^~~~~~~~~~~
tests\unit\test_protocols_ml.py:74:57: error: Unexpected keyword argument
"state" for "Model"  [call-arg]
            ml_protocol.load_model = AsyncMock(return_value=Model(
                                                            ^
tests\unit\test_protocols_ml.py:75:16: error: Argument "id" to "Model" has
incompatible type "str"; expected "UUID"  [arg-type]
                id="model_123",
                   ^~~~~~~~~~~
tests\unit\test_protocols_ml.py:79:19: error: "type[ModelState]" has no
attribute "LOADED"  [attr-defined]
                state=ModelState.LOADED,
                      ^~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:87:58: error: Name "TrainingResult" is not
defined  [name-defined]
    ...      ml_protocol.train_model = AsyncMock(return_value=TrainingResult(
                                                              ^~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:94:21: error: Unexpected keyword argument
"accuracy" for "ModelMetrics"  [call-arg]
                metrics=ModelMetrics(
                        ^
tests\unit\test_protocols_ml.py:94:21: error: Unexpected keyword argument
"precision" for "ModelMetrics"  [call-arg]
                metrics=ModelMetrics(
                        ^
tests\unit\test_protocols_ml.py:94:21: error: Unexpected keyword argument
"recall" for "ModelMetrics"  [call-arg]
                metrics=ModelMetrics(
                        ^
tests\unit\test_protocols_ml.py:94:21: error: Unexpected keyword argument
"f1_score" for "ModelMetrics"  [call-arg]
                metrics=ModelMetrics(
                        ^
tests\unit\test_protocols_ml.py:94:21: error: Unexpected keyword argument
"r2_score" for "ModelMetrics"  [call-arg]
                metrics=ModelMetrics(
                        ^
tests\unit\test_protocols_ml.py:114:54: error: Name "PredictionResult" is not
defined  [name-defined]
            ml_protocol.predict = AsyncMock(return_value=PredictionResult(
                                                         ^~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:121:60: error: Name "PredictionResult" is not
defined  [name-defined]
    ...  ml_protocol.predict_batch = AsyncMock(return_value=PredictionResult(
                                                            ^~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:129:61: error: Name "EvaluationResult" is not
defined  [name-defined]
    ... ml_protocol.evaluate_model = AsyncMock(return_value=EvaluationResult(
                                                            ^~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:131:21: error: Unexpected keyword argument
"accuracy" for "ModelMetrics"  [call-arg]
                metrics=ModelMetrics(
                        ^
tests\unit\test_protocols_ml.py:131:21: error: Unexpected keyword argument
"precision" for "ModelMetrics"  [call-arg]
                metrics=ModelMetrics(
                        ^
tests\unit\test_protocols_ml.py:131:21: error: Unexpected keyword argument
"recall" for "ModelMetrics"  [call-arg]
                metrics=ModelMetrics(
                        ^
tests\unit\test_protocols_ml.py:131:21: error: Unexpected keyword argument
"f1_score" for "ModelMetrics"  [call-arg]
                metrics=ModelMetrics(
                        ^
tests\unit\test_protocols_ml.py:131:21: error: Unexpected keyword argument
"r2_score" for "ModelMetrics"  [call-arg]
                metrics=ModelMetrics(
                        ^
tests\unit\test_protocols_ml.py:145:61: error: Name "SignalResult" is not
defined  [name-defined]
    ...     ml_protocol.analyze_market = AsyncMock(return_value=SignalResult(
                                                                ^~~~~~~~~~~~
tests\unit\test_protocols_ml.py:148:32: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                price_target=Price(51000.0, Currency("USDT")),
                                   ^~~~~~~
tests\unit\test_protocols_ml.py:149:29: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                stop_loss=Price(49000.0, Currency("USDT")),
                                ^~~~~~~
tests\unit\test_protocols_ml.py:150:31: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                take_profit=Price(52000.0, Currency("USDT")),
                                  ^~~~~~~
tests\unit\test_protocols_ml.py:154:62: error: Name "SignalResult" is not
defined  [name-defined]
    ...    ml_protocol.generate_signal = AsyncMock(return_value=SignalResult(
                                                                ^~~~~~~~~~~~
tests\unit\test_protocols_ml.py:174:25: error: Unexpected keyword argument
"price" for "MarketData"  [call-arg]
                data.append(MarketData(
                            ^
tests\unit\test_protocols_ml.py:174:25: error: Unexpected keyword argument
"open_price" for "MarketData"  [call-arg]
                data.append(MarketData(
                            ^
tests\unit\test_protocols_ml.py:174:25: error: Unexpected keyword argument
"close_price" for "MarketData"  [call-arg]
                data.append(MarketData(
                            ^
tests\unit\test_protocols_ml.py:175:24: error: Argument "symbol" to
"MarketData" has incompatible type "str"; expected "Symbol"  [arg-type]
                    symbol="BTC/USDT",
                           ^~~~~~~~~~
tests\unit\test_protocols_ml.py:176:27: error: Argument "timestamp" to
"MarketData" has incompatible type "datetime"; expected "TimestampValue" 
[arg-type]
                    timestamp=timestamp,
                              ^~~~~~~~~
tests\unit\test_protocols_ml.py:177:29: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    price=Price(base_price + price_change, Currency("USDT"...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:179:28: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    high=Price(base_price + price_change + 50, Currency("U...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:180:27: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    low=Price(base_price + price_change - 50, Currency("US...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:181:34: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    open_price=Price(base_price + price_change - 25, Curre...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:182:35: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    close_price=Price(base_price + price_change, Currency(...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:195:16: error: "Model" has no attribute "state"
 [attr-defined]
            assert model.state == ModelState.CREATED
                   ^~~~~~~~~~~
tests\unit\test_protocols_ml.py:201:16: error: "Model" has no attribute "state"
 [attr-defined]
            assert loaded_model.state == ModelState.LOADED
                   ^~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:201:38: error: "type[ModelState]" has no
attribute "LOADED"  [attr-defined]
            assert loaded_model.state == ModelState.LOADED
                                         ^~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:233:44: error: Name "TrainingResult" is not
defined  [name-defined]
            assert isinstance(training_result, TrainingResult)
                                               ^~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:254:46: error: Name "PredictionResult" is not
defined  [name-defined]
            assert isinstance(prediction_result, PredictionResult)
                                                 ^~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:264:41: error: Name "PredictionResult" is not
defined  [name-defined]
            assert isinstance(batch_result, PredictionResult)
                                            ^~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:273:46: error: Name "EvaluationResult" is not
defined  [name-defined]
            assert isinstance(evaluation_result, EvaluationResult)
                                                 ^~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:292:44: error: Name "SignalResult" is not
defined  [name-defined]
            assert isinstance(analysis_result, SignalResult)
                                               ^~~~~~~~~~~~
tests\unit\test_protocols_ml.py:304:42: error: Name "SignalResult" is not
defined  [name-defined]
            assert isinstance(signal_result, SignalResult)
                                             ^~~~~~~~~~~~
tests\unit\test_protocols_ml.py:313:51: error: Missing positional argument
"model_id" in call to "ModelNotFoundError"  [call-arg]
    ...       mock_ml_protocol.load_model.side_effect = ModelNotFoundError("M...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_protocols_ml.py:317:52: error: Missing positional arguments
"model_id", "training_step" in call to "TrainingError"  [call-arg]
    ...      mock_ml_protocol.train_model.side_effect = TrainingError("Traini...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_protocols_ml.py:325:54: error: Name "DataValidationError" is
not defined  [name-defined]
    ...    mock_ml_protocol.validate_data.side_effect = DataValidationError("...
                                                        ^~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:326:28: error: Name "DataValidationError" is
not defined  [name-defined]
            with pytest.raises(DataValidationError):
                               ^~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:329:53: error: Name "ModelValidationError" is
not defined  [name-defined]
    ...     mock_ml_protocol.create_model.side_effect = ModelValidationError(...
                                                        ^~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:330:28: error: Name "ModelValidationError" is
not defined  [name-defined]
            with pytest.raises(ModelValidationError):
                               ^~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:331:49: error: Missing positional arguments
"name", "model_type", "trading_pair", "prediction_type", "hyperparameters",
"features", "target" in call to "ModelConfig"  [call-arg]
                await mock_ml_protocol.create_model(ModelConfig())
                                                    ^~~~~~~~~~~~~
tests\unit\test_protocols_ml.py:333:56: error: Missing positional arguments
"required_samples", "available_samples" in call to "InsufficientDataError" 
[call-arg]
    ...  mock_ml_protocol.preprocess_data.side_effect = InsufficientDataError...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "ConnectionProtocol" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "MarketDataProtocol" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "TradingProtocol" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "AccountProtocol" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "ExchangeConfig" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "ConnectionState"; maybe
"ConnectionStatus"?  [attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "MarketData" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "OrderBook" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "Balance"  [attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "ExchangeError" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "AuthenticationError" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "RateLimitError"; maybe
"ExchangeRateLimitError"?  [attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "InsufficientFundsError" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "InvalidOrderError" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "NetworkError" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:9:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "TimeoutError" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
tests\unit\test_protocols_exchange.py:72:25: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                price=Price(50000.0, Currency("USDT")),
                            ^~~~~~~
tests\unit\test_protocols_exchange.py:74:24: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                high=Price(51000.0, Currency("USDT")),
                           ^~~~~~~
tests\unit\test_protocols_exchange.py:75:23: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                low=Price(49000.0, Currency("USDT")),
                          ^~~~~~~
tests\unit\test_protocols_exchange.py:76:30: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                open_price=Price(49500.0, Currency("USDT")),
                                 ^~~~~~~
tests\unit\test_protocols_exchange.py:77:31: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                close_price=Price(50000.0, Currency("USDT"))
                                  ^~~~~~~
tests\unit\test_protocols_exchange.py:83:24: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    (Price(49999.0, Currency("USDT")), Volume(1.0, Currenc...
                           ^~~~~~~
tests\unit\test_protocols_exchange.py:84:24: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    (Price(49998.0, Currency("USDT")), Volume(2.0, Currenc...
                           ^~~~~~~
tests\unit\test_protocols_exchange.py:87:24: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    (Price(50001.0, Currency("USDT")), Volume(1.5, Currenc...
                           ^~~~~~~
tests\unit\test_protocols_exchange.py:88:24: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    (Price(50002.0, Currency("USDT")), Volume(2.5, Currenc...
                           ^~~~~~~
tests\unit\test_protocols_exchange.py:92:13: error: Unexpected keyword argument
"timestamp" for "Trade"  [call-arg]
                Trade(
                ^
tests\unit\test_protocols_exchange.py:93:20: error: Argument "id" to "Trade"
has incompatible type "str"; expected "TradeId"  [arg-type]
                    id="trade_1",
                       ^~~~~~~~~
tests\unit\test_protocols_exchange.py:94:24: error: Argument "symbol" to
"Trade" has incompatible type "str"; expected "Symbol"  [arg-type]
                    symbol="BTC/USDT",
                           ^~~~~~~~~~
tests\unit\test_protocols_exchange.py:96:22: error: Argument "side" to "Trade"
has incompatible type "Literal[OrderSide.BUY]"; expected
"Literal['buy', 'sell', 'hold', 'close', 'strong_buy', 'strong_sell']" 
[arg-type]
                    side=OrderSide.BUY,
                         ^~~~~~~~~~~~~
tests\unit\test_protocols_exchange.py:97:29: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    price=Price(50000.0, Currency("USDT")),
                                ^~~~~~~
tests\unit\test_protocols_exchange.py:103:56: error: Unexpected keyword
argument "volume" for "Order"  [call-arg]
            exchange.create_order = AsyncMock(return_value=Order(
                                                           ^
tests\unit\test_protocols_exchange.py:103:56: error: Unexpected keyword
argument "filled_volume" for "Order"  [call-arg]
            exchange.create_order = AsyncMock(return_value=Order(
                                                           ^
tests\unit\test_protocols_exchange.py:103:56: error: Unexpected keyword
argument "timestamp" for "Order"  [call-arg]
            exchange.create_order = AsyncMock(return_value=Order(
                                                           ^
tests\unit\test_protocols_exchange.py:104:16: error: Argument "id" to "Order"
has incompatible type "str"; expected "OrderId"  [arg-type]
                id="order_123",
                   ^~~~~~~~~~~
tests\unit\test_protocols_exchange.py:105:20: error: Argument "symbol" to
"Order" has incompatible type "str"; expected "Symbol"  [arg-type]
                symbol="BTC/USDT",
                       ^~~~~~~~~~
tests\unit\test_protocols_exchange.py:106:18: error: Argument "side" to "Order"
has incompatible type "domain.entities.trading.OrderSide"; expected
"domain.entities.order.OrderSide"  [arg-type]
                side=OrderSide.BUY,
                     ^~~~~~~~~~~~~
tests\unit\test_protocols_exchange.py:107:24: error: Argument "order_type" to
"Order" has incompatible type "domain.entities.trading.OrderType"; expected
"domain.entities.order.OrderType"  [arg-type]
                order_type=OrderType.LIMIT,
                           ^~~~~~~~~~~~~~~
tests\unit\test_protocols_exchange.py:108:20: error: Argument "status" to
"Order" has incompatible type "domain.entities.trading.OrderStatus"; expected
"domain.entities.order.OrderStatus"  [arg-type]
                status=OrderStatus.PENDING,
                       ^~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_exchange.py:109:25: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                price=Price(50000.0, Currency("USDT")),
                            ^~~~~~~
tests\unit\test_protocols_exchange.py:114:53: error: Unexpected keyword
argument "volume" for "Order"  [call-arg]
            exchange.get_order = AsyncMock(return_value=Order(
                                                        ^
tests\unit\test_protocols_exchange.py:114:53: error: Unexpected keyword
argument "filled_volume" for "Order"  [call-arg]
            exchange.get_order = AsyncMock(return_value=Order(
                                                        ^
tests\unit\test_protocols_exchange.py:114:53: error: Unexpected keyword
argument "timestamp" for "Order"  [call-arg]
            exchange.get_order = AsyncMock(return_value=Order(
                                                        ^
tests\unit\test_protocols_exchange.py:115:16: error: Argument "id" to "Order"
has incompatible type "str"; expected "OrderId"  [arg-type]
                id="order_123",
                   ^~~~~~~~~~~
tests\unit\test_protocols_exchange.py:116:20: error: Argument "symbol" to
"Order" has incompatible type "str"; expected "Symbol"  [arg-type]
                symbol="BTC/USDT",
                       ^~~~~~~~~~
tests\unit\test_protocols_exchange.py:117:18: error: Argument "side" to "Order"
has incompatible type "domain.entities.trading.OrderSide"; expected
"domain.entities.order.OrderSide"  [arg-type]
                side=OrderSide.BUY,
                     ^~~~~~~~~~~~~
tests\unit\test_protocols_exchange.py:118:24: error: Argument "order_type" to
"Order" has incompatible type "domain.entities.trading.OrderType"; expected
"domain.entities.order.OrderType"  [arg-type]
                order_type=OrderType.LIMIT,
                           ^~~~~~~~~~~~~~~
tests\unit\test_protocols_exchange.py:119:20: error: Argument "status" to
"Order" has incompatible type "domain.entities.trading.OrderStatus"; expected
"domain.entities.order.OrderStatus"  [arg-type]
                status=OrderStatus.FILLED,
                       ^~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_exchange.py:120:25: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                price=Price(50000.0, Currency("USDT")),
                            ^~~~~~~
tests\unit\test_protocols_exchange.py:216:25: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                price=Price(50000.0, Currency("USDT"))
                            ^~~~~~~
tests\unit\test_protocols_exchange.py:288:29: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    price=Price(50000.0, Currency("USDT"))
                                ^~~~~~~
tests\unit\test_protocols_exchange.py:298:29: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    price=Price(50000.0, Currency("USDT"))
                                ^~~~~~~
tests\unit\test_protocols_exchange.py:301:47: error: Missing positional
argument "order_id" in call to "OrderNotFoundError"  [call-arg]
            mock_exchange.get_order.side_effect = OrderNotFoundError("Orde...
                                                  ^~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_protocols_exchange.py:335:59: error: "type[OrderType]" has no
attribute "STOP_LOSS"  [attr-defined]
    ...order_types = [OrderType.MARKET, OrderType.LIMIT, OrderType.STOP_LOSS]
                                                         ^~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_exchange.py:344:33: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                        price=Price(50000.0, Currency("USDT"))
                                    ^~~~~~~
tests\unit\test_protocols_exchange.py:395:29: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    price=Price(50000.0, Currency("USDT")),
                                ^~~~~~~
tests\unit\test_protocols_exchange.py:397:28: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    high=Price(51000.0, Currency("USDT")),
                               ^~~~~~~
tests\unit\test_protocols_exchange.py:398:27: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    low=Price(49000.0, Currency("USDT")),
                              ^~~~~~~
tests\unit\test_protocols_exchange.py:399:34: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    open_price=Price(49500.0, Currency("USDT")),
                                     ^~~~~~~
tests\unit\test_protocols_exchange.py:400:35: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    close_price=Price(50000.0, Currency("USDT"))
                                      ^~~~~~~
tests\domain\services\test_technical_analysis.py:111:17: error: Module has no
attribute "date_range"  [attr-defined]
            dates = pd.date_range('2024-01-01', periods=100, freq='1H')
                    ^~~~~~~~~~~~~
tests\domain\services\test_technical_analysis.py:124:16: error:
"DefaultTechnicalAnalysisService" has no attribute "_scaler"  [attr-defined]
            assert service._scaler is not None
                   ^~~~~~~~~~~~~~~
tests\domain\services\test_technical_analysis.py:136:20: error: "Series" has no
attribute "isna"  [attr-defined]
            assert not rsi.isna().all()  # Ќе все значени€ должны быть NaN
                       ^~~~~~~~
tests\domain\services\test_technical_analysis.py:140:20: error: "bool" has no
attribute "all"  [attr-defined]
                assert (valid_rsi >= 0).all()
                       ^~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_technical_analysis.py:140:21: error: Unsupported
operand types for <= ("int" and "Series")  [operator]
                assert (valid_rsi >= 0).all()
                        ^
tests\domain\services\test_technical_analysis.py:141:20: error: "bool" has no
attribute "all"  [attr-defined]
                assert (valid_rsi <= 100).all()
                       ^~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_technical_analysis.py:141:21: error: Unsupported
operand types for >= ("int" and "Series")  [operator]
                assert (valid_rsi <= 100).all()
                        ^
tests\domain\services\test_technical_analysis.py:185:20: error: "bool" has no
attribute "all"  [attr-defined]
                assert (valid_atr >= 0).all()
                       ^~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_technical_analysis.py:185:21: error: Unsupported
operand types for <= ("int" and "Series")  [operator]
                assert (valid_atr >= 0).all()
                        ^
tests\domain\services\test_technical_analysis.py:192:20: error: "Series" has no
attribute "isna"  [attr-defined]
            assert not ema.isna().all()
                       ^~~~~~~~
infrastructure\strategies\trend_strategies.py:61:9: error: "DataFrame" has no
attribute "loc"  [attr-defined]
            data.loc[:, "ema_fast"] = calculate_ema(data["close"], self.em...
            ^~~~~~~~
infrastructure\strategies\trend_strategies.py:62:9: error: "DataFrame" has no
attribute "loc"  [attr-defined]
            data.loc[:, "ema_medium"] = calculate_ema(data["close"], self....
            ^~~~~~~~
infrastructure\strategies\trend_strategies.py:63:9: error: "DataFrame" has no
attribute "loc"  [attr-defined]
            data.loc[:, "ema_slow"] = calculate_ema(data["close"], self.em...
            ^~~~~~~~
infrastructure\strategies\trend_strategies.py:66:9: error: "DataFrame" has no
attribute "loc"  [attr-defined]
            data.loc[:, "macd"] = macd_result[0]  # macd line
            ^~~~~~~~
infrastructure\strategies\trend_strategies.py:67:9: error: "DataFrame" has no
attribute "loc"  [attr-defined]
            data.loc[:, "macd_signal"] = macd_result[1]  # signal line
            ^~~~~~~~
infrastructure\strategies\trend_strategies.py:68:9: error: "DataFrame" has no
attribute "loc"  [attr-defined]
            data.loc[:, "macd_hist"] = macd_result[2]  # histogram
            ^~~~~~~~
infrastructure\strategies\trend_strategies.py:70:9: error: "DataFrame" has no
attribute "loc"  [attr-defined]
            data.loc[:, "adx"] = self._calculate_adx(data)
            ^~~~~~~~
infrastructure\strategies\trend_strategies.py:72:9: error: "DataFrame" has no
attribute "loc"  [attr-defined]
            data.loc[:, "atr"] = calculate_atr(
            ^~~~~~~~
infrastructure\strategies\trend_strategies.py:89:16: error: "Series" has no
attribute "ewm"  [attr-defined]
            exp1 = prices.ewm(span=self.config["macd_fast"], adjust=False)...
                   ^~~~~~~~~~
infrastructure\strategies\trend_strategies.py:90:16: error: "Series" has no
attribute "ewm"  [attr-defined]
            exp2 = prices.ewm(span=self.config["macd_slow"], adjust=False)...
                   ^~~~~~~~~~
infrastructure\strategies\trend_strategies.py:101:27: error: No overload
variant of "list" matches argument type "Series"  [call-overload]
                macd_values = list(macd)
                              ^~~~~~~~~~
infrastructure\strategies\trend_strategies.py:101:27: note: Possible overload variants:
infrastructure\strategies\trend_strategies.py:101:27: note:     def [_T] __init__(self) -> list[_T]
infrastructure\strategies\trend_strategies.py:101:27: note:     def [_T] __init__(self, Iterable[_T], /) -> list[_T]
infrastructure\strategies\trend_strategies.py:102:29: error: No overload
variant of "list" matches argument type "Series"  [call-overload]
                signal_values = list(signal)
                                ^~~~~~~~~~~~
infrastructure\strategies\trend_strategies.py:102:29: note: Possible overload variants:
infrastructure\strategies\trend_strategies.py:102:29: note:     def [_T] __init__(self) -> list[_T]
infrastructure\strategies\trend_strategies.py:102:29: note:     def [_T] __init__(self, Iterable[_T], /) -> list[_T]
infrastructure\strategies\trend_strategies.py:131:17: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    calculate_atr(
                    ^
infrastructure\strategies\trend_strategies.py:140:30: error:
"MarketStructureResult" has no attribute "__iter__" (not iterable) 
[attr-defined]
                    for level in self.technical_analysis.calculate_market_...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\trend_strategies.py:142:13: error: Need type
annotation for "liquidity_zones" (hint: "liquidity_zones: list[<type>] = ...") 
[var-annotated]
                liquidity_zones = []
                ^~~~~~~~~~~~~~~
infrastructure\strategies\trend_strategies.py:144:25: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                rsi = float(calculate_rsi(data["close"], 14).iloc[-1])
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\trend_strategies.py:150:21: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    abs(ema_20.iloc[-1] - ema_50.iloc[-1]) / ema_50.iloc[-...
                        ^~~~~~~~~~~~~~~
infrastructure\strategies\trend_strategies.py:224:17: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    calculate_atr(
                    ^
infrastructure\strategies\trend_strategies.py:233:30: error:
"MarketStructureResult" has no attribute "__iter__" (not iterable) 
[attr-defined]
                    for level in self.technical_analysis.calculate_market_...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\trend_strategies.py:235:13: error: Need type
annotation for "liquidity_zones" (hint: "liquidity_zones: list[<type>] = ...") 
[var-annotated]
                liquidity_zones = []
                ^~~~~~~~~~~~~~~
infrastructure\strategies\trend_strategies.py:237:25: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                rsi = float(calculate_rsi(data["close"], 14).iloc[-1])
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\trend_strategies.py:341:45: error: "DataFrame" has no
attribute "copy"  [attr-defined]
                df = self._calculate_indicators(data.copy())
                                                ^~~~~~~~~
infrastructure\strategies\trend_strategies.py:351:17: error: "DataFrame" has no
attribute "shape"  [attr-defined]
                    f"Original data shape: {data.shape}, After indicators:...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\trend_strategies.py:397:30: error: "type[Timestamp]"
has no attribute "now"  [attr-defined]
                    "timestamp": pd.Timestamp.now(),
                                 ^~~~~~~~~~~~~~~~
infrastructure\strategies\trend_strategies.py:430:5: error: Return type
"domain.types.strategy_types.Signal | None" of "generate_signal" incompatible
with return type "infrastructure.strategies.base_strategy.Signal | None" in
supertype "BaseStrategy"  [override]
        def generate_signal(self, data: pd.DataFrame) -> Optional[Signal]:
        ^
infrastructure\strategies\trend_strategies.py:446:45: error: "DataFrame" has no
attribute "copy"  [attr-defined]
                df = self._calculate_indicators(data.copy())
                                                ^~~~~~~~~
infrastructure\strategies\trend_strategies.py:447:16: error: "DataFrame" has no
attribute "shape"  [attr-defined]
                if df.shape[0] < max(self.ema_fast, self.ema_slow):
                   ^~~~~~~~
infrastructure\strategies\trend_strategies.py:567:23: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            last_candle = data.iloc[-1]
                          ^~~~~~~~~
infrastructure\strategies\trend_strategies.py:568:23: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            prev_candle = data.iloc[-2]
                          ^~~~~~~~~
infrastructure\strategies\manipulation_strategies.py:47:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["volume_delta"] = calculate_volume_delta(data["volume"])
            ^~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\manipulation_strategies.py:50:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                data["imbalance"] = pd.Series([0.0] * len(data), index=dat...
                ^~~~~~~~~~~~~~~~~
infrastructure\strategies\manipulation_strategies.py:52:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                data["imbalance"] = pd.Series([0.0] * len(data), index=dat...
                ^~~~~~~~~~~~~~~~~
infrastructure\strategies\manipulation_strategies.py:57:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["upper_fractals"] = upper_fractals
            ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\manipulation_strategies.py:58:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["lower_fractals"] = lower_fractals
            ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\manipulation_strategies.py:60:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            data["vwap"] = calculate_vwap(
            ^~~~~~~~~~~~
infrastructure\strategies\manipulation_strategies.py:93:23: error: Argument 1
of "analyze" is incompatible with supertype "BaseStrategy"; supertype defines
the argument type as "DataFrame"  [override]
        def analyze(self, data: Dict[str, Any]) -> Dict[str, Any]:
                          ^~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\manipulation_strategies.py:93:23: note: This violates the Liskov substitution principle
infrastructure\strategies\manipulation_strategies.py:93:23: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\strategies\manipulation_strategies.py:202:37: error: Argument 1
to "analyze" of "ManipulationStrategy" has incompatible type "DataFrame";
expected "dict[str, Any]"  [arg-type]
                analysis = self.analyze(data)
                                        ^~~~
infrastructure\strategies\manipulation_strategies.py:230:20: error: Unexpected
keyword argument "strategy_type" for "Signal"  [call-arg]
                return Signal(
                       ^
infrastructure\strategies\manipulation_strategies.py:230:20: error: Unexpected
keyword argument "market_regime" for "Signal"  [call-arg]
                return Signal(
                       ^
infrastructure\simulation\backtester\core.py:269:32: error: Argument "signal"
to "execute_trade" of "TradeExecutor" has incompatible type
"domain.entities.trading.Signal | infrastructure.simulation.backtester.types.Signal";
expected "domain.entities.trading.Signal"  [arg-type]
                            signal=domain_signal,
                                   ^~~~~~~~~~~~~
infrastructure\simulation\backtester\core.py:270:37: error: Argument
"market_data" to "execute_trade" of "TradeExecutor" has incompatible type
"domain.entities.market.MarketData | infrastructure.simulation.backtester.types.MarketData";
expected "domain.entities.market.MarketData"  [arg-type]
                            market_data=domain_market_data,
                                        ^~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtester\core.py:272:34: error: Argument "position"
to "execute_trade" of "TradeExecutor" has incompatible type "Trade | None";
expected "Position | None"  [arg-type]
                            position=position,
                                     ^~~~~~~~
infrastructure\simulation\backtester\core.py:306:65: error: Argument 1 to
"calculate_metrics" of "MetricsCalculator" has incompatible type
"list[domain.entities.trading.Trade]"; expected
"list[infrastructure.simulation.backtester.types.Trade]"  [arg-type]
    ...rics = self.metrics_calculator.calculate_metrics(trades, equity_curve)
                                                        ^~~~~~
infrastructure\simulation\backtester\core.py:309:24: error: Argument "trades"
to "BacktestResult" has incompatible type "list[domain.entities.trading.Trade]";
expected "list[infrastructure.simulation.backtester.types.Trade]"  [arg-type]
                    trades=trades,
                           ^~~~~~
infrastructure\services\technical_analysis_service.py:190:5: error: Return type
"dict[str, Series]" of "calculate_bollinger_bands" incompatible with return type
"BollingerBandsResult" in supertype "TechnicalAnalysisService"  [override]
        def calculate_bollinger_bands(
        ^
infrastructure\services\technical_analysis_service.py:190:5: error: Return type
"dict[str, Series]" of "calculate_bollinger_bands" incompatible with return type
"BollingerBandsResult" in supertype "TechnicalAnalysisProtocol"  [override]
        def calculate_bollinger_bands(
        ^
infrastructure\services\technical_analysis_service.py:219:20: error: Too many
arguments for "validate_ohlcv_data"  [call-arg]
                if not validate_ohlcv_data(df, self.config.min_data_points...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis_service.py:238:20: error: Too many
arguments for "validate_ohlcv_data"  [call-arg]
                if not validate_ohlcv_data(
                       ^
infrastructure\services\technical_analysis_service.py:255:20: error: Too many
arguments for "validate_ohlcv_data"  [call-arg]
                if not validate_ohlcv_data(
                       ^
infrastructure\services\technical_analysis_service.py:274:20: error: Too many
arguments for "validate_ohlcv_data"  [call-arg]
                if not validate_ohlcv_data(
                       ^
infrastructure\services\technical_analysis_service.py:293:20: error: Too many
arguments for "validate_ohlcv_data"  [call-arg]
                if not validate_ohlcv_data(
                       ^
infrastructure\services\technical_analysis_service.py:307:35: error: Too many
arguments for "generate_pattern_signals"  [call-arg]
                    pattern_signals = generate_pattern_signals(high, low, ...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis_service.py:307:60: error: Argument 1
to "generate_pattern_signals" has incompatible type "Series"; expected
"list[dict[str, Any]]"  [arg-type]
    ...      pattern_signals = generate_pattern_signals(high, low, close, vol...
                                                        ^~~~
infrastructure\services\technical_analysis_service.py:328:20: error: Too many
arguments for "validate_market_data"  [call-arg]
                if not validate_market_data(market_data, self.config.min_d...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis_service.py:344:23: error: Name
"generate_trading_signals" is not defined  [name-defined]
                signals = generate_trading_signals(high, low, close, volum...
                          ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis_service.py:346:22: error: Unexpected
keyword argument "timestamp" for "TechnicalAnalysisReport"  [call-arg]
                report = TechnicalAnalysisReport(
                         ^
infrastructure\services\technical_analysis_service.py:346:22: error: Unexpected
keyword argument "trend_direction" for "TechnicalAnalysisReport"  [call-arg]
                report = TechnicalAnalysisReport(
                         ^
infrastructure\services\technical_analysis_service.py:346:22: error: Unexpected
keyword argument "support_levels" for "TechnicalAnalysisReport"  [call-arg]
                report = TechnicalAnalysisReport(
                         ^
infrastructure\services\technical_analysis_service.py:346:22: error: Unexpected
keyword argument "resistance_levels" for "TechnicalAnalysisReport"  [call-arg]
                report = TechnicalAnalysisReport(
                         ^
infrastructure\services\technical_analysis_service.py:346:22: error: Unexpected
keyword argument "patterns" for "TechnicalAnalysisReport"  [call-arg]
                report = TechnicalAnalysisReport(
                         ^
infrastructure\services\technical_analysis_service.py:346:22: error: Unexpected
keyword argument "confidence" for "TechnicalAnalysisReport"  [call-arg]
                report = TechnicalAnalysisReport(
                         ^
infrastructure\services\technical_analysis_service.py:349:34: error: Argument
"market_structure" to "TechnicalAnalysisReport" has incompatible type
"dict[str, Any]"; expected "MarketStructureResult"  [arg-type]
                    market_structure=market_structure,
                                     ^~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis_service.py:366:20: error: Too many
arguments for "validate_market_data"  [call-arg]
                if not validate_market_data(market_data, self.config.min_d...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis_service.py:367:24: error: Too many
arguments for "create_empty_indicator_result"  [call-arg]
                    return create_empty_indicator_result(indicator_name)
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis_service.py:381:26: error:
Incompatible types in assignment (expression has type "dict[str, Series]",
variable has type "Series")  [assignment]
                    result = {"macd_line": macd_line, "signal_line": signa...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis_service.py:388:26: error:
Incompatible types in assignment (expression has type "dict[str, Series]",
variable has type "Series")  [assignment]
                    result = {"upper": upper, "middle": middle, "lower": l...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis_service.py:393:24: error: Too many
arguments for "create_empty_indicator_result"  [call-arg]
                    return create_empty_indicator_result(indicator_name)
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis_service.py:395:20: error: Unexpected
keyword argument "name" for "TechnicalIndicatorResult"  [call-arg]
                return TechnicalIndicatorResult(
                       ^
infrastructure\services\technical_analysis_service.py:395:20: error: Unexpected
keyword argument "values" for "TechnicalIndicatorResult"  [call-arg]
                return TechnicalIndicatorResult(
                       ^
infrastructure\services\technical_analysis_service.py:395:20: error: Unexpected
keyword argument "timestamp" for "TechnicalIndicatorResult"  [call-arg]
                return TechnicalIndicatorResult(
                       ^
infrastructure\services\technical_analysis_service.py:395:20: error: Unexpected
keyword argument "metadata" for "TechnicalIndicatorResult"  [call-arg]
                return TechnicalIndicatorResult(
                       ^
infrastructure\services\technical_analysis_service.py:403:20: error: Too many
arguments for "create_empty_indicator_result"  [call-arg]
                return create_empty_indicator_result(indicator_name)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis_service.py:408:20: error: Too many
arguments for "validate_market_data"  [call-arg]
                if not validate_market_data(market_data, self.config.min_d...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis_service.py:422:20: error: Too many
arguments for "validate_market_data"  [call-arg]
                if not validate_market_data(market_data, self.config.min_d...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis_service.py:429:31: error: Too many
arguments for "generate_pattern_signals"  [call-arg]
                pattern_signals = generate_pattern_signals(high, low, clos...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\technical_analysis_service.py:429:56: error: Argument 1
to "generate_pattern_signals" has incompatible type "Series"; expected
"list[dict[str, Any]]"  [arg-type]
    ...      pattern_signals = generate_pattern_signals(high, low, close, vol...
                                                        ^~~~
infrastructure\services\technical_analysis_service.py:436:20: error: Missing
positional arguments "high", "low" in call to "generate_composite_signal" 
[call-arg]
                return generate_composite_signal(all_signals)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\technical_analysis_service.py:436:46: error: Argument 1
to "generate_composite_signal" has incompatible type "list[TradingSignal]";
expected "Series"  [arg-type]
                return generate_composite_signal(all_signals)
                                                 ^~~~~~~~~~~
infrastructure\services\enhanced_trading_service.py:386:20: error: Too many
arguments for "calculate_performance_metrics"  [call-arg]
                return calculate_performance_metrics(orders, market_data, ...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\external_services\risk_analysis_service.py:26:23: error:
Unexpected keyword argument "portfolio" for "OrderRequest"; did you mean
"portfolio_id"?  [call-arg]
                request = OrderRequest(
                          ^
infrastructure\external_services\risk_analysis_service.py:26:23: error:
Unexpected keyword argument "historical_returns" for "OrderRequest"  [call-arg]
                request = OrderRequest(
                          ^
infrastructure\external_services\order_manager.py:100:39: error: Argument 1 to
"float" has incompatible type "Price"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                        price_val = float(order.price) if order.price else...
                                          ^~~~~~~~~~~
infrastructure\external_services\order_manager.py:197:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\external_services\order_manager.py:241:35: error: "MarketData"
has no attribute "bid_price"  [attr-defined]
            if not order.price or not market_data.bid_price or not market_...
                                      ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:241:64: error: "MarketData"
has no attribute "ask_price"  [attr-defined]
    ... order.price or not market_data.bid_price or not market_data.ask_price...
                                                        ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:244:29: error: Argument 1 to
"float" has incompatible type "Price"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
            order_price = float(order.price)
                                ^~~~~~~~~~~
infrastructure\external_services\order_manager.py:245:28: error: "MarketData"
has no attribute "bid_price"  [attr-defined]
            mid_price = (float(market_data.bid_price) + float(market_data....
                               ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:245:59: error: "MarketData"
has no attribute "ask_price"  [attr-defined]
    ...id_price = (float(market_data.bid_price) + float(market_data.ask_price...
                                                        ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:282:17: error: Generator has
incompatible item type "float"; expected "bool"  [misc]
                    float(o.quantity) * float(o.price) 
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:282:43: error: Argument 1 to
"float" has incompatible type "Price"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                    float(o.quantity) * float(o.price) 
                                              ^~~~~~~
infrastructure\external_services\order_manager.py:328:16: error: "MarketData"
has no attribute "bid_price"  [attr-defined]
            if not market_data.bid_price or not market_data.ask_price:
                   ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:328:45: error: "MarketData"
has no attribute "ask_price"  [attr-defined]
            if not market_data.bid_price or not market_data.ask_price:
                                                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:331:27: error: "MarketData"
has no attribute "bid_price"  [attr-defined]
            bid_price = float(market_data.bid_price)
                              ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:332:27: error: "MarketData"
has no attribute "ask_price"  [attr-defined]
            ask_price = float(market_data.ask_price)
                              ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:345:41: error: Argument 1 to
"float" has incompatible type "Volume"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
            if market_data.volume and float(market_data.volume) > 1000000:
                                            ^~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:347:43: error: Argument 1 to
"float" has incompatible type "Volume"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
            elif market_data.volume and float(market_data.volume) < 100000...
                                              ^~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:357:5: error: Missing return
statement  [return]
        async def _optimize_order_size(
        ^
infrastructure\external_services\order_manager.py:367:30: error: Incompatible
types in assignment (expression has type "Volume", variable has type
"VolumeValue")  [assignment]
                order.quantity = Volume(optimized_quantity)
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:371:30: error: Incompatible
types in assignment (expression has type "Volume", variable has type
"VolumeValue")  [assignment]
                order.quantity = Volume(optimized_quantity)
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:385:31: error: Argument 1 to
"float" has incompatible type "Price"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
            current_price = float(order.price)
                                  ^~~~~~~~~~~
infrastructure\external_services\order_manager.py:445:52: error: Incompatible
types in assignment (expression has type "dict[str, Any]", target has type
"str")  [assignment]
    ...          order.metadata['price_optimization'] = optimization_metadata
                                                        ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:460:23: error: Missing
positional argument "currency" in call to "Price"  [call-arg]
            order.price = Price(optimized_price)
                          ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:493:35: error: Argument 1 to
"float" has incompatible type "Money"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
            return Money(amount=float(order_value) * commission_rate, curr...
                                      ^~~~~~~~~~~
infrastructure\external_services\order_manager.py:520:16: error: Unexpected
keyword argument "bid_price" for "MarketData"  [call-arg]
            return MarketData(
                   ^
infrastructure\external_services\order_manager.py:520:16: error: Unexpected
keyword argument "ask_price" for "MarketData"  [call-arg]
            return MarketData(
                   ^
infrastructure\external_services\order_manager.py:520:16: error: Unexpected
keyword argument "last_price" for "MarketData"  [call-arg]
            return MarketData(
                   ^
infrastructure\external_services\order_manager.py:525:20: error: Argument
"volume" to "MarketData" has incompatible type "VolumeValue"; expected "Volume" 
[arg-type]
                volume=VolumeValue(Decimal("1000")),
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:526:38: error: Argument 1 to
"TimestampValue" has incompatible type "Decimal"; expected "datetime" 
[arg-type]
                timestamp=TimestampValue(Decimal("1640995200")),
                                         ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:558:24: error: Argument 1 to
"OrderId" has incompatible type "str"; expected "UUID"  [arg-type]
                id=OrderId(str(uuid4())),
                           ^~~~~~~~~~~~
infrastructure\external_services\order_manager.py:562:22: error: Argument
"quantity" to "Order" has incompatible type "Volume"; expected "VolumeValue" 
[arg-type]
                quantity=quantity,
                         ^~~~~~~~
infrastructure\external_services\order_manager.py:577:34: error: Argument 1 of
"cancel_order" is incompatible with supertype "ExchangeProtocol"; supertype
defines the argument type as "str"  [override]
        async def cancel_order(self, order_id: OrderId) -> bool:
                                     ^~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:577:34: note: This violates the Liskov substitution principle
infrastructure\external_services\order_manager.py:577:34: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\external_services\order_manager.py:581:19: error: Missing
positional argument "order_id" in call to "OrderNotFoundError"  [call-arg]
                raise OrderNotFoundError(f"Order not found: {order_id}")
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:591:19: error: Missing
positional argument "order_id" in call to "OrderNotFoundError"  [call-arg]
                raise OrderNotFoundError(f"Order not found: {order_id}")
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:603:36: error: Argument 1 to
"OrderId" has incompatible type "str"; expected "UUID"  [arg-type]
                id=order_id or OrderId(str(uuid4())),
                                       ^~~~~~~~~~~~
infrastructure\external_services\order_manager.py:605:18: error: Argument
"side" to "Order" has incompatible type
"domain.types.external_service_types.OrderSide"; expected
"domain.entities.order.OrderSide"  [arg-type]
                side=request.side,
                     ^~~~~~~~~~~~
infrastructure\external_services\order_manager.py:606:24: error: Argument
"order_type" to "Order" has incompatible type
"domain.types.external_service_types.OrderType"; expected
"domain.entities.order.OrderType"  [arg-type]
                order_type=request.order_type,
                           ^~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:608:19: error: Argument
"price" to "Order" has incompatible type "PriceValue | None"; expected
"Price | None"  [arg-type]
                price=request.price,
                      ^~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:628:19: error: Missing
positional argument "order_id" in call to "OrderNotFoundError"  [call-arg]
                raise OrderNotFoundError(f"Order not found: {order_id}")
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:645:19: error: Missing
positional argument "order_id" in call to "OrderNotFoundError"  [call-arg]
                raise OrderNotFoundError(f"Order not found: {order_id}")
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:653:19: error: Missing
positional argument "order_id" in call to "OrderNotFoundError"  [call-arg]
                raise OrderNotFoundError(f"Order not found: {order_id}")
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:661:28: error: Argument 1 to
"float" has incompatible type "Price"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                "price": float(order.price) if order.price else None,
                               ^~~~~~~~~~~
infrastructure\external_services\order_manager.py:686:32: error: Argument 1 to
"float" has incompatible type "Price"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                    "price": float(order.price) if order.price else None,
                                   ^~~~~~~~~~~
infrastructure\external_services\order_manager.py:697:19: error: Missing
positional argument "order_id" in call to "OrderNotFoundError"  [call-arg]
                raise OrderNotFoundError(f"Order not found: {order_id}")
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:719:32: error: Argument 1 to
"float" has incompatible type "Price"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                    "price": float(order.price) if order.price else None,
                                   ^~~~~~~~~~~
infrastructure\external_services\order_manager.py:756:30: error: Cannot
instantiate abstract class "ProductionOrderManager" with abstract attributes
"create_order", "fetch_balance", ... and "fetch_ticker" (3 methods suppressed) 
[abstract]
            self.order_manager = ProductionOrderManager(self.config)
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:826:34: error: Argument 1 of
"cancel_order" is incompatible with supertype "ExchangeProtocol"; supertype
defines the argument type as "str"  [override]
        async def cancel_order(self, order_id: OrderId) -> bool:
                                     ^~~~~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:826:34: note: This violates the Liskov substitution principle
infrastructure\external_services\order_manager.py:826:34: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\external_services\order_manager.py:848:21: error: Missing
positional argument "currency" in call to "Price"  [call-arg]
            price_obj = Price(price) if price else None
                        ^~~~~~~~~~~~
infrastructure\external_services\order_manager.py:848:27: error: Argument 1 to
"Price" has incompatible type "float"; expected "Decimal"  [arg-type]
            price_obj = Price(price) if price else None
                              ^~~~~
infrastructure\external_services\order_manager.py:853:18: error: Argument
"side" to "OrderRequest" has incompatible type
"domain.entities.order.OrderSide"; expected
"domain.types.external_service_types.OrderSide"  [arg-type]
                side=side_obj,
                     ^~~~~~~~
infrastructure\external_services\order_manager.py:854:24: error: Argument
"order_type" to "OrderRequest" has incompatible type
"domain.entities.order.OrderType"; expected
"domain.types.external_service_types.OrderType"  [arg-type]
                order_type=order_type_obj,
                           ^~~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:855:22: error: Argument
"quantity" to "OrderRequest" has incompatible type "Volume"; expected
"VolumeValue"  [arg-type]
                quantity=quantity_obj,
                         ^~~~~~~~~~~~
infrastructure\external_services\order_manager.py:856:19: error: Argument
"price" to "OrderRequest" has incompatible type "Price | None"; expected
"PriceValue | None"  [arg-type]
                price=price_obj,
                      ^~~~~~~~~
infrastructure\external_services\order_manager.py:866:32: error: Argument 1 to
"OrderId" has incompatible type "str"; expected "UUID"  [arg-type]
            order_id_obj = OrderId(order_id)
                                   ^~~~~~~~
infrastructure\external_services\order_manager.py:871:32: error: Argument 1 to
"OrderId" has incompatible type "str"; expected "UUID"  [arg-type]
            order_id_obj = OrderId(order_id)
                                   ^~~~~~~~
infrastructure\external_services\order_manager.py:881:18: error: Argument
"side" to "OrderRequest" has incompatible type
"domain.entities.order.OrderSide"; expected
"domain.types.external_service_types.OrderSide"  [arg-type]
                side=OrderSide.BUY,  # «начение по умолчанию
                     ^~~~~~~~~~~~~
infrastructure\external_services\order_manager.py:882:24: error: Argument
"order_type" to "OrderRequest" has incompatible type
"domain.entities.order.OrderType"; expected
"domain.types.external_service_types.OrderType"  [arg-type]
                order_type=OrderType.MARKET,  # «начение по умолчанию
                           ^~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:81:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\external_services\ml_services.py:85:14: error: "DataFrame" has
no attribute "copy"  [attr-defined]
            df = df.copy()
                 ^~~~~~~
infrastructure\external_services\ml_services.py:87:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df["sma_5"] = df["close"].rolling(window=5).mean()
            ^~~~~~~~~~~
infrastructure\external_services\ml_services.py:88:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df["sma_20"] = df["close"].rolling(window=20).mean()
            ^~~~~~~~~~~~
infrastructure\external_services\ml_services.py:89:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df["ema_12"] = df["close"].ewm(span=12).mean()
            ^~~~~~~~~~~~
infrastructure\external_services\ml_services.py:90:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df["ema_26"] = df["close"].ewm(span=26).mean()
            ^~~~~~~~~~~~
infrastructure\external_services\ml_services.py:96:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df["rsi"] = 100 - (100 / (1 + rs))
            ^~~~~~~~~
infrastructure\external_services\ml_services.py:98:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df["macd"] = df["ema_12"] - df["ema_26"]
            ^~~~~~~~~~
infrastructure\external_services\ml_services.py:99:9: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
            df["macd_signal"] = df["macd"].ewm(span=9).mean()
            ^~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:100:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["macd_histogram"] = df["macd"] - df["macd_signal"]
            ^~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:102:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["bb_middle"] = df["close"].rolling(window=20).mean()
            ^~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:104:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["bb_upper"] = df["bb_middle"] + (bb_std * 2)
            ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:105:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["bb_lower"] = df["bb_middle"] - (bb_std * 2)
            ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:106:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["bb_width"] = (df["bb_upper"] - df["bb_lower"]) / df["bb_mi...
            ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:108:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["volume_sma"] = df["volume"].rolling(window=20).mean()
            ^~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:109:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["volume_ratio"] = df["volume"] / df["volume_sma"]
            ^~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:111:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["price_change"] = df["close"].pct_change()
            ^~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:112:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["price_change_5"] = df["close"].pct_change(periods=5)
            ^~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:113:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["price_change_20"] = df["close"].pct_change(periods=20)
            ^~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:115:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["volatility"] = df["price_change"].rolling(window=20).std()
            ^~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:117:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["high_20"] = df["high"].rolling(window=20).max()
            ^~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:118:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["low_20"] = df["low"].rolling(window=20).min()
            ^~~~~~~~~~~~
infrastructure\external_services\ml_services.py:119:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["support_resistance_ratio"] = (df["close"] - df["low_20"]) ...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:123:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["momentum"] = df["close"] - df["close"].shift(4)
            ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:124:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["rate_of_change"] = (df["close"] / df["close"].shift(10) - ...
            ^~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:126:14: error: "DataFrame" has
no attribute "dropna"  [attr-defined]
            df = df.dropna()
                 ^~~~~~~~~
infrastructure\external_services\ml_services.py:136:14: error: "DataFrame" has
no attribute "copy"  [attr-defined]
            df = df.copy()
                 ^~~~~~~
infrastructure\external_services\ml_services.py:138:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["fractal_dimension"] = self._calculate_fractal_dimension(df...
            ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:140:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["price_entropy"] = self._calculate_entropy(df["close"])
            ^~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:141:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["volume_entropy"] = self._calculate_entropy(df["volume"])
            ^~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:143:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["wavelet_coeff"] = self._calculate_wavelet_coefficient(df["...
            ^~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:145:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["bid_ask_spread"] = (df["high"] - df["low"]) / df["close"]
            ^~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:146:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["price_efficiency"] = self._calculate_price_efficiency(df["...
            ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:148:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["hour"] = pd.to_datetime(df["timestamp"], unit="ms").dt.hou...
            ^~~~~~~~~~
infrastructure\external_services\ml_services.py:148:22: error: Item "Timestamp"
of "Timestamp | DatetimeIndex | Any" has no attribute "dt"  [union-attr]
            df["hour"] = pd.to_datetime(df["timestamp"], unit="ms").dt.hou...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:148:22: error: Item
"DatetimeIndex" of "Timestamp | DatetimeIndex | Any" has no attribute "dt" 
[union-attr]
            df["hour"] = pd.to_datetime(df["timestamp"], unit="ms").dt.hou...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:149:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["day_of_week"] = pd.to_datetime(df["timestamp"], unit="ms")...
            ^~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:149:29: error: Item "Timestamp"
of "Timestamp | DatetimeIndex | Any" has no attribute "dt"  [union-attr]
            df["day_of_week"] = pd.to_datetime(df["timestamp"], unit="ms")...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:149:29: error: Item
"DatetimeIndex" of "Timestamp | DatetimeIndex | Any" has no attribute "dt" 
[union-attr]
            df["day_of_week"] = pd.to_datetime(df["timestamp"], unit="ms")...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:150:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["month"] = pd.to_datetime(df["timestamp"], unit="ms").dt.mo...
            ^~~~~~~~~~~
infrastructure\external_services\ml_services.py:150:23: error: Item "Timestamp"
of "Timestamp | DatetimeIndex | Any" has no attribute "dt"  [union-attr]
            df["month"] = pd.to_datetime(df["timestamp"], unit="ms").dt.mo...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:150:23: error: Item
"DatetimeIndex" of "Timestamp | DatetimeIndex | Any" has no attribute "dt" 
[union-attr]
            df["month"] = pd.to_datetime(df["timestamp"], unit="ms").dt.mo...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:152:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["hour_sin"] = np.sin(2 * np.pi * df["hour"] / 24)
            ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:153:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["hour_cos"] = np.cos(2 * np.pi * df["hour"] / 24)
            ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:154:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["day_sin"] = np.sin(2 * np.pi * df["day_of_week"] / 7)
            ^~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:155:9: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
            df["day_cos"] = np.cos(2 * np.pi * df["day_of_week"] / 7)
            ^~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:161:23: error: "Series" has no
attribute "rolling"  [attr-defined]
            return np.log(series.rolling(window=10).std()) / np.log(
                          ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:162:13: error: "Series" has no
attribute "rolling"  [attr-defined]
                series.rolling(window=10).mean()
                ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:178:16: error: "Series" has no
attribute "rolling"  [attr-defined]
            return series.rolling(window=20).apply(entropy)
                   ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:183:16: error: "Series" has no
attribute "rolling"  [attr-defined]
            return series.rolling(window=8).apply(
                   ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:195:16: error: "Series" has no
attribute "rolling"  [attr-defined]
            return series.rolling(window=20).apply(efficiency)
                   ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:205:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                df[feature_cols] = self.scaler.fit_transform(df[feature_co...
                ^~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:207:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                df[feature_cols] = self.scaler.transform(df[feature_cols])
                ^~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:230:20: error: "LockType" has
no attribute "__aenter__"; maybe "__enter__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml_services.py:230:20: error: "LockType" has
no attribute "__aexit__"; maybe "__exit__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml_services.py:231:32: error: "type[UUID]" has
no attribute "uuid4"  [attr-defined]
                model_id = ModelId(UUID.uuid4())
                                   ^~~~~~~~~~
infrastructure\external_services\ml_services.py:237:33: error: Argument
"prediction_type" to "Model" has incompatible type
"domain.types.external_service_types.PredictionType"; expected
"domain.entities.ml.PredictionType"  [arg-type]
                    prediction_type=PredictionType(config["prediction_type...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\external_services\ml_services.py:238:26: error: Argument
"features" to "Model" has incompatible type "list[FeatureName]"; expected
"list[str]"  [arg-type]
                    features=config["features"],
                             ^~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:238:26: note: "list" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
infrastructure\external_services\ml_services.py:238:26: note: Consider using "Sequence" instead, which is covariant
infrastructure\external_services\ml_services.py:239:24: error:
"type[ModelStatus]" has no attribute "CREATED"  [attr-defined]
                    status=ModelStatus.CREATED,
                           ^~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:289:43: error: Argument 1 to
"ModelManager" has incompatible type "MLServiceConfig | None"; expected
"MLServiceConfig"  [arg-type]
            self.model_manager = ModelManager(config)
                                              ^~~~~~
infrastructure\external_services\ml_services.py:353:24: error: "LockType" has
no attribute "__aenter__"; maybe "__enter__"?  [attr-defined]
                async with self.lock:
                           ^~~~~~~~~
infrastructure\external_services\ml_services.py:353:24: error: "LockType" has
no attribute "__aexit__"; maybe "__exit__"?  [attr-defined]
                async with self.lock:
                           ^~~~~~~~~
infrastructure\external_services\ml_services.py:357:13: error: Unsupported
operand types for + ("None" and "int")  [operator]
                self.metrics["successful_training_sessions"] += 1
                ^
infrastructure\external_services\ml_services.py:357:13: note: Left operand is of type "float | None"
infrastructure\external_services\ml_services.py:358:53: error: Unsupported
operand types for / ("float" and "None")  [operator]
                self.metrics["average_training_time"] = (
                                                        ^
infrastructure\external_services\ml_services.py:358:53: note: Right operand is of type "float | None"
infrastructure\external_services\ml_services.py:359:17: error: Unsupported
operand types for * ("None" and "float")  [operator]
                    self.metrics["average_training_time"]
                    ^
infrastructure\external_services\ml_services.py:359:17: error: Unsupported
operand types for * ("None" and "int")  [operator]
                    self.metrics["average_training_time"]
                    ^
infrastructure\external_services\ml_services.py:359:17: note: Both left and right operands are unions
infrastructure\external_services\ml_services.py:360:20: error: Unsupported
operand types for - ("None" and "int")  [operator]
                    * (self.metrics["successful_training_sessions"] - 1)
                       ^
infrastructure\external_services\ml_services.py:360:20: note: Left operand is of type "float | None"
infrastructure\external_services\ml_services.py:368:13: error: Unsupported
operand types for + ("None" and "int")  [operator]
                self.metrics["failed_training_sessions"] += 1
                ^
infrastructure\external_services\ml_services.py:368:13: note: Left operand is of type "float | None"
infrastructure\external_services\ml_services.py:369:42: error: Incompatible
types in assignment (expression has type "str", target has type "float | None") 
[assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\ml_services.py:523:13: error: Unsupported
operand types for + ("None" and "int")  [operator]
                self.metrics["successful_predictions"] += 1
                ^
infrastructure\external_services\ml_services.py:523:13: note: Left operand is of type "float | None"
infrastructure\external_services\ml_services.py:524:55: error: Unsupported
operand types for / ("float" and "None")  [operator]
                self.metrics["average_prediction_time"] = (
                                                          ^
infrastructure\external_services\ml_services.py:524:55: note: Right operand is of type "float | None"
infrastructure\external_services\ml_services.py:525:17: error: Unsupported
operand types for * ("None" and "float")  [operator]
                    self.metrics["average_prediction_time"]
                    ^
infrastructure\external_services\ml_services.py:525:17: error: Unsupported
operand types for * ("None" and "int")  [operator]
                    self.metrics["average_prediction_time"]
                    ^
infrastructure\external_services\ml_services.py:525:17: note: Both left and right operands are unions
infrastructure\external_services\ml_services.py:526:20: error: Unsupported
operand types for - ("None" and "int")  [operator]
                    * (self.metrics["successful_predictions"] - 1)
                       ^
infrastructure\external_services\ml_services.py:526:20: note: Left operand is of type "float | None"
infrastructure\external_services\ml_services.py:531:13: error: Unsupported
operand types for + ("None" and "int")  [operator]
                self.metrics["failed_predictions"] += 1
                ^
infrastructure\external_services\ml_services.py:531:13: note: Left operand is of type "float | None"
infrastructure\external_services\ml_services.py:532:42: error: Incompatible
types in assignment (expression has type "str", target has type "float | None") 
[assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\ml_services.py:609:24: error: "LockType" has
no attribute "__aenter__"; maybe "__enter__"?  [attr-defined]
                async with self.lock:
                           ^~~~~~~~~
infrastructure\external_services\ml_services.py:609:24: error: "LockType" has
no attribute "__aexit__"; maybe "__exit__"?  [attr-defined]
                async with self.lock:
                           ^~~~~~~~~
infrastructure\external_services\ml_services.py:643:20: error: "LockType" has
no attribute "__aenter__"; maybe "__enter__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml_services.py:643:20: error: "LockType" has
no attribute "__aexit__"; maybe "__exit__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml_services.py:654:20: error: "LockType" has
no attribute "__aenter__"; maybe "__enter__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml_services.py:654:20: error: "LockType" has
no attribute "__aexit__"; maybe "__exit__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml_services.py:704:23: error:
"ProductionMLService" has no attribute "get_model"  [attr-defined]
            model = await self.service.get_model(trained_model_id)
                          ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:732:29: error: Argument
"prediction_type" to "Prediction" has incompatible type
"domain.types.external_service_types.PredictionType"; expected
"domain.entities.ml.PredictionType"  [arg-type]
                prediction_type=PredictionType.PRICE,
                                ^~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:769:19: error: Name
"ModelLoadError" is not defined  [name-defined]
                raise ModelLoadError(f"Failed to load model {model_id}")
                      ^~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:771:23: error:
"ProductionMLService" has no attribute "get_model"  [attr-defined]
            model = await self.service.get_model(model_id)
                          ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:773:19: error: Name
"ModelNotFoundError" is not defined  [name-defined]
                raise ModelNotFoundError(f"Model {model_id} not found afte...
                      ^~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:788:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\external_services\ml_services.py:789:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\external_services\ml_services.py:800:18: error: Incompatible
types (expression has type "str", TypedDict item "name" has type "ModelName") 
[typeddict-item]
                name=f"LocalModel_{model_id}",
                     ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml_services.py:802:26: error: Incompatible
types (expression has type "str", TypedDict item "trading_pair" has type
"Symbol")  [typeddict-item]
                trading_pair="BTCUSDT",
                             ^~~~~~~~~
infrastructure\external_services\ml_services.py:804:23: error: List item 0 has
incompatible type "str"; expected "FeatureName"  [list-item]
                features=["price", "volume"],
                          ^~~~~~~
infrastructure\external_services\ml_services.py:804:32: error: List item 1 has
incompatible type "str"; expected "FeatureName"  [list-item]
                features=["price", "volume"],
                                   ^~~~~~~~
infrastructure\external_services\ml_services.py:805:20: error: Incompatible
types (expression has type "str", TypedDict item "target" has type "TargetName")
 [typeddict-item]
                target="next_price",
                       ^~~~~~~~~~~~
infrastructure\external_services\ml_services.py:821:41: error: Argument
"features" to "MLPredictionRequest" has incompatible type "dict[str, Any]";
expected "dict[FeatureName, float]"  [arg-type]
                model_id=model_id, features=features
                                            ^~~~~~~~
infrastructure\external_services\ml_services.py:824:22: error: Unexpected
keyword argument "prediction" for "Prediction"; did you mean "prediction_type"? 
[call-arg]
            prediction = Prediction(
                         ^
infrastructure\external_services\bybit_client.py:95:43: error:
"type[ConnectionStatus]" has no attribute "AUTHENTICATED"  [attr-defined]
                    self._connection_status = ConnectionStatus.AUTHENTICAT...
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\bybit_client.py:117:62: error: Argument
"available" to "Balance" has incompatible type "float"; expected "Decimal" 
[arg-type]
    ...  return Balance(currency=str(currency), available=1000.0, locked=0.0)
                                                          ^~~~~~
infrastructure\external_services\bybit_client.py:117:77: error: Argument
"locked" to "Balance" has incompatible type "float"; expected "Decimal" 
[arg-type]
    ...  return Balance(currency=str(currency), available=1000.0, locked=0.0)
                                                                         ^~~
infrastructure\external_services\bybit_client.py:129:20: error: Missing
positional argument "exchange" in call to "OrderBookSnapshot"  [call-arg]
                return OrderBookSnapshot(
                       ^
infrastructure\external_services\bybit_client.py:133:27: error: Argument
"timestamp" to "OrderBookSnapshot" has incompatible type "int"; expected
"Timestamp"  [arg-type]
                    timestamp=0,
                              ^
infrastructure\external_services\bybit_client.py:144:20: error: Unexpected
keyword argument "bid_price" for "MarketData"  [call-arg]
                return MarketData(
                       ^
infrastructure\external_services\bybit_client.py:144:20: error: Unexpected
keyword argument "ask_price" for "MarketData"  [call-arg]
                return MarketData(
                       ^
infrastructure\external_services\bybit_client.py:144:20: error: Unexpected
keyword argument "last_price" for "MarketData"  [call-arg]
                return MarketData(
                       ^
infrastructure\external_services\bybit_client.py:146:38: error: Argument 1 to
"PriceValue" has incompatible type "int"; expected "Decimal"  [arg-type]
                    bid_price=PriceValue(50000),
                                         ^~~~~
infrastructure\external_services\bybit_client.py:147:38: error: Argument 1 to
"PriceValue" has incompatible type "int"; expected "Decimal"  [arg-type]
                    ask_price=PriceValue(50001),
                                         ^~~~~
infrastructure\external_services\bybit_client.py:148:39: error: Argument 1 to
"PriceValue" has incompatible type "float"; expected "Decimal"  [arg-type]
                    last_price=PriceValue(50000.5),
                                          ^~~~~~~
infrastructure\external_services\bybit_client.py:149:24: error: Argument
"volume" to "MarketData" has incompatible type "VolumeValue"; expected "Volume" 
[arg-type]
                    volume=VolumeValue(1000),
                           ^~~~~~~~~~~~~~~~~
infrastructure\external_services\bybit_client.py:149:36: error: Argument 1 to
"VolumeValue" has incompatible type "int"; expected "Decimal"  [arg-type]
                    volume=VolumeValue(1000),
                                       ^~~~
infrastructure\external_services\bybit_client.py:150:27: error: Name
"TimestampValue" is not defined  [name-defined]
                    timestamp=TimestampValue(1640995200),
                              ^~~~~~~~~~~~~~
infrastructure\external_services\bybit_client.py:183:28: error: Argument 1 to
"OrderId" has incompatible type "str"; expected "UUID"  [arg-type]
                    id=OrderId("temp_order_id"),
                               ^~~~~~~~~~~~~~~
infrastructure\external_services\bybit_client.py:187:26: error: Argument
"quantity" to "Order" has incompatible type "Volume"; expected "VolumeValue" 
[arg-type]
                    quantity=quantity,
                             ^~~~~~~~
infrastructure\external_services\bybit_client.py:194:34: error: Argument 1 of
"cancel_order" is incompatible with supertype "ExchangeProtocol"; supertype
defines the argument type as "str"  [override]
        async def cancel_order(self, order_id: OrderId) -> bool:
                                     ^~~~~~~~~~~~~~~~~
infrastructure\external_services\bybit_client.py:194:34: note: This violates the Liskov substitution principle
infrastructure\external_services\bybit_client.py:194:34: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\external_services\bybit_client.py:215:26: error: Argument
"quantity" to "Order" has incompatible type "Volume"; expected "VolumeValue" 
[arg-type]
                    quantity=Volume(1.0),
                             ^~~~~~~~~~~
infrastructure\external_services\bybit_client.py:281:39: error: Argument 1 to
"float" has incompatible type "Money"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                commission_amount = float(order_value) * commission_rate
                                          ^~~~~~~~~~~
infrastructure\external_services\bybit_client.py:292:27: error: Name
"MarketDataRequest" is not defined  [name-defined]
                    request = MarketDataRequest(
                              ^~~~~~~~~~~~~~~~~
infrastructure\external_services\bybit_client.py:401:35: error: Name "time" is
not defined  [name-defined]
                    "serverTime": int(time.time() * 1000),
                                      ^~~~
infrastructure\external_services\account_manager.py:98:51: error: Argument
"available" to "Balance" has incompatible type "float"; expected "Decimal" 
[arg-type]
                    Balance(currency="BTC", available=1.0, locked=0.0),
                                                      ^~~
infrastructure\external_services\account_manager.py:98:63: error: Argument
"locked" to "Balance" has incompatible type "float"; expected "Decimal" 
[arg-type]
                    Balance(currency="BTC", available=1.0, locked=0.0),
                                                                  ^~~
infrastructure\external_services\account_manager.py:99:52: error: Argument
"available" to "Balance" has incompatible type "float"; expected "Decimal" 
[arg-type]
    ...              Balance(currency="USDT", available=50000.0, locked=0.0),
                                                        ^~~~~~~
infrastructure\external_services\account_manager.py:99:68: error: Argument
"locked" to "Balance" has incompatible type "float"; expected "Decimal" 
[arg-type]
    ...              Balance(currency="USDT", available=50000.0, locked=0.0),
                                                                        ^~~
infrastructure\external_services\account_manager.py:134:34: error: Argument 1
of "cancel_order" is incompatible with supertype "ExchangeProtocol"; supertype
defines the argument type as "str"  [override]
        async def cancel_order(self, order_id: OrderId) -> bool:
                                     ^~~~~~~~~~~~~~~~~
infrastructure\external_services\account_manager.py:134:34: note: This violates the Liskov substitution principle
infrastructure\external_services\account_manager.py:134:34: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\evolution\strategy_storage.py:445:38: error: Incompatible types
(expression has type "datetime | None", TypedDict item "last_backup_time" has
type "str | None")  [typeddict-item]
                        last_backup_time=last_backup_time,
                                         ^~~~~~~~~~~~~~~~
infrastructure\evolution\strategy_storage.py:515:17: error: "Sequence[str]" has
no attribute "append"  [attr-defined]
                    export_data["candidates"].append(candidate.to_dict())
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\evolution\strategy_storage.py:520:17: error: "Sequence[str]" has
no attribute "append"  [attr-defined]
                    export_data["evaluations"].append(evaluation.to_dict()...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\evolution\strategy_storage.py:525:17: error: "Sequence[str]" has
no attribute "append"  [attr-defined]
                    export_data["contexts"].append(context.to_dict())
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\evolution\storage.py:522:17: error: "Sequence[str]" has no
attribute "append"  [attr-defined]
                    export_data["candidates"].append(candidate.to_dict())
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\evolution\storage.py:527:17: error: "Sequence[str]" has no
attribute "append"  [attr-defined]
                    export_data["evaluations"].append(evaluation.to_dict()...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\evolution\storage.py:532:17: error: "Sequence[str]" has no
attribute "append"  [attr-defined]
                    export_data["contexts"].append(context.to_dict())
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_evolution_example.py:94:22: error: Module has no attribute
"date_range"  [attr-defined]
            timestamps = pd.date_range(
                         ^~~~~~~~~~~~~
examples\strategy_evolution_example.py:95:19: error: "type[Timestamp]" has no
attribute "now"  [attr-defined]
                start=pd.Timestamp.now() - pd.Timedelta(days=periods),
                      ^~~~~~~~~~~~~~~~
examples\strategy_evolution_example.py:95:40: error: Module has no attribute
"Timedelta"  [attr-defined]
                start=pd.Timestamp.now() - pd.Timedelta(days=periods),
                                           ^~~~~~~~~~~~
examples\strategy_evolution_example.py:107:9: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
            df['symbol'] = self.config.symbols[0] if self.config.symbols e...
            ^~~~~~~~~~~~
examples\strategy_evolution_example.py:108:16: error: "DataFrame" has no
attribute "set_index"  [attr-defined]
            return df.set_index('timestamp')
                   ^~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:92:25: error: Incompatible types in
assignment (expression has type "Decimal | Literal[0]", variable has type
"Decimal")  [assignment]
                total_pnl = sum(Decimal(str(trade.get("pnl", 0))) for trad...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
examples\mirror_neuron_signal_example.py:178:22: error: Module has no attribute
"date_range"  [attr-defined]
            timestamps = pd.date_range(
                         ^~~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:179:19: error: "type[Timestamp]" has
no attribute "now"  [attr-defined]
                start=pd.Timestamp.now() - pd.Timedelta(days=periods),
                      ^~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:179:40: error: Module has no attribute
"Timedelta"  [attr-defined]
                start=pd.Timestamp.now() - pd.Timedelta(days=periods),
                                           ^~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:193:9: error: Unsupported target for
indexed assignment ("DataFrame")  [index]
            df['symbol'] = self.config.symbols[0] if self.config.symbols e...
            ^~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:194:16: error: "DataFrame" has no
attribute "set_index"  [attr-defined]
            return df.set_index('timestamp')
                   ^~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:217:14: error: "DataFrame" has no
attribute "copy"  [attr-defined]
            df = self.market_data.copy()
                 ^~~~~~~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:260:23: error: "DataFrame" has no
attribute "tail"  [attr-defined]
            recent_data = self.market_data.tail(100)
                          ^~~~~~~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:285:26: error: Unexpected keyword
argument "signal_id" for "Signal"  [call-arg]
                    signal = Signal(
                             ^
examples\mirror_neuron_signal_example.py:285:26: error: Unexpected keyword
argument "symbol" for "Signal"  [call-arg]
                    signal = Signal(
                             ^
examples\mirror_neuron_signal_example.py:290:31: error: Argument "timestamp" to
"Signal" has incompatible type "Timestamp"; expected "datetime"  [arg-type]
                        timestamp=Timestamp.now(),
                                  ^~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:292:25: error: Dict entry 0 has
incompatible type "str": "Any | None"; expected "str":
"str | int | float | Decimal | list[str] | dict[str, str | int | float | Decimal | bool]"
 [dict-item]
                            'pattern_id': pattern.get('id'),
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:293:25: error: Dict entry 1 has
incompatible type "str": "Any | None"; expected "str":
"str | int | float | Decimal | list[str] | dict[str, str | int | float | Decimal | bool]"
 [dict-item]
                            'confidence': pattern.get('confidence'),
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:294:25: error: Dict entry 2 has
incompatible type "str": "Any | None"; expected "str":
"str | int | float | Decimal | list[str] | dict[str, str | int | float | Decimal | bool]"
 [dict-item]
                            'pattern_type': pattern.get('type'),
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:295:25: error: Dict entry 3 has
incompatible type "str": "Any | None"; expected "str":
"str | int | float | Decimal | list[str] | dict[str, str | int | float | Decimal | bool]"
 [dict-item]
                            'neural_activation': pattern.get('neural_activ...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
examples\mirror_neuron_signal_example.py:314:20: error: "type[SignalType]" has
no attribute "REVERSAL"  [attr-defined]
                return SignalType.REVERSAL
                       ^~~~~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:342:37: error: Argument 1 to "float"
has incompatible type
"str | int | float | Decimal | list[str] | dict[str, str | int | float | Decimal | bool]";
expected "str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                    entry_price = float(signal.metadata.get('current_price...
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
examples\mirror_neuron_signal_example.py:347:37: error: Argument 1 to "float"
has incompatible type
"str | int | float | Decimal | list[str] | dict[str, str | int | float | Decimal | bool]";
expected "str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                    entry_price = float(signal.metadata.get('current_price...
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
examples\mirror_neuron_signal_example.py:350:40: error: "type[SignalType]" has
no attribute "REVERSAL"  [attr-defined]
                elif signal.signal_type == SignalType.REVERSAL and current...
                                           ^~~~~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example.py:352:36: error: Argument 1 to "float"
has incompatible type
"str | int | float | Decimal | list[str] | dict[str, str | int | float | Decimal | bool]";
expected "str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                    exit_price = float(signal.metadata.get('current_price'...
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
examples\mirror_neuron_signal_example.py:360:34: error: "Signal" has no
attribute "signal_id"  [attr-defined]
                        'signal_id': signal.signal_id
                                     ^~~~~~~~~~~~~~~~
examples\liquidity_gravity_example.py:22:1: error: Module
"application.risk.liquidity_gravity_monitor" has no attribute
"LiquidityGravityFilter"; maybe "LiquidityGravityMonitor",
"LiquidityGravityResult", or "LiquidityGravityModel"?  [attr-defined]
    from application.risk.liquidity_gravity_monitor import (
    ^
examples\liquidity_gravity_example.py:22:1: error: Module
"application.risk.liquidity_gravity_monitor" has no attribute
"LiquidityRiskAssessor"  [attr-defined]
    from application.risk.liquidity_gravity_monitor import (
    ^
examples\liquidity_gravity_example.py:22:1: error: Module
"application.risk.liquidity_gravity_monitor" has no attribute "RiskThresholds" 
[attr-defined]
    from application.risk.liquidity_gravity_monitor import (
    ^
examples\liquidity_gravity_example.py:92:23: error: Argument "timestamp" to
"LiquidityGravitySignal" has incompatible type "datetime"; expected "Timestamp" 
[arg-type]
                timestamp=datetime.now(),
                          ^~~~~~~~~~~~~~
examples\liquidity_gravity_example.py:211:23: error: Argument "timestamp" to
"OrderBookSnapshot" has incompatible type "Timestamp"; expected "datetime" 
[arg-type]
                timestamp=Timestamp.now(),
                          ^~~~~~~~~~~~~~~
examples\liquidity_gravity_example.py:235:23: error: Argument "timestamp" to
"OrderBookSnapshot" has incompatible type "Timestamp"; expected "datetime" 
[arg-type]
                timestamp=Timestamp.now(),
                          ^~~~~~~~~~~~~~~
examples\liquidity_gravity_example.py:260:23: error: Argument "timestamp" to
"OrderBookSnapshot" has incompatible type "Timestamp"; expected "datetime" 
[arg-type]
                timestamp=Timestamp.now(),
                          ^~~~~~~~~~~~~~~
examples\liquidity_gravity_example.py:327:29: error: Incompatible types in
assignment (expression has type "Decimal | Literal[0]", variable has type
"Decimal")  [assignment]
                    total_pnl = sum(Decimal(str(trade["pnl"])) for trade i...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
examples\liquidity_gravity_example.py:541:19: error: Argument "timestamp" to
"OrderBookSnapshot" has incompatible type "Timestamp"; expected "datetime" 
[arg-type]
            timestamp=Timestamp.now(),
                      ^~~~~~~~~~~~~~~
examples\liquidity_gravity_example.py:555:19: error: Argument "timestamp" to
"OrderBookSnapshot" has incompatible type "Timestamp"; expected "datetime" 
[arg-type]
            timestamp=Timestamp.now(),
                      ^~~~~~~~~~~~~~~
examples\liquidity_gravity_example.py:581:14: error: Name "ExampleMode" is not
defined  [name-defined]
            mode=ExampleMode.DEMO,
                 ^~~~~~~~~~~
examples\liquidity_gravity_example.py:598:5: error: Name "asyncio" is not
defined  [name-defined]
        asyncio.run(main())
        ^~~~~~~
application\services\notification_service.py:149:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\unit\domain\sessions\test_integration.py:8:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
shared\visualization.py:15:13: error: "Series" has no attribute "index" 
[attr-defined]
        ax.plot(equity_data.index, equity_data.values)
                ^~~~~~~~~~~~~~~~~
shared\visualization.py:15:32: error: Argument 2 to "plot" of "Axes" has
incompatible type "Callable[[], ndarray[Any, Any]]"; expected
"float | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] | str"
 [arg-type]
        ax.plot(equity_data.index, equity_data.values)
                                   ^~~~~~~~~~~~~~~~~~
shared\visualization.py:31:14: error: "Series" has no attribute "index" 
[attr-defined]
        ax1.plot(prices.index, prices.values, label="Price")
                 ^~~~~~~~~~~~
shared\visualization.py:38:18: error: "Series" has no attribute "index" 
[attr-defined]
            ax2.plot(indicator.index, indicator.values, label=name)
                     ^~~~~~~~~~~~~~~
shared\visualization.py:53:14: error: "Series" has no attribute "index" 
[attr-defined]
        ax1.plot(cvd.index, cvd.values, label="CVD", color="blue")
                 ^~~~~~~~~
shared\visualization.py:59:14: error: "Series" has no attribute "index" 
[attr-defined]
        ax2.plot(delta_volume.index, delta_volume.values, label="Delta Vol...
                 ^~~~~~~~~~~~~~~~~~
shared\visualization.py:74:13: error: "Series" has no attribute "index" 
[attr-defined]
        ax.plot(prices.index, prices.values, label="Price", color="black")
                ^~~~~~~~~~~~
shared\visualization.py:74:27: error: Argument 2 to "plot" of "Axes" has
incompatible type "Callable[[], ndarray[Any, Any]]"; expected
"float | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] | str"
 [arg-type]
        ax.plot(prices.index, prices.values, label="Price", color="black")
                              ^~~~~~~~~~~~~
shared\visualization.py:163:13: error: Argument 1 to "hist" of "Axes" has
incompatible type "Callable[[], ndarray[Any, Any]]"; expected
"_SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] | Sequence[_SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes]]"
 [arg-type]
        ax.hist(data.values, bins=50, alpha=0.7, edgecolor="black")
                ^~~~~~~~~~~
shared\visualization.py:174:13: error: "Series" has no attribute "index" 
[attr-defined]
        ax.plot(data.index, data.values)
                ^~~~~~~~~~
shared\visualization.py:174:25: error: Argument 2 to "plot" of "Axes" has
incompatible type "Callable[[], ndarray[Any, Any]]"; expected
"float | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] | str"
 [arg-type]
        ax.plot(data.index, data.values)
                            ^~~~~~~~~~~
infrastructure\strategies\visualization.py:142:27: error: "Series" has no
attribute "expanding"  [attr-defined]
                running_max = equity.expanding().max()
                              ^~~~~~~~~~~~~~~~
infrastructure\strategies\visualization.py:169:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                df["exit_time"] = pd.to_datetime(df["exit_time"])
                ^~~~~~~~~~~~~~~
infrastructure\strategies\visualization.py:170:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                df["month"] = df["exit_time"].dt.to_period("M")
                ^~~~~~~~~~~
infrastructure\strategies\visualization.py:172:31: error: "DataFrame" has no
attribute "groupby"  [attr-defined]
                monthly_returns = df.groupby("month")["profit"].sum()
                                  ^~~~~~~~~~
infrastructure\strategies\visualization.py:225:21: error: Argument 1 to "bar"
has incompatible type "dict_keys[str, Any]"; expected
"float | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes]"
 [arg-type]
                plt.bar(metrics.keys(), metrics.values())
                        ^~~~~~~~~~~~~~
infrastructure\strategies\visualization.py:225:37: error: Argument 2 to "bar"
has incompatible type "dict_values[str, Any]"; expected
"float | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes]"
 [arg-type]
                plt.bar(metrics.keys(), metrics.values())
                                        ^~~~~~~~~~~~~~~~
infrastructure\strategies\visualization.py:284:13: error: "DataFrame" has no
attribute "to_csv"  [attr-defined]
                pd.DataFrame([results]).to_csv(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\backtest.py:72:51: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
                    signal = strategy.generate_signal(data.iloc[: i + 1])
                                                      ^~~~~~~~~
infrastructure\strategies\backtest.py:223:46: error: Unsupported operand types
for > ("int" and "Series")  [operator]
                        returns.mean() / returns[returns < 0].std()
                                                 ^
infrastructure\strategies\backtest.py:224:32: error: Unsupported operand types
for > ("int" and "Series")  [operator]
                        if returns[returns < 0].std() != 0
                                   ^
infrastructure\strategies\backtest.py:248:27: error: "Series" has no attribute
"expanding"  [attr-defined]
                running_max = equity.expanding().max()
                              ^~~~~~~~~~~~~~~~
infrastructure\strategies\backtest.py:336:17: error: "DataFrame" has no
attribute "to_csv"  [attr-defined]
                    pd.DataFrame([results]).to_csv(
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:11:1: error: Library stubs not
installed for "aiofiles"  [import-untyped]
    import aiofiles
    ^
infrastructure\simulation\backtest_explainer.py:11:1: note: Hint: "python3 -m pip install types-aiofiles"
infrastructure\simulation\backtest_explainer.py:11:1: note: (or run "mypy --install-types" to install all missing stub packages)
infrastructure\simulation\backtest_explainer.py:11:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
infrastructure\simulation\backtest_explainer.py:145:26: error: "DataFrame" has
no attribute "loc"  [attr-defined]
                entry_data = market_data.loc[entry_time]
                             ^~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:405:28: error: "DataFrame" has
no attribute "groupby"  [attr-defined]
                regime_stats = data.groupby("regime").agg(
                               ^~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:413:32: error: "DataFrame" has
no attribute "groupby"  [attr-defined]
                regime_durations = data.groupby("regime").size()
                                   ^~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:415:34: error: Module has no
attribute "crosstab"  [attr-defined]
                regime_transitions = pd.crosstab(data["regime"].shift(), d...
                                     ^~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:441:20: error: Unsupported
right operand type for in ("object")  [operator]
                    if pattern_type not in pattern_stats["pattern_types"]:
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:442:21: error: Unsupported
target for indexed assignment ("object")  [index]
                        pattern_stats["pattern_types"][pattern_type] = 0
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:443:17: error: Value of type
"object" is not indexable  [index]
                    pattern_stats["pattern_types"][pattern_type] += 1
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:443:17: error: Unsupported
target for indexed assignment ("object")  [index]
                    pattern_stats["pattern_types"][pattern_type] += 1
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:445:24: error: Unsupported
right operand type for in ("object")  [operator]
                        if pattern_type not in pattern_stats["pattern_accu...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\simulation\backtest_explainer.py:446:25: error: Unsupported
target for indexed assignment ("object")  [index]
                            pattern_stats["pattern_accuracy"][pattern_type...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:447:21: error: Value of type
"object" is not indexable  [index]
                        pattern_stats["pattern_accuracy"][pattern_type].ap...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:451:24: error: Unsupported
right operand type for in ("object")  [operator]
                        if pattern_type not in pattern_stats["pattern_prof...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\simulation\backtest_explainer.py:452:25: error: Unsupported
target for indexed assignment ("object")  [index]
                            pattern_stats["pattern_profitability"][pattern...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\simulation\backtest_explainer.py:453:21: error: Value of type
"object" is not indexable  [index]
                        pattern_stats["pattern_profitability"][pattern_typ...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:457:33: error: "object" has no
attribute "__iter__"; maybe "__dir__" or "__str__"? (not iterable) 
[attr-defined]
                for pattern_type in pattern_stats["pattern_accuracy"]:
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:458:17: error: Unsupported
target for indexed assignment ("object")  [index]
                    pattern_stats["pattern_accuracy"][pattern_type] = np.m...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:459:21: error: Value of type
"object" is not indexable  [index]
                        pattern_stats["pattern_accuracy"][pattern_type]
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:461:33: error: "object" has no
attribute "__iter__"; maybe "__dir__" or "__str__"? (not iterable) 
[attr-defined]
                for pattern_type in pattern_stats["pattern_profitability"]...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:462:17: error: Unsupported
target for indexed assignment ("object")  [index]
                    pattern_stats["pattern_profitability"][pattern_type] =...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:463:21: error: Value of type
"object" is not indexable  [index]
                        pattern_stats["pattern_profitability"][pattern_typ...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:554:28: error: "DataFrame" has
no attribute "corr"  [attr-defined]
                correlations = data.corr()
                               ^~~~~~~~~
infrastructure\simulation\backtest_explainer.py:629:13: error: "DataFrame" has
no attribute "plot"  [attr-defined]
                metrics_df.plot(ax=ax5)
                ^~~~~~~~~~~~~~~
infrastructure\simulation\backtest_explainer.py:634:25: error: "DataFrame" has
no attribute "corr"  [attr-defined]
                sns.heatmap(data.corr(), ax=ax6)
                            ^~~~~~~~~
infrastructure\ml_services\visualization.py:221:23: error: "DataFrame" has no
attribute "close"  [attr-defined]
                up = data[data.close >= data.open]
                          ^~~~~~~~~~
infrastructure\ml_services\visualization.py:221:37: error: "DataFrame" has no
attribute "open"  [attr-defined]
                up = data[data.close >= data.open]
                                        ^~~~~~~~~
infrastructure\ml_services\visualization.py:222:25: error: "DataFrame" has no
attribute "close"  [attr-defined]
                down = data[data.close < data.open]
                            ^~~~~~~~~~
infrastructure\ml_services\visualization.py:222:38: error: "DataFrame" has no
attribute "open"  [attr-defined]
                down = data[data.close < data.open]
                                         ^~~~~~~~~
infrastructure\ml_services\visualization.py:334:26: error: Argument 1 to "plot"
of "Axes" has incompatible type "Series"; expected
"float | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] | str"
 [arg-type]
                    ax3.plot(indicators["rsi"], color="purple")
                             ^~~~~~~~~~~~~~~~~
infrastructure\ml_services\visualization.py:342:26: error: Argument 1 to "plot"
of "Axes" has incompatible type "Series"; expected
"float | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] | str"
 [arg-type]
                    ax4.plot(indicators["macd"], label="MACD", color="blue...
                             ^~~~~~~~~~~~~~~~~~
infrastructure\ml_services\visualization.py:343:26: error: Argument 1 to "plot"
of "Axes" has incompatible type "Series"; expected
"float | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes] | str"
 [arg-type]
                    ax4.plot(indicators["macd_signal"], label="Signal", co...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\exchange.py:19:1: error: Module
"infrastructure.external_services.order_manager" has no attribute
"OrderManager"; maybe "OrderManagerAdapter"?  [attr-defined]
    from .order_manager import OrderManager
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\exchange.py:20:1: error: Module
"infrastructure.external_services.technical_analysis_service" has no attribute
"AccountMetrics"  [attr-defined]
    from .technical_analysis_service import AccountMetrics
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\exchange.py:61:23: error: Cannot instantiate
abstract class "BybitClient" with abstract attributes "create_order",
"fetch_balance", ... and "fetch_ticker" (3 methods suppressed)  [abstract]
            self.client = BybitClient(
                          ^
infrastructure\external_services\exchange.py:65:32: error: Cannot instantiate
abstract class "AccountManager" with abstract attributes "create_order",
"fetch_balance", ... and "fetch_ticker" (3 methods suppressed)  [abstract]
            self.account_manager = AccountManager(
                                   ^
infrastructure\external_services\exchange.py:156:19: error: Name "pd" is not
defined  [name-defined]
        ) -> Optional[pd.DataFrame]:
                      ^
infrastructure\external_services\exchange.py:168:27: error: "BybitClient" has
no attribute "fetch_ohlcv"  [attr-defined]
                ohlcv = await self.client.fetch_ohlcv(symbol, timeframe, l...
                              ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\exchange.py:173:18: error: Name "pd" is not
defined  [name-defined]
                df = pd.DataFrame(
                     ^~
infrastructure\external_services\exchange.py:176:31: error: Name "pd" is not
defined  [name-defined]
                df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms...
                                  ^~
infrastructure\external_services\exchange.py:187:26: error: "AccountManager"
has no attribute "get_metrics"  [attr-defined]
                return await self.account_manager.get_metrics()
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\exchange.py:190:42: error: Incompatible types
in assignment (expression has type "str", target has type "float | None") 
[assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\exchange.py:191:13: error: Unsupported operand
types for + ("None" and "int")  [operator]
                self.metrics["error_count"] += 1
                ^
infrastructure\external_services\exchange.py:191:13: note: Left operand is of type "float | None"
infrastructure\external_services\exchange.py:209:38: error: "AccountManager"
has no attribute "get_available_margin"  [attr-defined]
                available_margin = await self.account_manager.get_availabl...
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\external_services\exchange.py:226:13: error: Unsupported operand
types for + ("None" and "int")  [operator]
                self.metrics["total_trades"] += 1
                ^
infrastructure\external_services\exchange.py:226:13: note: Left operand is of type "float | None"
infrastructure\external_services\exchange.py:233:42: error: Incompatible types
in assignment (expression has type "str", target has type "float | None") 
[assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\exchange.py:234:13: error: Unsupported operand
types for + ("None" and "int")  [operator]
                self.metrics["error_count"] += 1
                ^
infrastructure\external_services\exchange.py:234:13: note: Left operand is of type "float | None"
infrastructure\external_services\exchange.py:235:13: error: Unsupported operand
types for + ("None" and "int")  [operator]
                self.metrics["failed_trades"] += 1
                ^
infrastructure\external_services\exchange.py:235:13: note: Left operand is of type "float | None"
infrastructure\external_services\exchange.py:246:42: error: Incompatible types
in assignment (expression has type "str", target has type "float | None") 
[assignment]
                self.metrics["last_error"] = str(e)
                                             ^~~~~~
infrastructure\external_services\exchange.py:247:13: error: Unsupported operand
types for + ("None" and "int")  [operator]
                self.metrics["error_count"] += 1
                ^
infrastructure\external_services\exchange.py:247:13: note: Left operand is of type "float | None"
infrastructure\external_services\exchange.py:343:10: error: Name "pd" is not
defined  [name-defined]
        ) -> pd.DataFrame:
             ^
infrastructure\external_services\exchange.py:358:24: error: Name "pd" is not
defined  [name-defined]
                    return pd.DataFrame()
                           ^~
infrastructure\external_services\exchange.py:360:21: error: "BybitClient" has
no attribute "fetch_ohlcv"  [attr-defined]
                ohlcv = self.client.fetch_ohlcv(
                        ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\exchange.py:368:24: error: Name "pd" is not
defined  [name-defined]
                    return pd.DataFrame()
                           ^~
infrastructure\external_services\exchange.py:370:18: error: Name "pd" is not
defined  [name-defined]
                df = pd.DataFrame(
                     ^~
infrastructure\external_services\exchange.py:373:31: error: Name "pd" is not
defined  [name-defined]
                df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms...
                                  ^~
infrastructure\external_services\exchange.py:382:20: error: Name "pd" is not
defined  [name-defined]
                return pd.DataFrame()
                       ^~
infrastructure\external_services\exchange.py:420:54: error: Argument 1 to
"create_order" of "ExchangeProtocol" has incompatible type
"**dict[str, object]"; expected "Order"  [arg-type]
                order = await self.client.create_order(**order_params)
                                                         ^~~~~~~~~~~~
infrastructure\external_services\exchange.py:457:53: error: Name "pd" is not
defined  [name-defined]
        def update_market_data(self, symbol: str, data: pd.DataFrame):
                                                        ^
infrastructure\external_services\exchange.py:491:26: error: "BybitClient" has
no attribute "get_account"; maybe "get_account_info"?  [attr-defined]
                return await self.client.get_account()
                             ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\external_services\ml\model_manager.py:62:20: error: "LockType"
has no attribute "__aenter__"; maybe "__enter__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml\model_manager.py:62:20: error: "LockType"
has no attribute "__aexit__"; maybe "__exit__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml\model_manager.py:76:20: error: "LockType"
has no attribute "__aenter__"; maybe "__enter__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml\model_manager.py:76:20: error: "LockType"
has no attribute "__aexit__"; maybe "__exit__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml\model_manager.py:88:20: error: "LockType"
has no attribute "__aenter__"; maybe "__enter__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml\model_manager.py:88:20: error: "LockType"
has no attribute "__aexit__"; maybe "__exit__"?  [attr-defined]
            async with self.lock:
                       ^~~~~~~~~
infrastructure\external_services\ml\model_manager.py:184:24: error: "LockType"
has no attribute "__aenter__"; maybe "__enter__"?  [attr-defined]
                async with self.lock:
                           ^~~~~~~~~
infrastructure\external_services\ml\model_manager.py:184:24: error: "LockType"
has no attribute "__aexit__"; maybe "__exit__"?  [attr-defined]
                async with self.lock:
                           ^~~~~~~~~
infrastructure\external_services\exchanges\factory.py:33:27: error: Argument
"exchange_name" to "ExchangeServiceConfig" has incompatible type "str"; expected
"ExchangeName"  [arg-type]
                exchange_name=exchange_type.value,
                              ^~~~~~~~~~~~~~~~~~~
infrastructure\external_services\exchanges\factory.py:54:21: error: Argument
"api_key" to "ExchangeCredentials" has incompatible type "str"; expected
"APIKey"  [arg-type]
                api_key=api_key, api_secret=api_secret, testnet=testnet
                        ^~~~~~~
infrastructure\external_services\exchanges\factory.py:54:41: error: Argument
"api_secret" to "ExchangeCredentials" has incompatible type "str"; expected
"APISecret"  [arg-type]
                api_key=api_key, api_secret=api_secret, testnet=testnet
                                            ^~~~~~~~~~
infrastructure\external_services\exchanges\factory.py:61:27: error: Argument
"exchange_name" to "ExchangeServiceConfig" has incompatible type "str"; expected
"ExchangeName"  [arg-type]
                exchange_name="bybit",
                              ^~~~~~~
infrastructure\external_services\exchanges\factory.py:77:21: error: Argument
"api_key" to "ExchangeCredentials" has incompatible type "str"; expected
"APIKey"  [arg-type]
                api_key=api_key, api_secret=api_secret, testnet=testnet
                        ^~~~~~~
infrastructure\external_services\exchanges\factory.py:77:41: error: Argument
"api_secret" to "ExchangeCredentials" has incompatible type "str"; expected
"APISecret"  [arg-type]
                api_key=api_key, api_secret=api_secret, testnet=testnet
                                            ^~~~~~~~~~
infrastructure\external_services\exchanges\factory.py:84:27: error: Argument
"exchange_name" to "ExchangeServiceConfig" has incompatible type "str"; expected
"ExchangeName"  [arg-type]
                exchange_name="binance",
                              ^~~~~~~~~
infrastructure\evolution\backup.py:50:13: error: Attribute "storage" already
defined on line 47  [no-redef]
                self.storage: Optional[StrategyStorage] = None  # ƒл€ тест...
                ^~~~~~~~~~~~
infrastructure\evolution\backup.py:53:13: error: Attribute "storage" already
defined on line 47  [no-redef]
                self.storage: Optional[StrategyStorage] = None  # ƒл€ тест...
                ^~~~~~~~~~~~
infrastructure\evolution\backup.py:56:13: error: Attribute "storage" already
defined on line 47  [no-redef]
                self.storage: Optional[StrategyStorage] = None
                ^~~~~~~~~~~~
infrastructure\evolution\backup.py:360:25: error: Name "model" already defined
on line 355  [no-redef]
                            model: Any = evaluation_to_model(evaluation_ob...
                            ^~~~~
infrastructure\evolution\backup.py:365:25: error: Name "model" already defined
on line 355  [no-redef]
                            model: Any = context_to_model(context_obj)
                            ^~~~~
tests\test_utils.py:7:1: error: Module "shared.visualization" has no attribute
"plot_trades"  [attr-defined]
    from shared.visualization import (plot_equity_curve, plot_indicators,
    ^
tests\infrastructure\evolution\test_backup.py:59:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Collection[str]]]"; expected "str | Path | None" 
[arg-type]
            backup_path = backup.create_backup(data)
                                               ^~~~
tests\infrastructure\evolution\test_backup.py:60:16: error: "BackupMetadata"
has no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:61:16: error: "BackupMetadata"
has no attribute "suffix"  [attr-defined]
            assert backup_path.suffix == ".json"
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:63:14: error: No overload variant
of "open" matches argument types "BackupMetadata", "str", "str"  [call-overload]
            with open(backup_path, "r", encoding="utf-8") as f:
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:63:14: note: Possible overload variants:
tests\infrastructure\evolution\test_backup.py:63:14: note:     def open(file: int | str | bytes | PathLike[str] | PathLike[bytes], mode: Literal['r+', '+r', 'rt+', 'r+t', '+rt', 'tr+', 't+r', '+tr', 'w+', '+w', 'wt+', 'w+t', '+wt', 'tw+', 't+w', '+tw', 'a+', '+a', 'at+', 'a+t', '+at', 'ta+', 't+a', '+ta', 'x+', '+x', 'xt+', 'x+t', '+xt', 'tx+', 't+x', '+tx'] | Literal['w', 'wt', 'tw', 'a', 'at', 'ta', 'x', 'xt', 'tx'] | Literal['r', 'rt', 'tr', 'U', 'rU', 'Ur', 'rtU', 'rUt', 'Urt', 'trU', 'tUr', 'Utr'] = ..., buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ..., closefd: bool = ..., opener: Any | None = ...) -> TextIOWrapper[_WrappedBuffer]
tests\infrastructure\evolution\test_backup.py:63:14: note:     def open(file: int | str | bytes | PathLike[str] | PathLike[bytes], mode: Literal['rb+', 'r+b', '+rb', 'br+', 'b+r', '+br', 'wb+', 'w+b', '+wb', 'bw+', 'b+w', '+bw', 'ab+', 'a+b', '+ab', 'ba+', 'b+a', '+ba', 'xb+', 'x+b', '+xb', 'bx+', 'b+x', '+bx'] | Literal['rb', 'br', 'rbU', 'rUb', 'Urb', 'brU', 'bUr', 'Ubr'] | Literal['wb', 'bw', 'ab', 'ba', 'xb', 'bx'], buffering: Literal[0], encoding: None = ..., errors: None = ..., newline: None = ..., closefd: bool = ..., opener: Any | None = ...) -> FileIO
tests\infrastructure\evolution\test_backup.py:63:14: note:     def open(file: int | str | bytes | PathLike[str] | PathLike[bytes], mode: Literal['rb+', 'r+b', '+rb', 'br+', 'b+r', '+br', 'wb+', 'w+b', '+wb', 'bw+', 'b+w', '+bw', 'ab+', 'a+b', '+ab', 'ba+', 'b+a', '+ba', 'xb+', 'x+b', '+xb', 'bx+', 'b+x', '+bx'], buffering: Literal[-1, 1] = ..., encoding: None = ..., errors: None = ..., newline: None = ..., closefd: bool = ..., opener: Any | None = ...) -> BufferedRandom
tests\infrastructure\evolution\test_backup.py:63:14: note:     def open(file: int | str | bytes | PathLike[str] | PathLike[bytes], mode: Literal['wb', 'bw', 'ab', 'ba', 'xb', 'bx'], buffering: Literal[-1, 1] = ..., encoding: None = ..., errors: None = ..., newline: None = ..., closefd: bool = ..., opener: Any | None = ...) -> BufferedWriter
tests\infrastructure\evolution\test_backup.py:63:14: note:     def open(file: int | str | bytes | PathLike[str] | PathLike[bytes], mode: Literal['rb', 'br', 'rbU', 'rUb', 'Urb', 'brU', 'bUr', 'Ubr'], buffering: Literal[-1, 1] = ..., encoding: None = ..., errors: None = ..., newline: None = ..., closefd: bool = ..., opener: Any | None = ...) -> BufferedReader
tests\infrastructure\evolution\test_backup.py:63:14: note:     def open(file: int | str | bytes | PathLike[str] | PathLike[bytes], mode: Literal['rb+', 'r+b', '+rb', 'br+', 'b+r', '+br', 'wb+', 'w+b', '+wb', 'bw+', 'b+w', '+bw', 'ab+', 'a+b', '+ab', 'ba+', 'b+a', '+ba', 'xb+', 'x+b', '+xb', 'bx+', 'b+x', '+bx'] | Literal['rb', 'br', 'rbU', 'rUb', 'Urb', 'brU', 'bUr', 'Ubr'] | Literal['wb', 'bw', 'ab', 'ba', 'xb', 'bx'], buffering: int = ..., encoding: None = ..., errors: None = ..., newline: None = ..., closefd: bool = ..., opener: Any | None = ...) -> BinaryIO
tests\infrastructure\evolution\test_backup.py:63:14: note:     def open(file: int | str | bytes | PathLike[str] | PathLike[bytes], mode: str, buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ..., closefd: bool = ..., opener: Any | None = ...) -> IO[Any]
tests\infrastructure\evolution\test_backup.py:80:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, str]";
expected "str | Path | None"  [arg-type]
            backup_path = backup.create_backup(data)
                                               ^~~~
tests\infrastructure\evolution\test_backup.py:81:16: error: "BackupMetadata"
has no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:82:16: error: "BackupMetadata"
has no attribute "suffix"  [attr-defined]
            assert backup_path.suffix == ".json.gz"
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:92:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, str]";
expected "str | Path | None"  [arg-type]
            backup_path = backup.create_backup(data)
                                               ^~~~
tests\infrastructure\evolution\test_backup.py:93:16: error: "BackupMetadata"
has no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:94:16: error: "BackupMetadata"
has no attribute "suffix"  [attr-defined]
            assert backup_path.suffix == ".json.enc"
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:110:34: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, str]";
expected "str | Path | None"  [arg-type]
                backup.create_backup({"test": "data"})
                                     ^~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:127:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Collection[str]]]"; expected "str | Path | None" 
[arg-type]
            backup_path = backup.create_backup(data)
                                               ^~~~
tests\infrastructure\evolution\test_backup.py:129:47: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "BackupMetadata";
expected "str"  [arg-type]
            restored_data = backup.restore_backup(backup_path)
                                                  ^~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:131:16: error: Unsupported right
operand type for in ("bool")  [operator]
            assert "candidates" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:132:16: error: Unsupported right
operand type for in ("bool")  [operator]
            assert "evaluations" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:133:16: error: Unsupported right
operand type for in ("bool")  [operator]
            assert "contexts" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:134:16: error: Unsupported right
operand type for in ("bool")  [operator]
            assert "metadata" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:136:20: error: Value of type
"bool" is not indexable  [index]
            assert len(restored_data["candidates"]) == 1
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:137:16: error: Value of type
"bool" is not indexable  [index]
            assert restored_data["candidates"][0]["id"] == str(sample_cand...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:138:16: error: Value of type
"bool" is not indexable  [index]
            assert restored_data["candidates"][0]["name"] == sample_candid...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:148:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, str]";
expected "str | Path | None"  [arg-type]
            backup_path = backup.create_backup(data)
                                               ^~~~
tests\infrastructure\evolution\test_backup.py:150:47: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "BackupMetadata";
expected "str"  [arg-type]
            restored_data = backup.restore_backup(backup_path)
                                                  ^~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:162:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, str]";
expected "str | Path | None"  [arg-type]
            backup_path = backup.create_backup(data)
                                               ^~~~
tests\infrastructure\evolution\test_backup.py:164:47: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "BackupMetadata";
expected "str"  [arg-type]
            restored_data = backup.restore_backup(backup_path)
                                                  ^~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:171:35: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "Path"; expected
"str"  [arg-type]
                backup.restore_backup(non_existent_path)
                                      ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:181:35: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "Path"; expected
"str"  [arg-type]
                backup.restore_backup(invalid_backup_path)
                                      ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:189:34: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, str]";
expected "str | Path | None"  [arg-type]
                backup.create_backup(data)
                                     ^~~~
tests\infrastructure\evolution\test_backup.py:192:20: error: "BackupMetadata"
has no attribute "suffix"  [attr-defined]
            assert all(backup_path.suffix == ".json" for backup_path in ba...
                       ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:212:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Collection[str]]]"; expected "str | Path | None" 
[arg-type]
            backup_path = backup.create_backup(data)
                                               ^~~~
tests\infrastructure\evolution\test_backup.py:214:16: error: "EvolutionBackup"
has no attribute "get_backup_info"  [attr-defined]
            info = backup.get_backup_info(backup_path)
                   ^~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:229:13: error: "EvolutionBackup"
has no attribute "get_backup_info"  [attr-defined]
                backup.get_backup_info(non_existent_path)
                ^~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:236:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, str]";
expected "str | Path | None"  [arg-type]
            backup_path = backup.create_backup(data)
                                               ^~~~
tests\infrastructure\evolution\test_backup.py:237:16: error: "BackupMetadata"
has no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:239:30: error: Argument 1 to
"delete_backup" of "EvolutionBackup" has incompatible type "BackupMetadata";
expected "str"  [arg-type]
            backup.delete_backup(backup_path)
                                 ^~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:240:20: error: "BackupMetadata"
has no attribute "exists"  [attr-defined]
            assert not backup_path.exists()
                       ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:246:34: error: Argument 1 to
"delete_backup" of "EvolutionBackup" has incompatible type "Path"; expected
"str"  [arg-type]
                backup.delete_backup(non_existent_path)
                                     ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:258:34: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, str]";
expected "str | Path | None"  [arg-type]
                backup.create_backup(data)
                                     ^~~~
tests\infrastructure\evolution\test_backup.py:263:25: error: "EvolutionBackup"
has no attribute "cleanup_old_backups"; maybe "_cleanup_old_backups"? 
[attr-defined]
            deleted_count = backup.cleanup_old_backups()
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:283:9: error: "EvolutionBackup"
has no attribute "_validate_backup_data"; maybe "_load_backup_data"? 
[attr-defined]
            backup._validate_backup_data(valid_data)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:291:13: error: "EvolutionBackup"
has no attribute "_validate_backup_data"; maybe "_load_backup_data"? 
[attr-defined]
                backup._validate_backup_data(invalid_data)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:297:27: error: "EvolutionBackup"
has no attribute "_compress_data"  [attr-defined]
            compressed_data = backup._compress_data(data)
                              ^~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:304:27: error: "EvolutionBackup"
has no attribute "_compress_data"  [attr-defined]
            compressed_data = backup._compress_data(original_data)
                              ^~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:305:29: error: "EvolutionBackup"
has no attribute "_decompress_data"  [attr-defined]
            decompressed_data = backup._decompress_data(compressed_data)
                                ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:316:26: error: "EvolutionBackup"
has no attribute "_encrypt_data"  [attr-defined]
            encrypted_data = backup._encrypt_data(data)
                             ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:328:26: error: "EvolutionBackup"
has no attribute "_encrypt_data"  [attr-defined]
            encrypted_data = backup._encrypt_data(original_data)
                             ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:329:26: error: "EvolutionBackup"
has no attribute "_decrypt_data"  [attr-defined]
            decrypted_data = backup._decrypt_data(encrypted_data)
                             ^~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_backup.py:341:34: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, str]";
expected "str | Path | None"  [arg-type]
                backup.create_backup(data)
                                     ^~~~
tests\infrastructure\evolution\test_backup.py:346:25: error: "BackupMetadata"
has no attribute "stat"  [attr-defined]
            backup_times = [backup_path.stat().st_mtime for backup_path in...
                            ^~~~~~~~~~~~~~~~
infrastructure\ml_services\decision_reasoner.py:17:1: error: Module
"infrastructure.ml_services.candle_patterns" has no attribute "CandlePatterns" 
[attr-defined]
    from .candle_patterns import CandlePatterns
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\decision_reasoner.py:77:29: error:
"MarketRegimeDetector" has no attribute "detect_regime"  [attr-defined]
                market_regime = self.market_regime_detector.detect_regime(...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\decision_reasoner.py:344:35: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                        window_data = new_data.iloc[i-50:i+1]
                                      ^~~~~~~~~~~~~
infrastructure\ml_services\decision_reasoner.py:351:73: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
    ...es = list(TechnicalIndicators.get_all_indicators(new_data.iloc[:50]).k...
                                                        ^~~~~~~~~~~~~
infrastructure\ml_services\decision_reasoner.py:353:17: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                y = new_labels.iloc[50:len(features)+50]  # —оответствие и...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\evolution\migration.py:151:26: error: No overload variant of
"exec" of "Session" matches argument type "TextClause"  [call-overload]
                    result = session.exec(
                             ^
infrastructure\evolution\migration.py:151:26: note: Possible overload variants:
infrastructure\evolution\migration.py:151:26: note:     def [_TSelectParam: Any] exec(self, statement: Select[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> TupleResult[_TSelectParam]
infrastructure\evolution\migration.py:151:26: note:     def [_TSelectParam: Any] exec(self, statement: SelectOfScalar[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> ScalarResult[_TSelectParam]
infrastructure\evolution\migration.py:159:20: error: Incompatible return value
type (got "list[dict[Any, Any]]", expected "list[MigrationMetadata]") 
[return-value]
                return migrations
                       ^~~~~~~~~~
infrastructure\evolution\migration.py:189:17: error: No overload variant of
"exec" of "Session" matches argument type "TextClause"  [call-overload]
                    session.exec(
                    ^
infrastructure\evolution\migration.py:189:17: note: Possible overload variants:
infrastructure\evolution\migration.py:189:17: note:     def [_TSelectParam: Any] exec(self, statement: Select[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> TupleResult[_TSelectParam]
infrastructure\evolution\migration.py:189:17: note:     def [_TSelectParam: Any] exec(self, statement: SelectOfScalar[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> ScalarResult[_TSelectParam]
infrastructure\evolution\migration.py:239:21: error: No overload variant of
"exec" of "Session" matches argument type "TextClause"  [call-overload]
                        session.exec(text(script))
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\evolution\migration.py:239:21: note: Possible overload variants:
infrastructure\evolution\migration.py:239:21: note:     def [_TSelectParam: Any] exec(self, statement: Select[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> TupleResult[_TSelectParam]
infrastructure\evolution\migration.py:239:21: note:     def [_TSelectParam: Any] exec(self, statement: SelectOfScalar[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> ScalarResult[_TSelectParam]
infrastructure\evolution\migration.py:253:21: error: No overload variant of
"exec" of "Session" matches argument type "TextClause"  [call-overload]
                        session.exec(text(script))
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\evolution\migration.py:253:21: note: Possible overload variants:
infrastructure\evolution\migration.py:253:21: note:     def [_TSelectParam: Any] exec(self, statement: Select[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> TupleResult[_TSelectParam]
infrastructure\evolution\migration.py:253:21: note:     def [_TSelectParam: Any] exec(self, statement: SelectOfScalar[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> ScalarResult[_TSelectParam]
infrastructure\evolution\migration.py:312:17: error: No overload variant of
"exec" of "Session" matches argument types "TextClause", "dict[str, object]" 
[call-overload]
                    session.exec(
                    ^
infrastructure\evolution\migration.py:312:17: note: Possible overload variants:
infrastructure\evolution\migration.py:312:17: note:     def [_TSelectParam: Any] exec(self, statement: Select[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> TupleResult[_TSelectParam]
infrastructure\evolution\migration.py:312:17: note:     def [_TSelectParam: Any] exec(self, statement: SelectOfScalar[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> ScalarResult[_TSelectParam]
infrastructure\evolution\migration.py:344:26: error: No overload variant of
"exec" of "Session" matches argument types "TextClause", "dict[str, str]" 
[call-overload]
                    result = session.exec(
                             ^
infrastructure\evolution\migration.py:344:26: note: Possible overload variants:
infrastructure\evolution\migration.py:344:26: note:     def [_TSelectParam: Any] exec(self, statement: Select[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> TupleResult[_TSelectParam]
infrastructure\evolution\migration.py:344:26: note:     def [_TSelectParam: Any] exec(self, statement: SelectOfScalar[_TSelectParam], *, params: Mapping[str, Any] | Sequence[Mapping[str, Any]] | None = ..., execution_options: Mapping[str, Any] = ..., bind_arguments: dict[str, Any] | None = ..., _parent_execute_state: Any | None = ..., _add_event: Any | None = ...) -> ScalarResult[_TSelectParam]
infrastructure\evolution\migration.py:351:28: error: Incompatible return value
type (got "dict[Any, Any]", expected "MigrationMetadata | None")  [return-value]
                        return dict(result)
                               ^~~~~~~~~~~~
infrastructure\data\price_pattern_extractor.py:22:5: error: Name "DBSCAN"
already defined (possibly by an import)  [no-redef]
        class DBSCAN:
        ^
infrastructure\data\price_pattern_extractor.py:155:19: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                row = data.iloc[index]
                      ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:197:27: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                window_data = data.iloc[window_start:window_end]
                              ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:201:31: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                    pivot_price = data.iloc[index]['high']
                                  ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:208:31: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                    pivot_price = data.iloc[index]['low']
                                  ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:216:34: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                    current_volume = data.iloc[index]['volume']
                                     ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:248:27: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                window_data = data.iloc[window_start:window_end]
                              ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:275:31: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                historical_data = data.iloc[start_idx:index]
                                  ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:310:27: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                window_data = data.iloc[window_start:window_end]
                              ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:313:30: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                current_volume = data.iloc[index]['volume']
                                 ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:334:26: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                local_data = data.iloc[index - lookback:index + forward]
                             ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:439:44: error: Unsupported
operand types for * ("float" and "Decimal")  [operator]
                    weighted_average = sum(w * v for w, v in zip(weights, ...
                                               ^
infrastructure\data\price_pattern_extractor.py:442:24: error: Incompatible
return value type (got "Decimal | float", expected "float")  [return-value]
                    return sum(values) / len(values)
                           ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\data\price_pattern_extractor.py:563:13: error: Need type
annotation for "clusters" (hint: "clusters: list[<type>] = ...") 
[var-annotated]
                clusters = []
                ^~~~~~~~
infrastructure\data\price_pattern_extractor.py:607:21: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                local = data.iloc[idx - window:idx + window + 1]
                        ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:609:25: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                    pivot = data.iloc[idx]['high']
                            ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:613:25: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                    pivot = data.iloc[idx]['low']
                            ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:617:22: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                volume = data.iloc[idx]['volume']
                         ^~~~~~~~~
infrastructure\data\price_pattern_extractor.py:627:21: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                local = data.iloc[max(0, idx - window):min(len(data), idx ...
                        ^~~~~~~~~
infrastructure\core\market_state.py:190:16: error: Incompatible return value
type (got "list[floating[Any]]", expected "list[float]")  [return-value]
            return clusters
                   ^~~~~~~~
domain\sessions\__init__.py:42:5: error: Cannot assign to a type  [misc]
        Series = Any
        ^~~~~~
domain\sessions\__init__.py:42:14: error: Incompatible types in assignment
(expression has type "type[Any]", variable has type "type[Series]") 
[assignment]
        Series = Any
                 ^~~
domain\sessions\__init__.py:43:5: error: Cannot assign to a type  [misc]
        DataFrame = Any
        ^~~~~~~~~
domain\sessions\__init__.py:43:17: error: Incompatible types in assignment
(expression has type "type[Any]", variable has type "type[DataFrame]") 
[assignment]
        DataFrame = Any
                    ^~~
domain\sessions\__init__.py:44:5: error: Cannot assign to a type  [misc]
        PandasSeries = Any
        ^~~~~~~~~~~~
domain\sessions\__init__.py:44:20: error: Incompatible types in assignment
(expression has type "type[Any]", variable has type "type[Series[float]]") 
[assignment]
        PandasSeries = Any
                       ^~~
domain\sessions\__init__.py:45:5: error: Cannot assign to a type  [misc]
        PandasDataFrame = Any
        ^~~~~~~~~~~~~~~
domain\sessions\__init__.py:45:23: error: Incompatible types in assignment
(expression has type "type[Any]", variable has type "type[DataFrame]") 
[assignment]
        PandasDataFrame = Any
                          ^~~
domain\services\pattern_service.py:266:40: error: Incompatible types in
assignment (expression has type "float", target has type "dict[str, float]") 
[assignment]
                characteristics["error"] = float(0.0)  # »спользуем float ...
                                           ^~~~~~~~~~
domain\services\pattern_service.py:267:16: error: Incompatible return value
type (got "dict[str, dict[str, float]]", expected
"dict[str, float | dict[str, float]]")  [return-value]
            return characteristics
                   ^~~~~~~~~~~~~~~
domain\services\pattern_service.py:267:16: note: "dict" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
domain\services\pattern_service.py:267:16: note: Consider using "Mapping" instead, which is covariant in the value type
domain\services\pattern_service.py:267:16: note: Perhaps you need a type annotation for "characteristics"? Suggestion: "dict[str, float | dict[str, float]]"
domain\services\pattern_discovery.py:118:24: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            pattern_data = data.iloc[pattern.start_idx : pattern.end_idx +...
                           ^~~~~~~~~
domain\services\pattern_discovery.py:126:23: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            future_data = data.iloc[
                          ^~~~~~~~~
domain\services\pattern_discovery.py:187:18: error: "Series" has no attribute
"rolling"  [attr-defined]
            middle = prices.rolling(window=period).mean()
                     ^~~~~~~~~~~~~~
domain\services\pattern_discovery.py:188:15: error: "Series" has no attribute
"rolling"  [attr-defined]
            std = prices.rolling(window=period).std()
                  ^~~~~~~~~~~~~~
domain\services\pattern_discovery.py:358:24: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
            pattern_data = data.iloc[pattern.start_idx : pattern.end_idx]
                           ^~~~~~~~~
tests\infrastructure\evolution\test_migration.py:14:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:15:16: error:
"EvolutionMigration" has no attribute "migrations_dir"; maybe "migration_dir"? 
[attr-defined]
            assert migration.migrations_dir == temp_migration_dir
                   ^~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:16:16: error:
"EvolutionMigration" has no attribute "auto_migrate"  [attr-defined]
            assert migration.auto_migrate is True
                   ^~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:17:16: error:
"EvolutionMigration" has no attribute "backup_before_migrate"; maybe
"_create_backup_before_migration"?  [attr-defined]
            assert migration.backup_before_migrate is True
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:18:16: error:
"EvolutionMigration" has no attribute "rollback_supported"  [attr-defined]
            assert migration.rollback_supported is True
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:27:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "dict[str, object]"; expected
"StrategyStorage"  [arg-type]
            migration = EvolutionMigration(config)
                                           ^~~~~~
tests\infrastructure\evolution\test_migration.py:28:16: error:
"EvolutionMigration" has no attribute "migrations_dir"; maybe "migration_dir"? 
[attr-defined]
            assert migration.migrations_dir == temp_migration_dir
                   ^~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:29:16: error:
"EvolutionMigration" has no attribute "auto_migrate"  [attr-defined]
            assert migration.auto_migrate is False
                   ^~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:30:16: error:
"EvolutionMigration" has no attribute "backup_before_migrate"; maybe
"_create_backup_before_migration"?  [attr-defined]
            assert migration.backup_before_migrate is False
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:31:16: error:
"EvolutionMigration" has no attribute "rollback_supported"  [attr-defined]
            assert migration.rollback_supported is False
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:43:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:57:26: error:
"EvolutionMigration" has no attribute "create_migration"; maybe
"_create_migrations_table" or "_execute_migration"?  [attr-defined]
            migration_path = migration.create_migration(migration_data)
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:71:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:79:13: error:
"EvolutionMigration" has no attribute "create_migration"; maybe
"_create_migrations_table" or "_execute_migration"?  [attr-defined]
                migration.create_migration(invalid_data)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:86:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:93:13: error:
"EvolutionMigration" has no attribute "create_migration"; maybe
"_create_migrations_table" or "_execute_migration"?  [attr-defined]
                migration.create_migration(migration_data)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:97:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:103:23: error:
"EvolutionMigration" has no attribute "load_migration"; maybe "apply_migration"
or "list_migrations"?  [attr-defined]
            loaded_data = migration.load_migration(migration_path)
                          ^~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:109:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:112:13: error:
"EvolutionMigration" has no attribute "load_migration"; maybe "apply_migration"
or "list_migrations"?  [attr-defined]
                migration.load_migration(non_existent_path)
                ^~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:116:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:122:13: error:
"EvolutionMigration" has no attribute "load_migration"; maybe "apply_migration"
or "list_migrations"?  [attr-defined]
                migration.load_migration(invalid_path)
                ^~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:126:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:139:20: error:
"MigrationMetadata" has no attribute "suffix"  [attr-defined]
            assert all(migration_path.suffix == ".json" for migration_path...
                       ^~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:141:21: error:
"MigrationMetadata" has no attribute "stem"  [attr-defined]
            versions = [migration_path.stem for migration_path in migratio...
                        ^~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:145:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:150:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:156:16: error:
"EvolutionMigration" has no attribute "get_migration_info"  [attr-defined]
            info = migration.get_migration_info(migration_path)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:168:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:171:13: error:
"EvolutionMigration" has no attribute "get_migration_info"  [attr-defined]
                migration.get_migration_info(non_existent_path)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:175:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:180:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:190:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:200:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:211:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:222:9: error: Too many
arguments for "_check_dependencies" of "EvolutionMigration"  [call-arg]
            migration._check_dependencies("1.1", ["1.0"])
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:222:39: error: Argument 1 to
"_check_dependencies" of "EvolutionMigration" has incompatible type "str";
expected "list[str]"  [arg-type]
            migration._check_dependencies("1.1", ["1.0"])
                                          ^~~~~
tests\infrastructure\evolution\test_migration.py:225:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:237:13: error: Too many
arguments for "_check_dependencies" of "EvolutionMigration"  [call-arg]
                migration._check_dependencies("1.1", ["1.0"])
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:237:43: error: Argument 1 to
"_check_dependencies" of "EvolutionMigration" has incompatible type "str";
expected "list[str]"  [arg-type]
                migration._check_dependencies("1.1", ["1.0"])
                                              ^~~~~
tests\infrastructure\evolution\test_migration.py:241:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:252:13: error: Too many
arguments for "_check_dependencies" of "EvolutionMigration"  [call-arg]
                migration._check_dependencies("1.0", ["1.1"])
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:252:43: error: Argument 1 to
"_check_dependencies" of "EvolutionMigration" has incompatible type "str";
expected "list[str]"  [arg-type]
                migration._check_dependencies("1.0", ["1.1"])
                                              ^~~~~
tests\infrastructure\evolution\test_migration.py:256:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:268:29: error:
"EvolutionMigration" has no attribute "_sort_migrations_by_dependencies" 
[attr-defined]
            sorted_migrations = migration._sort_migrations_by_dependencies...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:274:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:280:18: error:
"EvolutionMigration" has no attribute "execute_migration"; maybe
"_execute_migration"?  [attr-defined]
            result = migration.execute_migration(migration_path)
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:287:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:301:13: error:
"EvolutionMigration" has no attribute "execute_migration"; maybe
"_execute_migration"?  [attr-defined]
                migration.execute_migration(migration_path)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:305:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:311:47: error: Argument 1 to
"rollback_migration" of "EvolutionMigration" has incompatible type "Path";
expected "str"  [arg-type]
            result = migration.rollback_migration(migration_path)
                                                  ^~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:312:16: error: Value of type
"bool" is not indexable  [index]
            assert result["success"] is True
                   ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:313:16: error: Value of type
"bool" is not indexable  [index]
            assert result["version"] == "1.0"
                   ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:314:16: error: Value of type
"bool" is not indexable  [index]
            assert result["executed_scripts"] == 1
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:315:16: error: Value of type
"bool" is not indexable  [index]
            assert result["execution_time"] > 0
                   ^~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:318:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:332:42: error: Argument 1 to
"rollback_migration" of "EvolutionMigration" has incompatible type "Path";
expected "str"  [arg-type]
                migration.rollback_migration(migration_path)
                                             ^~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:336:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:347:18: error:
"EvolutionMigration" has no attribute "get_migration_status"  [attr-defined]
            status = migration.get_migration_status()
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:355:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:361:9: error:
"EvolutionMigration" has no attribute "_validate_migration_file"; maybe
"_validate_migration"?  [attr-defined]
            migration._validate_migration_file(migration_path)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_migration.py:367:13: error:
"EvolutionMigration" has no attribute "_validate_migration_file"; maybe
"_validate_migration"?  [attr-defined]
                migration._validate_migration_file(invalid_path)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:83:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Collection[str]]]"; expected "str | Path | None" 
[arg-type]
            backup_path = backup.create_backup(backup_data)
                                               ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:85:16: error:
"BackupMetadata" has no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:87:47: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "BackupMetadata";
expected "str"  [arg-type]
            restored_data = backup.restore_backup(backup_path)
                                                  ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:89:16: error: Unsupported
right operand type for in ("bool")  [operator]
            assert "candidates" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:90:16: error: Unsupported
right operand type for in ("bool")  [operator]
            assert "evaluations" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:91:16: error: Unsupported
right operand type for in ("bool")  [operator]
            assert "contexts" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:92:20: error: Value of type
"bool" is not indexable  [index]
            assert len(restored_data["candidates"]) == 1
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:93:20: error: Value of type
"bool" is not indexable  [index]
            assert len(restored_data["evaluations"]) == 1
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:94:20: error: Value of type
"bool" is not indexable  [index]
            assert len(restored_data["contexts"]) == 1
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:123:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Collection[str]]]"; expected "str | Path | None" 
[arg-type]
            backup_path = backup.create_backup(cache_backup_data)
                                               ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:125:16: error:
"BackupMetadata" has no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:127:53: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "BackupMetadata";
expected "str"  [arg-type]
            restored_cache_data = backup.restore_backup(backup_path)
                                                        ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:129:16: error: Unsupported
right operand type for in ("bool")  [operator]
            assert "cache_stats" in restored_cache_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:130:16: error: Unsupported
right operand type for in ("bool")  [operator]
            assert "cached_candidates" in restored_cache_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:131:16: error: Unsupported
right operand type for in ("bool")  [operator]
            assert "cached_evaluations" in restored_cache_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:132:16: error: Unsupported
right operand type for in ("bool")  [operator]
            assert "cached_contexts" in restored_cache_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:137:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:164:26: error:
"EvolutionMigration" has no attribute "create_migration"; maybe
"_create_migrations_table" or "_execute_migration"?  [attr-defined]
            migration_path = migration.create_migration(migration_data)
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:168:18: error:
"EvolutionMigration" has no attribute "execute_migration"; maybe
"_execute_migration"?  [attr-defined]
            result = migration.execute_migration(migration_path)
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:185:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:199:26: error:
"EvolutionMigration" has no attribute "create_migration"; maybe
"_create_migrations_table" or "_execute_migration"?  [attr-defined]
            migration_path = migration.create_migration(migration_data)
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:200:28: error:
"EvolutionMigration" has no attribute "execute_migration"; maybe
"_execute_migration"?  [attr-defined]
            migration_result = migration.execute_migration(migration_path)
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:222:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Collection[str]]]"; expected "str | Path | None" 
[arg-type]
            backup_path = backup.create_backup(backup_data)
                                               ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:223:16: error:
"BackupMetadata" has no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:234:47: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "BackupMetadata";
expected "str"  [arg-type]
            restored_data = backup.restore_backup(backup_path)
                                                  ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:238:20: error: Value of type
"bool" is not indexable  [index]
            assert len(restored_data["candidates"]) == 1
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:267:39: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "Path"; expected
"str"  [arg-type]
                    backup.restore_backup(non_existent_backup_path)
                                          ^~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:341:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Collection[str]]]"; expected "str | Path | None" 
[arg-type]
            backup_path = backup.create_backup(backup_data)
                                               ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:348:16: error:
"BackupMetadata" has no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:424:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Collection[str]]]"; expected "str | Path | None" 
[arg-type]
            backup_path = backup.create_backup(backup_data)
                                               ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:428:47: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "BackupMetadata";
expected "str"  [arg-type]
            restored_data = backup.restore_backup(backup_path)
                                                  ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:429:16: error: Item "None"
of "StrategyCandidate | None" has no attribute "name"  [union-attr]
            assert stored.name == "Updated Strategy"
                   ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:430:16: error: Item "None"
of "Any | None" has no attribute "name"  [union-attr]
            assert cached.name == "Updated Strategy"
                   ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:431:16: error: Item "None"
of "StrategyCandidate | None" has no attribute "name"  [union-attr]
            assert stored.name == cached.name
                   ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:431:31: error: Item "None"
of "Any | None" has no attribute "name"  [union-attr]
            assert stored.name == cached.name
                                  ^~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:432:16: error: Item "None"
of "StrategyCandidate | None" has no attribute "description"  [union-attr]
            assert stored.description == "Updated description"
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:433:16: error: Item "None"
of "Any | None" has no attribute "description"  [union-attr]
            assert cached.description == "Updated description"
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:434:16: error: Item "None"
of "StrategyCandidate | None" has no attribute "description"  [union-attr]
            assert stored.description == cached.description
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:434:38: error: Item "None"
of "Any | None" has no attribute "description"  [union-attr]
            assert stored.description == cached.description
                                         ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:436:20: error: Value of type
"bool" is not indexable  [index]
            assert len(restored_data["candidates"]) == 1
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:437:16: error: Value of type
"bool" is not indexable  [index]
            assert restored_data["candidates"][0]["name"] == "Updated Stra...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_integration.py:438:16: error: Value of type
"bool" is not indexable  [index]
            assert restored_data["candidates"][0]["description"] == "Updat...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:30:40: error: Argument 1 to
"EvolutionMigration" has incompatible type "str"; expected "StrategyStorage" 
[arg-type]
            migration = EvolutionMigration(str(temp_migration_dir))
                                           ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:145:30: error: "EvolutionMigration"
has no attribute "create_migration"; maybe "_create_migrations_table" or
"_execute_migration"?  [attr-defined]
                migration_path = migration.create_migration(migration_data...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:146:22: error: "EvolutionMigration"
has no attribute "execute_migration"; maybe "_execute_migration"? 
[attr-defined]
                result = migration.execute_migration(migration_path)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:171:86: error: Name "List" is not
defined  [name-defined]
    ...n(self, context: EvolutionContext, size: int) -> List[StrategyCandidat...
                                                        ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:171:86: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\infrastructure\evolution\test_e2e.py:210:25: error: Missing keys
("direction", "operator", "value") for TypedDict "EntryCondition" 
[typeddict-item]
                            {
                            ^
tests\infrastructure\evolution\test_e2e.py:228:25: error: Missing keys
("operator", "value") for TypedDict "ExitCondition"  [typeddict-item]
                            {
                            ^
tests\infrastructure\evolution\test_e2e.py:267:48: error: Name "List" is not
defined  [name-defined]
        def _evaluate_strategies(self, candidates: List[StrategyCandidate]...
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:267:48: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\infrastructure\evolution\test_e2e.py:331:65: error: Name "List" is not
defined  [name-defined]
    ...ulate_trades(self, candidate: StrategyCandidate) -> List[TradeResult]:
                                                           ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:331:65: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\infrastructure\evolution\test_e2e.py:355:52: error: Name "List" is not
defined  [name-defined]
    ...  def _select_best_candidates(self, evaluations: List[StrategyEvaluati...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
tests\infrastructure\evolution\test_e2e.py:355:52: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\infrastructure\evolution\test_e2e.py:364:59: error: Name "List" is not
defined  [name-defined]
    ...generate_next_generation(self, best_evaluations: List[StrategyEvaluati...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
tests\infrastructure\evolution\test_e2e.py:364:59: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\infrastructure\evolution\test_e2e.py:365:74: error: Name "List" is not
defined  [name-defined]
    ...        context: EvolutionContext, size: int) -> List[StrategyCandidat...
                                                        ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:365:74: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\infrastructure\evolution\test_e2e.py:395:29: error: Missing keys
("direction", "operator", "value") for TypedDict "EntryCondition" 
[typeddict-item]
                                {
                                ^
tests\infrastructure\evolution\test_e2e.py:412:29: error: Missing keys
("operator", "value") for TypedDict "ExitCondition"  [typeddict-item]
                                {
                                ^
tests\infrastructure\evolution\test_e2e.py:441:45: error: Name "List" is not
defined  [name-defined]
                                    candidates: List[StrategyCandidate], e...
                                                ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:441:45: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\infrastructure\evolution\test_e2e.py:458:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, object]";
expected "str | Path | None"  [arg-type]
            backup_path = backup.create_backup(backup_data)
                                               ^~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:459:16: error: "BackupMetadata" has
no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:460:48: error: Name "List" is not
defined  [name-defined]
        def _find_best_strategy(self, evaluations: List[StrategyEvaluation...
                                                   ^~~~~~~~~~~~~~~~~~~~~~~...
tests\infrastructure\evolution\test_e2e.py:460:48: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\infrastructure\evolution\test_e2e.py:466:73: error: Name "List" is not
defined  [name-defined]
    ...ackup(self, backup: EvolutionBackup, candidates: List[StrategyCandidat...
                                                        ^~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:466:73: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\infrastructure\evolution\test_e2e.py:467:41: error: Name "List" is not
defined  [name-defined]
                               evaluations: List[StrategyEvaluationResult]...
                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:467:41: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\infrastructure\evolution\test_e2e.py:491:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Any]]"; expected "str | Path | None"  [arg-type]
            backup_path = backup.create_backup(backup_data)
                                               ^~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:492:16: error: "BackupMetadata" has
no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:493:16: error: Incompatible return
value type (got "BackupMetadata", expected "Path")  [return-value]
            return backup_path
                   ^~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:508:47: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "Path"; expected
"str"  [arg-type]
            restored_data = backup.restore_backup(final_backup_path)
                                                  ^~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:509:16: error: Unsupported right
operand type for in ("bool")  [operator]
            assert "candidates" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:510:16: error: Unsupported right
operand type for in ("bool")  [operator]
            assert "evaluations" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:511:16: error: Unsupported right
operand type for in ("bool")  [operator]
            assert "context" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:512:16: error: Unsupported right
operand type for in ("bool")  [operator]
            assert "best_strategy" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:513:16: error: Unsupported right
operand type for in ("bool")  [operator]
            assert "final_metrics" in restored_data
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:515:20: error: Value of type "bool"
is not indexable  [index]
            assert len(restored_data["candidates"]) == len(candidates)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:516:20: error: Value of type "bool"
is not indexable  [index]
            assert len(restored_data["evaluations"]) == len(evaluations)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:574:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Collection[str]]]"; expected "str | Path | None" 
[arg-type]
            backup_path = backup.create_backup(backup_data)
                                               ^~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:578:47: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "BackupMetadata";
expected "str"  [arg-type]
            restored_data = backup.restore_backup(backup_path)
                                                  ^~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:580:31: error: Value of type "bool"
is not indexable  [index]
            for candidate_data in restored_data["candidates"]:
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:647:44: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type
"dict[str, Collection[Collection[str]]]"; expected "str | Path | None" 
[arg-type]
            backup_path = backup.create_backup(backup_data)
                                               ^~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:653:16: error: "BackupMetadata" has
no attribute "exists"  [attr-defined]
            assert backup_path.exists()
                   ^~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:659:47: error: Argument 1 to
"restore_backup" of "EvolutionBackup" has incompatible type "BackupMetadata";
expected "str"  [arg-type]
            restored_data = backup.restore_backup(backup_path)
                                                  ^~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:662:20: error: Value of type "bool"
is not indexable  [index]
            assert len(restored_data["candidates"]) == 1000
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\evolution\test_e2e.py:663:20: error: Value of type "bool"
is not indexable  [index]
            assert len(restored_data["evaluations"]) == 1000 
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_pattern_discovery.py:378:20: error: Cannot use
isinstance() with TypedDict type  [misc]
                assert isinstance(pattern, PatternResult)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\market_profiles\storage\pattern_memory_repository.py:498:25: error:
Expected keyword arguments, {...}, or dict(...) in TypedDict constructor  [misc]
                    context=PatternContext(
                            ^
infrastructure\market_profiles\storage\pattern_memory_repository.py:526:42: error:
Argument 1 to "from_dict" of "PatternFeatures" has incompatible type
"dict[str, Any]"; expected "PatternFeaturesDict"  [arg-type]
            return PatternFeatures.from_dict(features_data)
                                             ^~~~~~~~~~~~~
infrastructure\market_profiles\storage\pattern_memory_repository.py:809:5: error:
Return type "Coroutine[Any, Any, dict[str, Any]]" of "get_storage_statistics"
incompatible with return type "Coroutine[Any, Any, StorageStatistics]" in
supertype "IPatternStorage"  [override]
        async def get_storage_statistics(self) -> Dict[str, Any]:
        ^
infrastructure\market_profiles\storage\market_maker_storage.py:275:28: error:
Argument 2 to "run_in_executor" of "AbstractEventLoop" has incompatible type
"Callable[[dict[str, Any]], bytes]"; expected
"Callable[[PatternFeaturesDict], bytes]"  [arg-type]
                self.executor, self._compress_data, pattern.features.to_di...
                               ^~~~~~~~~~~~~~~~~~~
infrastructure\market_profiles\storage\market_maker_storage.py:524:25: error:
Expected keyword arguments, {...}, or dict(...) in TypedDict constructor  [misc]
                    context=PatternContext(
                            ^
infrastructure\market_profiles\storage\market_maker_storage.py:552:42: error:
Argument 1 to "from_dict" of "PatternFeatures" has incompatible type
"dict[str, Any]"; expected "PatternFeaturesDict"  [arg-type]
            return PatternFeatures.from_dict(features_data)
                                             ^~~~~~~~~~~~~
infrastructure\market_profiles\storage\market_maker_storage.py:831:47: error:
Item "None" of "datetime | None" has no attribute "isoformat"  [union-attr]
                                    "updated_at": pattern_memory.last_seen...
                                                  ^~~~~~~~~~~~~~~~~~~~~~~~...
examples\ai_trading_example.py:44:17: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.date_range(start="2024-01-01", end="2024-12-31", fr...
                    ^~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:91:60: error: Argument 1 to
"_analyze_divergences" of "ReversalPredictor" has incompatible type "DataFrame";
expected "OHLCVData"  [arg-type]
                divergence_signals = self._analyze_divergences(df)
                                                               ^~
domain\prediction\reversal_predictor.py:153:60: error: Argument 1 to
"_detect_rsi_divergences" of "ReversalPredictor" has incompatible type
"DataFrame"; expected "OHLCVData"  [arg-type]
                rsi_divergences = self._detect_rsi_divergences(df)
                                                               ^~
domain\prediction\reversal_predictor.py:155:62: error: Argument 1 to
"_detect_macd_divergences" of "ReversalPredictor" has incompatible type
"DataFrame"; expected "OHLCVData"  [arg-type]
                macd_divergences = self._detect_macd_divergences(df)
                                                                 ^~
domain\prediction\reversal_predictor.py:177:25: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                        and rsi.iloc[rsi_highs[-1]] < rsi.iloc[rsi_highs[-...
                            ^~~~~~~~~~~~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:188:39: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                                    float(rsi.iloc[i]) for i in rsi_highs[...
                                          ^~~~~~~~~~~
domain\prediction\reversal_predictor.py:199:25: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                        and rsi.iloc[rsi_lows[-1]] > rsi.iloc[rsi_lows[-2]...
                            ^~~~~~~~~~~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:210:51: error: Value of type
"Callable[[], Any]" is not indexable  [index]
    ...                           indicator_lows=[float(rsi.iloc[i]) for i in...
                                                        ^~~~~~~~~~~
domain\prediction\reversal_predictor.py:239:25: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                        and macd.iloc[macd_highs[-1]] < macd.iloc[macd_hig...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:250:39: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                                    float(macd.iloc[i]) for i in macd_high...
                                          ^~~~~~~~~~~~
domain\prediction\reversal_predictor.py:262:25: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                        and macd.iloc[macd_lows[-1]] > macd.iloc[macd_lows...
                            ^~~~~~~~~~~~~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:274:39: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                                    float(macd.iloc[i]) for i in macd_lows...
                                          ^~~~~~~~~~~~
domain\prediction\reversal_predictor.py:291:22: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
                candle = data.iloc[i]
                         ^~~~~~~~~
domain\prediction\reversal_predictor.py:292:27: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
                prev_candle = data.iloc[i - 1]
                              ^~~~~~~~~
domain\prediction\reversal_predictor.py:413:29: error: Value of type
"Callable[[], Any]" is not indexable  [index]
            current_rsi = float(rsi.iloc[-1])
                                ^~~~~~~~~~~~
domain\prediction\reversal_predictor.py:438:22: error: Argument 1 to "Price"
has incompatible type "float"; expected "Decimal"  [arg-type]
            return Price(float(data["close"].iloc[-1]), Currency.USD)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:454:16: error: Incompatible return
value type (got "float", expected "ConfidenceScore")  [return-value]
            return min(1.0, score)
                   ^~~~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:465:13: error: Incompatible types in
assignment (expression has type "float", variable has type "ConfidenceScore") 
[assignment]
                base += 0.1 * sum(d.strength for d in divergence_signals)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:467:13: error: Incompatible types in
assignment (expression has type "float", variable has type "ConfidenceScore") 
[assignment]
                base += 0.1 * sum(p.strength for p in candlestick_patterns...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:469:13: error: Incompatible types in
assignment (expression has type "float", variable has type "ConfidenceScore") 
[assignment]
                base += 0.05 * abs(momentum_analysis.momentum_loss)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:470:16: error: Incompatible return
value type (got "float", expected "SignalStrengthScore")  [return-value]
            return min(1.0, base)
                   ^~~~~~~~~~~~~~
domain\prediction\reversal_predictor.py:476:21: error: "Series" has no
attribute "diff"  [attr-defined]
                delta = prices.diff()
                        ^~~~~~~~~~~
domain\prediction\reversal_predictor.py:491:24: error: "Series" has no
attribute "ewm"  [attr-defined]
                ema_fast = prices.ewm(span=fast).mean()
                           ^~~~~~~~~~
domain\prediction\reversal_predictor.py:492:24: error: "Series" has no
attribute "ewm"  [attr-defined]
                ema_slow = prices.ewm(span=slow).mean()
                           ^~~~~~~~~~
domain\memory\pattern_memory.py:62:20: error: Incompatible return value type
(got "float | SupportsDunderLT[Any] | SupportsDunderGT[Any]", expected "float") 
[return-value]
                return max(0.0, min(1.0, combined_sim))
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\memory\pattern_memory.py:778:32: error: Incompatible types in assignment
(expression has type "str", variable has type "PatternType | None") 
[assignment]
                    pattern_type = snapshot.pattern_type.value
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\memory\pattern_memory.py:778:32: note: Items in the first union not in the second: "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"
tests\unit\application_tests\test_prediction.py:21:16: error: Incompatible
return value type (got "tuple[Mock, Mock, Mock]", expected "Mock") 
[return-value]
            return market_repo, pattern_repo, ml_repo
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:45:24: error:
"CombinedPredictor" has no attribute "predict_price_movement"  [attr-defined]
            result = await predictor.predict_price_movement(symbol, timefr...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:63:20: error: Missing
positional arguments "pattern_prediction", "session_signals",
"aggregated_session_signal", "timestamp" in call to "_combine_predictions" of
"CombinedPredictor"  [call-arg]
            combined = predictor._combine_predictions(predictions)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:63:51: error: Argument 1 to
"_combine_predictions" of "CombinedPredictor" has incompatible type
"list[dict[str, object]]"; expected "str"  [arg-type]
            combined = predictor._combine_predictions(predictions)
                                                      ^~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:64:16: error: Unsupported right
operand type for in ("CombinedPredictionResult")  [operator]
            assert "direction" in combined
                   ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:65:16: error: Unsupported right
operand type for in ("CombinedPredictionResult")  [operator]
            assert "confidence" in combined
                   ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:66:16: error: Unsupported right
operand type for in ("CombinedPredictionResult")  [operator]
            assert "price_target" in combined
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:67:27: error: Value of type
"CombinedPredictionResult" is not indexable  [index]
            assert isinstance(combined["direction"], str)
                              ^~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:68:27: error: Value of type
"CombinedPredictionResult" is not indexable  [index]
            assert isinstance(combined["confidence"], (int, float))
                              ^~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:69:27: error: Value of type
"CombinedPredictionResult" is not indexable  [index]
            assert isinstance(combined["price_target"], (int, float))
                              ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:74:24: error:
"CombinedPredictor" has no attribute "_calculate_weighted_average" 
[attr-defined]
            weighted_avg = predictor._calculate_weighted_average(values, w...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:85:21: error:
"CombinedPredictor" has no attribute "_determine_consensus_direction" 
[attr-defined]
            consensus = predictor._determine_consensus_direction(predictio...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:93:21: error:
"CombinedPredictor" has no attribute "_determine_consensus_direction" 
[attr-defined]
            consensus = predictor._determine_consensus_direction(predictio...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:102:28: error:
"CombinedPredictor" has no attribute "_get_technical_prediction"  [attr-defined]
            prediction = await predictor._get_technical_prediction(symbol,...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:116:28: error:
"CombinedPredictor" has no attribute "_get_pattern_prediction"; maybe
"pattern_predictor"?  [attr-defined]
            prediction = await predictor._get_pattern_prediction(symbol, t...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:130:28: error:
"CombinedPredictor" has no attribute "_get_ml_prediction"  [attr-defined]
            prediction = await predictor._get_ml_prediction(symbol, timefr...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:160:24: error:
"PatternPredictor" has no attribute "predict_from_patterns"  [attr-defined]
            result = await predictor.predict_from_patterns(symbol, timefra...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:173:22: error:
"PatternPredictor" has no attribute "_analyze_pattern_confidence" 
[attr-defined]
            confidence = predictor._analyze_pattern_confidence(pattern)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:179:18: error:
"PatternPredictor" has no attribute "_calculate_pattern_weight"  [attr-defined]
            weight = predictor._calculate_pattern_weight(pattern)
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:193:25: error:
"PatternPredictor" has no attribute "get_pattern_history"  [attr-defined]
            history = await predictor.get_pattern_history(symbol, timefram...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:211:16: error: Incompatible
return value type (got "tuple[Mock, Mock]", expected "Mock")  [return-value]
            return market_repo, reversal_repo
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:228:24: error:
"ReversalController" has no attribute "detect_reversal_signals"  [attr-defined]
            result = await controller.detect_reversal_signals(symbol, time...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:241:20: error:
"ReversalController" has no attribute "_analyze_signal_strength"  [attr-defined]
            strength = controller._analyze_signal_strength(signal)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:250:23: error:
"ReversalController" has no attribute "_calculate_reversal_probability" 
[attr-defined]
            probability = controller._calculate_reversal_probability(signa...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:261:21: error:
"ReversalController" has no attribute "_determine_overall_direction" 
[attr-defined]
            direction = controller._determine_overall_direction(signals)
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:269:21: error:
"ReversalController" has no attribute "_determine_overall_direction" 
[attr-defined]
            direction = controller._determine_overall_direction(signals)
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:283:25: error:
"ReversalController" has no attribute "get_reversal_history"  [attr-defined]
            history = await controller.get_reversal_history(symbol, timefr...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:295:16: error:
"ReversalController" has no attribute "_validate_signal_data"  [attr-defined]
            assert controller._validate_signal_data(valid_signal) is True
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:298:16: error:
"ReversalController" has no attribute "_validate_signal_data"  [attr-defined]
            assert controller._validate_signal_data(invalid_signal) is Fal...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_prediction.py:301:16: error:
"ReversalController" has no attribute "_validate_signal_data"  [attr-defined]
            assert controller._validate_signal_data(invalid_signal) is Fal...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\portfolio_optimization.py:63:30: error:
Argument 1 to "LinearConstraint" has incompatible type
"Callable[[], ndarray[Any, Any]]"; expected
"CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | sparray[bool_ | integer[Any] | floating[_32Bit] | floating[_64Bit] | floating[Any] | complexfloating[Any, Any], tuple[int, Unpack[tuple[int, ...]]]] | spmatrix[bool_ | integer[Any] | floating[_32Bit] | floating[_64Bit] | floating[Any] | complexfloating[Any, Any]]"
 [arg-type]
                LinearConstraint(expected_returns.values, target_return, t...
                                 ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\portfolio_optimization.py:81:18: error:
No overload variant of "dot" matches argument types "ndarray[Any, Any]",
"Series"  [call-overload]
        return float(np.dot(weights, expected_returns))
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\portfolio_optimization.py:81:18: note: Possible overload variants:
infrastructure\services\risk_analysis\portfolio_optimization.py:81:18: note:     def dot(a: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], b: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], out: None = ...) -> Any
infrastructure\services\risk_analysis\portfolio_optimization.py:81:18: note:     def [_ArrayType: ndarray[Any, dtype[Any]]] dot(a: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], b: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], out: _ArrayType) -> _ArrayType
infrastructure\services\risk_analysis\portfolio_optimization.py:88:43: error:
"DataFrame" has no attribute "values"  [attr-defined]
        return float(np.dot(weights.T, np.dot(covariance_matrix.values, we...
                                              ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\portfolio_optimization.py:118:41: error:
"DataFrame" has no attribute "values"  [attr-defined]
            marginal_contributions = np.dot(covariance_matrix.values, weig...
                                            ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\portfolio_optimization.py:138:17: error:
"DataFrame" has no attribute "values"  [attr-defined]
                    correlation_matrix.values * np.outer(volatilities, vol...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:201:17: error: Unexpected keyword
argument "event_type" for "Event"  [call-arg]
                    Event(
                    ^
infrastructure\core\portfolio_manager.py:297:32: error: "DataFrame" has no
attribute "dot"  [attr-defined]
                weighted_returns = portfolio_returns.dot(weights)
                                   ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:327:26: error: "int" has no attribute
"cumprod"  [attr-defined]
                cumulative = (1 + returns).cumprod()
                             ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:327:31: error: Unsupported operand
types for + ("int" and "Series")  [operator]
                cumulative = (1 + returns).cumprod()
                                  ^~~~~~~
infrastructure\core\portfolio_manager.py:345:16: error: Incompatible return
value type (got "dict[str, dict[str, float]]", expected "dict[str, float]") 
[return-value]
            return self.correlation_matrix
                   ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:363:34: error: "DataFrame" has no
attribute "corr"  [attr-defined]
                correlation_matrix = returns_df.corr()
                                     ^~~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:400:18: error: Incompatible types in
assignment (expression has type "object", variable has type "str | None") 
[assignment]
            method = method or self.optimization_config["method"]
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:452:32: error: "DataFrame" has no
attribute "mean"  [attr-defined]
                expected_returns = returns_df.mean() * 252  # √одовые дохо...
                                   ^~~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:485:22: error: No overload variant of
"minimize" matches argument types "Callable[[Any], Any]",
"ndarray[Any, dtype[Any]]", "str", "list[tuple[object, object]]",
"dict[str, object]", "dict[str, object]"  [call-overload]
                result = minimize(
                         ^
infrastructure\core\portfolio_manager.py:485:22: note: Possible overload variants:
infrastructure\core\portfolio_manager.py:485:22: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], float | floating[Any] | integer[Any] | bool_], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...] = ..., method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None = ..., jac: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | Literal['2-point', '3-point', 'cs'] | Literal[False, 0] | None = ..., hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:485:22: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], tuple[float | floating[Any] | integer[Any] | bool_, CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...], method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None, jac: Literal[True, 1], hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:485:22: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], tuple[float | floating[Any] | integer[Any] | bool_, CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...] = ..., method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None = ..., *, jac: Literal[True, 1], hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:509:36: error: No overload variant of
"dot" matches argument types "DataFrame", "Any"  [call-overload]
                    np.dot(result.x.T, np.dot(cov_matrix_stable, result.x)...
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:509:36: note: Possible overload variants:
infrastructure\core\portfolio_manager.py:509:36: note:     def dot(a: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], b: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], out: None = ...) -> Any
infrastructure\core\portfolio_manager.py:509:36: note:     def [_ArrayType: ndarray[Any, dtype[Any]]] dot(a: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], b: _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes], out: _ArrayType) -> _ArrayType
infrastructure\core\portfolio_manager.py:557:32: error: "DataFrame" has no
attribute "mean"  [attr-defined]
                expected_returns = returns_df.mean() * 252
                                   ^~~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:558:26: error: "DataFrame" has no
attribute "cov"  [attr-defined]
                cov_matrix = returns_df.cov() * 252
                             ^~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:604:22: error: No overload variant of
"minimize" matches argument types "Callable[[Any], Any]",
"ndarray[Any, dtype[Any]]", "str", "list[tuple[object, object]]",
"dict[str, object]"  [call-overload]
                result = minimize(
                         ^
infrastructure\core\portfolio_manager.py:604:22: note: Possible overload variants:
infrastructure\core\portfolio_manager.py:604:22: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], float | floating[Any] | integer[Any] | bool_], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...] = ..., method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None = ..., jac: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | Literal['2-point', '3-point', 'cs'] | Literal[False, 0] | None = ..., hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:604:22: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], tuple[float | floating[Any] | integer[Any] | bool_, CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...], method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None, jac: Literal[True, 1], hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:604:22: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], tuple[float | floating[Any] | integer[Any] | bool_, CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...] = ..., method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None = ..., *, jac: Literal[True, 1], hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:663:26: error: "DataFrame" has no
attribute "cov"  [attr-defined]
                cov_matrix = returns_df.cov() * 252
                             ^~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:685:22: error: No overload variant of
"minimize" matches argument types "Callable[[Any], Any]",
"ndarray[Any, dtype[Any]]", "str", "list[tuple[object, object]]",
"dict[str, object]"  [call-overload]
                result = minimize(
                         ^
infrastructure\core\portfolio_manager.py:685:22: note: Possible overload variants:
infrastructure\core\portfolio_manager.py:685:22: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], float | floating[Any] | integer[Any] | bool_], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...] = ..., method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None = ..., jac: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | Literal['2-point', '3-point', 'cs'] | Literal[False, 0] | None = ..., hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:685:22: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], tuple[float | floating[Any] | integer[Any] | bool_, CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...], method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None, jac: Literal[True, 1], hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:685:22: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], tuple[float | floating[Any] | integer[Any] | bool_, CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...] = ..., method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None = ..., *, jac: Literal[True, 1], hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:706:32: error: "DataFrame" has no
attribute "mean"  [attr-defined]
                expected_returns = returns_df.mean() * 252
                                   ^~~~~~~~~~~~~~~
infrastructure\core\portfolio_manager.py:767:26: error: No overload variant of
"minimize" matches argument types "Callable[[Any], Any]",
"ndarray[Any, dtype[Any]]", "str", "list[tuple[int, int]]",
"list[dict[str, object]]"  [call-overload]
                    result = minimize(
                             ^
infrastructure\core\portfolio_manager.py:767:26: note: Possible overload variants:
infrastructure\core\portfolio_manager.py:767:26: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], float | floating[Any] | integer[Any] | bool_], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...] = ..., method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None = ..., jac: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | Literal['2-point', '3-point', 'cs'] | Literal[False, 0] | None = ..., hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:767:26: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], tuple[float | floating[Any] | integer[Any] | bool_, CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...], method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None, jac: Literal[True, 1], hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:767:26: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], tuple[float | floating[Any] | integer[Any] | bool_, CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...] = ..., method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None = ..., *, jac: Literal[True, 1], hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
infrastructure\core\portfolio_manager.py:874:13: error: Unsupported operand
types for + ("None" and "int")  [operator]
                self.rebalancing_stats["total_rebalances"] += 1
                ^
infrastructure\core\portfolio_manager.py:874:13: note: Left operand is of type "float | None"
infrastructure\core\portfolio_manager.py:875:13: error: Unsupported operand
types for + ("None" and "int")  [operator]
                self.rebalancing_stats["successful_rebalances"] += success...
                ^
infrastructure\core\portfolio_manager.py:875:13: note: Left operand is of type "float | None"
infrastructure\core\portfolio_manager.py:876:13: error: Unsupported operand
types for + ("None" and "float")  [operator]
                self.rebalancing_stats["total_cost"] += total_cost
                ^
infrastructure\core\portfolio_manager.py:876:13: note: Left operand is of type "float | None"
infrastructure\core\portfolio_manager.py:882:17: error: Unexpected keyword
argument "event_type" for "Event"  [call-arg]
                    Event(
                    ^
domain\services\risk_analysis.py:315:32: error: "DataFrame" has no attribute
"dropna"  [attr-defined]
                stressed_returns = stressed_data.pct_change().dropna()
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:319:47: error: "DataFrame" has no attribute
"iloc"  [attr-defined]
                        stressed_returns_series = stressed_returns.iloc[:,...
                                                  ^~~~~~~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:321:47: error: "DataFrame" has no attribute
"mean"  [attr-defined]
                        stressed_returns_series = stressed_returns.mean(ax...
                                                  ^~~~~~~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:335:22: error: "DataFrame" has no attribute
"cov"  [attr-defined]
            cov_matrix = returns.cov()
                         ^~~~~~~~~~~
domain\services\risk_analysis.py:336:24: error: "DataFrame" has no attribute
"mean"  [attr-defined]
            mean_returns = returns.mean()
                           ^~~~~~~~~~~~
domain\services\risk_analysis.py:365:33: error: "DataFrame" has no attribute
"dot"  [attr-defined]
                portfolio_returns = returns.dot(optimal_weights)
                                    ^~~~~~~~~~~
domain\services\risk_analysis.py:379:28: error: No overload variant of
"percentile" matches argument types "Series", "float"  [call-overload]
            return Decimal(str(np.percentile(returns, (1 - confidence_leve...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\services\risk_analysis.py:379:28: note: Possible overload variants:
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> floating[Any]
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> complexfloating[Any, Any]
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> timedelta64
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[datetime64]] | _NestedSequence[_SupportsArray[dtype[datetime64]]], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> datetime64
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> Any
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[floating[Any]]]
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[complexfloating[Any, Any]]]
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[timedelta64]]
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[datetime64]] | _NestedSequence[_SupportsArray[dtype[datetime64]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[datetime64]]
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[object_]]
domain\services\risk_analysis.py:379:28: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: bool = ...) -> Any
domain\services\risk_analysis.py:379:28: note:     def [_ArrayType: ndarray[Any, dtype[Any]]] percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: _ArrayType = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: bool = ...) -> _ArrayType
domain\services\risk_analysis.py:383:15: error: No overload variant of
"percentile" matches argument types "Series", "float"  [call-overload]
            var = np.percentile(returns, (1 - confidence_level) * 100)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:383:15: note: Possible overload variants:
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> floating[Any]
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> complexfloating[Any, Any]
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> timedelta64
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[datetime64]] | _NestedSequence[_SupportsArray[dtype[datetime64]]], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> datetime64
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> Any
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[floating[Any]]]
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[complexfloating[Any, Any]]]
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[timedelta64]]
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[datetime64]] | _NestedSequence[_SupportsArray[dtype[datetime64]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[datetime64]]
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[object_]]
domain\services\risk_analysis.py:383:15: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: bool = ...) -> Any
domain\services\risk_analysis.py:383:15: note:     def [_ArrayType: ndarray[Any, dtype[Any]]] percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: _ArrayType = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: bool = ...) -> _ArrayType
domain\services\risk_analysis.py:388:22: error: "int" has no attribute
"cumprod"  [attr-defined]
            cumulative = (1 + returns).cumprod()
                         ^~~~~~~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:388:27: error: Unsupported operand types for +
("int" and "Series")  [operator]
            cumulative = (1 + returns).cumprod()
                              ^~~~~~~
domain\services\risk_analysis.py:395:26: error: Unsupported operand types for -
("Series" and "float")  [operator]
            excess_returns = returns - self.risk_free_rate / 252
                             ^
domain\services\risk_analysis.py:396:28: error: "float" has no attribute "mean"
 [attr-defined]
            return Decimal(str(excess_returns.mean() / returns.std() * np....
                               ^~~~~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:400:26: error: Unsupported operand types for -
("Series" and "float")  [operator]
            excess_returns = returns - self.risk_free_rate / 252
                             ^
domain\services\risk_analysis.py:401:36: error: Unsupported operand types for >
("int" and "Series")  [operator]
            downside_returns = returns[returns < 0]
                                       ^
domain\services\risk_analysis.py:404:17: error: "float" has no attribute "mean"
 [attr-defined]
                str(excess_returns.mean() / downside_std * np.sqrt(252))
                    ^~~~~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:428:56: error: "Series" has no attribute
"index"  [attr-defined]
                    [returns.mean()] * len(returns), index=returns.index
                                                           ^~~~~~~~~~~~~
domain\services\risk_analysis.py:430:22: error: "Series" has no attribute "cov"
 [attr-defined]
            covariance = returns.cov(market_returns)
                         ^~~~~~~~~~~
domain\services\risk_analysis.py:431:27: error: "Series" has no attribute "var"
 [attr-defined]
            market_variance = market_returns.var()
                              ^~~~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:453:25: error: Unsupported operand types for -
("Series" and "float")  [operator]
            active_return = returns - benchmark_return
                            ^
domain\services\risk_analysis.py:454:26: error: "float" has no attribute "std" 
[attr-defined]
            tracking_error = active_return.std()
                             ^~~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:456:17: error: "float" has no attribute "mean"
 [attr-defined]
                str(active_return.mean() / tracking_error) if tracking_err...
                    ^~~~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:473:28: error: "Series" has no attribute
"corr"  [attr-defined]
            return Decimal(str(returns1.corr(returns2)))
                               ^~~~~~~~~~~~~
domain\services\risk_analysis.py:496:20: error: "Series" has no attribute
"kurtosis"  [attr-defined]
            kurtosis = returns.kurtosis()
                       ^~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:550:36: error: Unsupported operand types for *
("Series" and "float")  [operator]
                    stressed_returns = returns * multiplier
                                       ^
domain\services\risk_analysis.py:552:36: error: Unsupported operand types for *
("Series" and "float")  [operator]
                    stressed_returns = returns * multiplier
                                       ^
domain\services\risk_analysis.py:554:36: error: Incompatible types in
assignment (expression has type "Series", variable has type "float") 
[assignment]
                    stressed_returns = returns
                                       ^~~~~~~
domain\services\risk_analysis.py:555:39: error: Argument 1 to "_calculate_var"
of "DefaultRiskAnalysisService" has incompatible type "float"; expected "Series"
 [arg-type]
                var = self._calculate_var(stressed_returns, self.confidenc...
                                          ^~~~~~~~~~~~~~~~
domain\services\risk_analysis.py:575:25: error: "DataFrame" has no attribute
"copy"  [attr-defined]
            stressed_data = data.copy()
                            ^~~~~~~~~
domain\evolution\strategy_optimizer.py:298:40: error: Incompatible types in
assignment (expression has type "dict[str, Any]", variable has type
"IndicatorParameters")  [assignment]
                    indicator.parameters = self._mutate_parameters(indicat...
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\evolution\strategy_optimizer.py:298:64: error: Argument 1 to
"_mutate_parameters" of "StrategyOptimizer" has incompatible type
"IndicatorParameters"; expected "dict[str, Any]"  [arg-type]
    ...  indicator.parameters = self._mutate_parameters(indicator.parameters)
                                                        ^~~~~~~~~~~~~~~~~~~~
domain\evolution\strategy_optimizer.py:302:44: error: Incompatible types in
assignment (expression has type "dict[str, Any]", variable has type
"FilterParameters")  [assignment]
                    filter_config.parameters = self._mutate_parameters(fil...
                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\evolution\strategy_optimizer.py:302:68: error: Argument 1 to
"_mutate_parameters" of "StrategyOptimizer" has incompatible type
"FilterParameters"; expected "dict[str, Any]"  [arg-type]
    ...lter_config.parameters = self._mutate_parameters(filter_config.paramet...
                                                        ^~~~~~~~~~~~~~~~~~~~~~~~
domain\evolution\strategy_optimizer.py:306:35: error: Incompatible types in
assignment (expression has type "dict[str, Any]", variable has type
"list[EntryCondition]")  [assignment]
                    rule.conditions = self._mutate_parameters(rule.conditi...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\evolution\strategy_optimizer.py:306:59: error: Argument 1 to
"_mutate_parameters" of "StrategyOptimizer" has incompatible type
"list[EntryCondition]"; expected "dict[str, Any]"  [arg-type]
    ...            rule.conditions = self._mutate_parameters(rule.conditions)
                                                             ^~~~~~~~~~~~~~~
domain\evolution\strategy_optimizer.py:307:9: error: Incompatible types in
assignment (expression has type "ExitRule", variable has type "EntryRule") 
[assignment]
            for rule in mutated.exit_rules:
            ^
domain\evolution\strategy_optimizer.py:309:17: error: "EntryRule" has no
attribute "parameters"  [attr-defined]
                    rule.parameters = self._mutate_parameters(rule.paramet...
                    ^~~~~~~~~~~~~~~
domain\evolution\strategy_optimizer.py:373:42: error: TypedDict key must be a
string literal; expected one of ("period", "fast", "slow", "signal",
"acceleration", ...)  [literal-required]
                        indicator.parameters[param_name] = params[param_ke...
                                             ^~~~~~~~~~
domain\evolution\strategy_optimizer.py:379:46: error: TypedDict key must be a
string literal; expected one of ("min_atr", "max_atr", "min_width", "max_width",
"min_volume", ...)  [literal-required]
                        filter_config.parameters[param_name] = params[para...
                                                 ^~~~~~~~~~
domain\evolution\strategy_optimizer.py:421:52: error: TypedDict key must be a
string literal; expected one of ("period", "fast", "slow", "signal",
"acceleration", ...)  [literal-required]
    ...              if isinstance(indicator.parameters[param_name], (int, fl...
                                                        ^~~~~~~~~~
domain\evolution\strategy_optimizer.py:422:42: error: TypedDict key must be a
string literal; expected one of ("period", "fast", "slow", "signal",
"acceleration", ...)  [literal-required]
                        indicator.parameters[param_name] = vector[idx]
                                             ^~~~~~~~~~
domain\evolution\strategy_optimizer.py:427:56: error: TypedDict key must be a
string literal; expected one of ("min_atr", "max_atr", "min_width", "max_width",
"min_volume", ...)  [literal-required]
    ...          if isinstance(filter_config.parameters[param_name], (int, fl...
                                                        ^~~~~~~~~~
domain\evolution\strategy_optimizer.py:428:46: error: TypedDict key must be a
string literal; expected one of ("min_atr", "max_atr", "min_width", "max_width",
"min_volume", ...)  [literal-required]
                        filter_config.parameters[param_name] = vector[idx]
                                                 ^~~~~~~~~~
tests\unit\test_portfolio_manager.py:75:17: error: Module has no attribute
"date_range"  [attr-defined]
            dates = pd.date_range('2023-01-01', periods=100, freq='1D')
                    ^~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:95:9: error: Value of type
"Coroutine[Any, Any, list[RebalancingAction]]" must be used  [unused-coroutine]
            portfolio_manager.rebalance_portfolio({
            ^
tests\unit\test_portfolio_manager.py:95:9: note: Are you missing an await?
tests\unit\test_portfolio_manager.py:96:13: error: Dict entry 0 has
incompatible type "str": "str"; expected "str": "float"  [dict-item]
                "name": "Test Portfolio",
                ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:97:13: error: Dict entry 1 has
incompatible type "str": "Decimal"; expected "str": "float"  [dict-item]
                "initial_capital": Decimal("100000.0")
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:117:27: error: No overload variant of
"__getitem__" of "list" matches argument type "str"  [call-overload]
            assert isinstance(rebalance_result["actions"], list)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:117:27: note: Possible overload variants:
tests\unit\test_portfolio_manager.py:117:27: note:     def __getitem__(self, SupportsIndex, /) -> RebalancingAction
tests\unit\test_portfolio_manager.py:117:27: note:     def __getitem__(self, slice[Any, Any, Any], /) -> list[RebalancingAction]
tests\unit\test_portfolio_manager.py:118:27: error: No overload variant of
"__getitem__" of "list" matches argument type "str"  [call-overload]
            assert isinstance(rebalance_result["success"], bool)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:118:27: note: Possible overload variants:
tests\unit\test_portfolio_manager.py:118:27: note:     def __getitem__(self, SupportsIndex, /) -> RebalancingAction
tests\unit\test_portfolio_manager.py:118:27: note:     def __getitem__(self, slice[Any, Any, Any], /) -> list[RebalancingAction]
tests\unit\test_portfolio_manager.py:119:27: error: No overload variant of
"__getitem__" of "list" matches argument type "str"  [call-overload]
            assert isinstance(rebalance_result["updated_portfolio"], dict)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:119:27: note: Possible overload variants:
tests\unit\test_portfolio_manager.py:119:27: note:     def __getitem__(self, SupportsIndex, /) -> RebalancingAction
tests\unit\test_portfolio_manager.py:119:27: note:     def __getitem__(self, slice[Any, Any, Any], /) -> list[RebalancingAction]
tests\unit\test_portfolio_manager.py:120:27: error: No overload variant of
"__getitem__" of "list" matches argument type "str"  [call-overload]
            assert isinstance(rebalance_result["rebalance_time"], datetime...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:120:27: note: Possible overload variants:
tests\unit\test_portfolio_manager.py:120:27: note:     def __getitem__(self, SupportsIndex, /) -> RebalancingAction
tests\unit\test_portfolio_manager.py:120:27: note:     def __getitem__(self, slice[Any, Any, Any], /) -> list[RebalancingAction]
tests\unit\test_portfolio_manager.py:123:19: error: No overload variant of
"__getitem__" of "list" matches argument type "str"  [call-overload]
            actions = rebalance_result["actions"]
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:123:19: note: Possible overload variants:
tests\unit\test_portfolio_manager.py:123:19: note:     def __getitem__(self, SupportsIndex, /) -> RebalancingAction
tests\unit\test_portfolio_manager.py:123:19: note:     def __getitem__(self, slice[Any, Any, Any], /) -> list[RebalancingAction]
tests\unit\test_portfolio_manager.py:137:9: error: Value of type
"Coroutine[Any, Any, list[RebalancingAction]]" must be used  [unused-coroutine]
            portfolio_manager.rebalance_portfolio({
            ^
tests\unit\test_portfolio_manager.py:137:9: note: Are you missing an await?
tests\unit\test_portfolio_manager.py:138:13: error: Dict entry 0 has
incompatible type "str": "str"; expected "str": "float"  [dict-item]
                "name": "Test Portfolio",
                ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:139:13: error: Dict entry 1 has
incompatible type "str": "Decimal"; expected "str": "float"  [dict-item]
                "initial_capital": Decimal("100000.0")
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:143:37: error: Unexpected keyword argument
"symbols" for "optimize_portfolio" of "PortfolioManager"  [call-arg]
            optimization_result = await portfolio_manager.optimize_portfol...
                                        ^
infrastructure\core\portfolio_manager.py:378:5: note: "optimize_portfolio" of "PortfolioManager" defined here
tests\unit\test_portfolio_manager.py:143:37: error: Unexpected keyword argument
"historical_data" for "optimize_portfolio" of "PortfolioManager"  [call-arg]
            optimization_result = await portfolio_manager.optimize_portfol...
                                        ^
infrastructure\core\portfolio_manager.py:378:5: note: "optimize_portfolio" of "PortfolioManager" defined here
tests\unit\test_portfolio_manager.py:150:16: error: Unsupported right operand
type for in ("PortfolioOptimizationResult")  [operator]
            assert "optimal_weights" in optimization_result
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:151:16: error: Unsupported right operand
type for in ("PortfolioOptimizationResult")  [operator]
            assert "expected_return" in optimization_result
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:152:16: error: Unsupported right operand
type for in ("PortfolioOptimizationResult")  [operator]
            assert "expected_risk" in optimization_result
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:153:16: error: Unsupported right operand
type for in ("PortfolioOptimizationResult")  [operator]
            assert "sharpe_ratio" in optimization_result
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:154:16: error: Unsupported right operand
type for in ("PortfolioOptimizationResult")  [operator]
            assert "optimization_time" in optimization_result
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:157:27: error: Value of type
"PortfolioOptimizationResult" is not indexable  [index]
            assert isinstance(optimization_result["optimal_weights"], dict...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:158:27: error: Value of type
"PortfolioOptimizationResult" is not indexable  [index]
            assert isinstance(optimization_result["expected_return"], floa...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:159:27: error: Value of type
"PortfolioOptimizationResult" is not indexable  [index]
            assert isinstance(optimization_result["expected_risk"], float)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:160:27: error: Value of type
"PortfolioOptimizationResult" is not indexable  [index]
            assert isinstance(optimization_result["sharpe_ratio"], float)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:161:27: error: Value of type
"PortfolioOptimizationResult" is not indexable  [index]
            assert isinstance(optimization_result["optimization_time"], da...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:164:19: error: Value of type
"PortfolioOptimizationResult" is not indexable  [index]
            weights = optimization_result["optimal_weights"]
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:171:30: error:
"dict[str, dict[str, float]]" not callable  [operator]
            correlation_matrix = portfolio_manager.correlation_matrix(samp...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_portfolio_manager.py:176:16: error: "DataFrame" has no
attribute "shape"  [attr-defined]
            assert correlation_matrix.shape[0] == correlation_matrix.shape...
                   ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:177:16: error: "DataFrame" has no
attribute "shape"  [attr-defined]
            assert correlation_matrix.shape[0] == len(sample_market_data.c...
                   ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:181:20: error: "DataFrame" has no
attribute "iloc"  [attr-defined]
                assert correlation_matrix.iloc[i, i] == pytest.approx(1.0,...
                       ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:187:9: error: Value of type
"Coroutine[Any, Any, list[RebalancingAction]]" must be used  [unused-coroutine]
            portfolio_manager.rebalance_portfolio({
            ^
tests\unit\test_portfolio_manager.py:187:9: note: Are you missing an await?
tests\unit\test_portfolio_manager.py:188:13: error: Dict entry 0 has
incompatible type "str": "str"; expected "str": "float"  [dict-item]
                "name": "Test Portfolio",
                ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:189:13: error: Dict entry 1 has
incompatible type "str": "Decimal"; expected "str": "float"  [dict-item]
                "initial_capital": Decimal("100000.0")
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:218:9: error: Value of type
"Coroutine[Any, Any, list[RebalancingAction]]" must be used  [unused-coroutine]
            portfolio_manager.rebalance_portfolio({
            ^
tests\unit\test_portfolio_manager.py:218:9: note: Are you missing an await?
tests\unit\test_portfolio_manager.py:219:13: error: Dict entry 0 has
incompatible type "str": "str"; expected "str": "float"  [dict-item]
                "name": "Test Portfolio",
                ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:220:13: error: Dict entry 1 has
incompatible type "str": "Decimal"; expected "str": "float"  [dict-item]
                "initial_capital": Decimal("100000.0")
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:236:27: error: No overload variant of
"__getitem__" of "list" matches argument type "str"  [call-overload]
            assert isinstance(validation_result["is_valid"], bool)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:236:27: note: Possible overload variants:
tests\unit\test_portfolio_manager.py:236:27: note:     def __getitem__(self, SupportsIndex, /) -> RebalancingAction
tests\unit\test_portfolio_manager.py:236:27: note:     def __getitem__(self, slice[Any, Any, Any], /) -> list[RebalancingAction]
tests\unit\test_portfolio_manager.py:237:27: error: No overload variant of
"__getitem__" of "list" matches argument type "str"  [call-overload]
            assert isinstance(validation_result["errors"], list)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:237:27: note: Possible overload variants:
tests\unit\test_portfolio_manager.py:237:27: note:     def __getitem__(self, SupportsIndex, /) -> RebalancingAction
tests\unit\test_portfolio_manager.py:237:27: note:     def __getitem__(self, slice[Any, Any, Any], /) -> list[RebalancingAction]
tests\unit\test_portfolio_manager.py:238:27: error: No overload variant of
"__getitem__" of "list" matches argument type "str"  [call-overload]
            assert isinstance(validation_result["warnings"], list)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:238:27: note: Possible overload variants:
tests\unit\test_portfolio_manager.py:238:27: note:     def __getitem__(self, SupportsIndex, /) -> RebalancingAction
tests\unit\test_portfolio_manager.py:238:27: note:     def __getitem__(self, slice[Any, Any, Any], /) -> list[RebalancingAction]
tests\unit\test_portfolio_manager.py:243:9: error: Value of type
"Coroutine[Any, Any, list[RebalancingAction]]" must be used  [unused-coroutine]
            portfolio_manager.rebalance_portfolio({
            ^
tests\unit\test_portfolio_manager.py:243:9: note: Are you missing an await?
tests\unit\test_portfolio_manager.py:244:13: error: Dict entry 0 has
incompatible type "str": "str"; expected "str": "float"  [dict-item]
                "name": "Test Portfolio",
                ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:245:13: error: Dict entry 1 has
incompatible type "str": "Decimal"; expected "str": "float"  [dict-item]
                "initial_capital": Decimal("100000.0")
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:253:16: error: Unsupported right operand
type for in ("Coroutine[Any, Any, dict[str, Any]]")  [operator]
            assert "total_value" in status
                   ^~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:253:16: note: Maybe you forgot to use "await"?
tests\unit\test_portfolio_manager.py:254:16: error: Unsupported right operand
type for in ("Coroutine[Any, Any, dict[str, Any]]")  [operator]
            assert "cash" in status
                   ^~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:254:16: note: Maybe you forgot to use "await"?
tests\unit\test_portfolio_manager.py:255:16: error: Unsupported right operand
type for in ("Coroutine[Any, Any, dict[str, Any]]")  [operator]
            assert "positions_count" in status
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:255:16: note: Maybe you forgot to use "await"?
tests\unit\test_portfolio_manager.py:256:16: error: Unsupported right operand
type for in ("Coroutine[Any, Any, dict[str, Any]]")  [operator]
            assert "last_updated" in status
                   ^~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:256:16: note: Maybe you forgot to use "await"?
tests\unit\test_portfolio_manager.py:259:27: error: Value of type
"Coroutine[Any, Any, dict[str, Any]]" is not indexable  [index]
            assert isinstance(status["total_value"], Decimal)
                              ^~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:259:27: note: Maybe you forgot to use "await"?
tests\unit\test_portfolio_manager.py:260:27: error: Value of type
"Coroutine[Any, Any, dict[str, Any]]" is not indexable  [index]
            assert isinstance(status["cash"], Decimal)
                              ^~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:260:27: note: Maybe you forgot to use "await"?
tests\unit\test_portfolio_manager.py:261:27: error: Value of type
"Coroutine[Any, Any, dict[str, Any]]" is not indexable  [index]
            assert isinstance(status["positions_count"], int)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:261:27: note: Maybe you forgot to use "await"?
tests\unit\test_portfolio_manager.py:262:27: error: Value of type
"Coroutine[Any, Any, dict[str, Any]]" is not indexable  [index]
            assert isinstance(status["last_updated"], datetime)
                              ^~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:262:27: note: Maybe you forgot to use "await"?
tests\unit\test_portfolio_manager.py:273:19: error: Too many arguments for
"optimize_portfolio" of "PortfolioManager"  [call-arg]
                await portfolio_manager.optimize_portfolio([], pd.DataFram...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_portfolio_manager.py:273:56: error: Argument 1 to
"optimize_portfolio" of "PortfolioManager" has incompatible type "list[Never]";
expected "str | None"  [arg-type]
    ...        await portfolio_manager.optimize_portfolio([], pd.DataFrame())
                                                          ^~
tests\unit\test_portfolio_manager.py:279:9: error: Value of type
"Coroutine[Any, Any, list[RebalancingAction]]" must be used  [unused-coroutine]
            portfolio_manager.rebalance_portfolio({
            ^
tests\unit\test_portfolio_manager.py:279:9: note: Are you missing an await?
tests\unit\test_portfolio_manager.py:280:13: error: Dict entry 0 has
incompatible type "str": "str"; expected "str": "float"  [dict-item]
                "name": "Minimal Portfolio",
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:281:13: error: Dict entry 1 has
incompatible type "str": "Decimal"; expected "str": "float"  [dict-item]
                "initial_capital": Decimal("100.0")
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:287:16: error: No overload variant of
"__getitem__" of "list" matches argument type "str"  [call-overload]
            assert result["success"] is True
                   ^~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:287:16: note: Possible overload variants:
tests\unit\test_portfolio_manager.py:287:16: note:     def __getitem__(self, SupportsIndex, /) -> RebalancingAction
tests\unit\test_portfolio_manager.py:287:16: note:     def __getitem__(self, slice[Any, Any, Any], /) -> list[RebalancingAction]
tests\unit\test_portfolio_manager.py:294:28: error: Unexpected keyword argument
"symbols" for "optimize_portfolio" of "PortfolioManager"  [call-arg]
            opt_result = await portfolio_manager.optimize_portfolio(
                               ^
infrastructure\core\portfolio_manager.py:378:5: note: "optimize_portfolio" of "PortfolioManager" defined here
tests\unit\test_portfolio_manager.py:294:28: error: Unexpected keyword argument
"historical_data" for "optimize_portfolio" of "PortfolioManager"  [call-arg]
            opt_result = await portfolio_manager.optimize_portfolio(
                               ^
infrastructure\core\portfolio_manager.py:378:5: note: "optimize_portfolio" of "PortfolioManager" defined here
tests\unit\test_portfolio_manager.py:304:13: error: "PortfolioManager" has no
attribute "cleanup"  [attr-defined]
                portfolio_manager.cleanup()
                ^~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:310:16: error: "PortfolioManager" has no
attribute "risk_analyzers"  [attr-defined]
            assert portfolio_manager.risk_analyzers is not None
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_portfolio_manager.py:311:16: error: "PortfolioManager" has no
attribute "optimizers"  [attr-defined]
            assert portfolio_manager.optimizers is not None 
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\autonomous_controller.py:41:41: error: Argument 1 to
"MetricsCollector" has incompatible type
"infrastructure.messaging.optimized_event_bus.EventBus"; expected
"infrastructure.messaging.event_bus.EventBus"  [arg-type]
            self.metrics = MetricsCollector(event_bus)
                                            ^~~~~~~~~
infrastructure\core\autonomous_controller.py:42:45: error: Argument 1 to
"HealthChecker" has incompatible type
"infrastructure.messaging.optimized_event_bus.EventBus"; expected
"infrastructure.messaging.event_bus.EventBus"  [arg-type]
            self.health_checker = HealthChecker(event_bus)
                                                ^~~~~~~~~
infrastructure\core\autonomous_controller.py:45:41: error: Argument 1 to
"RiskManager" has incompatible type
"infrastructure.messaging.optimized_event_bus.EventBus"; expected
"infrastructure.messaging.event_bus.EventBus"  [arg-type]
            self.risk_manager = RiskManager(event_bus, config.get("risk", ...
                                            ^~~~~~~~~
infrastructure\core\autonomous_controller.py:47:13: error: Argument 1 to
"PortfolioManager" has incompatible type
"infrastructure.messaging.optimized_event_bus.EventBus"; expected
"infrastructure.messaging.event_bus.EventBus"  [arg-type]
                event_bus, config.get("portfolio", {})
                ^~~~~~~~~
infrastructure\core\autonomous_controller.py:52:49: error: Argument 1 to
"RegimeDiscovery" has incompatible type
"infrastructure.messaging.optimized_event_bus.EventBus"; expected
"infrastructure.messaging.event_bus.EventBus"  [arg-type]
            self.regime_discovery = RegimeDiscovery(event_bus)
                                                    ^~~~~~~~~
infrastructure\core\autonomous_controller.py:126:13: error: Argument 1 to
"publish" of "EventBus" has incompatible type
"domain.types.messaging_types.Event"; expected
"infrastructure.messaging.optimized_event_bus.Event"  [arg-type]
                Event(
                ^
infrastructure\core\autonomous_controller.py:127:22: error: Argument "type" to
"Event" has incompatible type "str"; expected "EventType"  [arg-type]
                    type="system_health_check",
                         ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\autonomous_controller.py:128:22: error: Argument "name" to
"Event" has incompatible type "str"; expected "EventName"  [arg-type]
                    name="system.health_issues",
                         ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\autonomous_controller.py:130:26: error: Argument "priority"
to "Event" has incompatible type
"infrastructure.messaging.optimized_event_bus.EventPriority"; expected
"domain.types.messaging_types.EventPriority"  [arg-type]
                    priority=EventPriority.HIGH,
                             ^~~~~~~~~~~~~~~~~~
infrastructure\core\autonomous_controller.py:396:16: error: Unsupported right
operand type for in ("object")  [operator]
                if strategy_name in self.system_state["active_strategies"]...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\autonomous_controller.py:397:17: error: "object" has no
attribute "remove"  [attr-defined]
                    self.system_state["active_strategies"].remove(strategy...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\autonomous_controller.py:526:17: error: Argument 1 to
"publish" of "EventBus" has incompatible type
"domain.types.messaging_types.Event"; expected
"infrastructure.messaging.optimized_event_bus.Event"  [arg-type]
                    Event(
                    ^
infrastructure\core\autonomous_controller.py:527:26: error: Argument "type" to
"Event" has incompatible type "str"; expected "EventType"  [arg-type]
                        type="system_error",
                             ^~~~~~~~~~~~~~
infrastructure\core\autonomous_controller.py:528:26: error: Argument "name" to
"Event" has incompatible type "str"; expected "EventName"  [arg-type]
                        name="system.error",
                             ^~~~~~~~~~~~~~
infrastructure\core\autonomous_controller.py:530:30: error: Argument "priority"
to "Event" has incompatible type
"infrastructure.messaging.optimized_event_bus.EventPriority"; expected
"domain.types.messaging_types.EventPriority"  [arg-type]
                        priority=EventPriority.CRITICAL,
                                 ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\portfolio\agent_portfolio.py:30:49: error: Argument 2 to
"__init__" of "BaseAgent" has incompatible type "PortfolioConfig | None";
expected
"Literal['market_maker', 'whale_analyzer', 'risk_manager', 'portfolio_optimizer', 'order_executor', 'news_analyzer', 'market_regime', 'strategy_agent', 'meta_controller', 'evolutionary_agent', 'social_media', 'entanglement_detector']"
 [arg-type]
            super().__init__("portfolio_optimizer", config)
                                                    ^~~~~~
infrastructure\agents\portfolio\agent_portfolio.py:33:61: error: Argument
"event_bus" to "PortfolioManager" has incompatible type
"infrastructure.messaging.optimized_event_bus.EventBus"; expected
"infrastructure.messaging.event_bus.EventBus"  [arg-type]
    ...f.portfolio_manager = PortfolioManager(event_bus=EventBus(), config={}...
                                                        ^~~~~~~~~~
infrastructure\agents\portfolio\agent_portfolio.py:35:51: error: Argument
"event_bus" to "RiskManager" has incompatible type
"infrastructure.messaging.optimized_event_bus.EventBus"; expected
"infrastructure.messaging.event_bus.EventBus"  [arg-type]
    ...       self.risk_manager = RiskManager(event_bus=EventBus(), config={}...
                                                        ^~~~~~~~~~
infrastructure\agents\portfolio\agent_portfolio.py:58:13: error: Property
"status" defined in "AgentState" is read-only  [misc]
                self.state.status = AgentStatus.HEALTHY
                ^~~~~~~~~~~~~~~~~
infrastructure\agents\portfolio\agent_portfolio.py:69:5: error: Return type
"Coroutine[Any, Any, dict[str, Any]]" of "process" incompatible with return type
"Coroutine[Any, Any, ProcessingResult]" in supertype "BaseAgent"  [override]
        async def process(self, data: Any) -> Dict[str, Any]:
        ^
tests\test_entanglement_detector_integration.py:11:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import (
    ^
tests\unit\test_autonomous_controller.py:111:9: error: "AutonomousController"
has no attribute "make_autonomous_decision"  [attr-defined]
            autonomous_controller.make_autonomous_decision = make_autonomo...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:114:26: error: "AutonomousController"
has no attribute "make_autonomous_decision"  [attr-defined]
            decision = await autonomous_controller.make_autonomous_decisio...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:145:9: error: "AutonomousController"
has no attribute "assess_risk"  [attr-defined]
            autonomous_controller.assess_risk = assess_risk
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:148:33: error: "AutonomousController"
has no attribute "assess_risk"  [attr-defined]
            risk_assessment = await autonomous_controller.assess_risk(port...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:186:9: error: "AutonomousController"
has no attribute "select_strategy"  [attr-defined]
            autonomous_controller.select_strategy = select_strategy
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:189:35: error: "AutonomousController"
has no attribute "select_strategy"  [attr-defined]
            selected_strategy = await autonomous_controller.select_strateg...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:218:9: error: "AutonomousController"
has no attribute "detect_market_regime"; maybe "_detect_market_regime"? 
[attr-defined]
            autonomous_controller.detect_market_regime = detect_market_reg...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:221:24: error: "AutonomousController"
has no attribute "detect_market_regime"; maybe "_detect_market_regime"? 
[attr-defined]
            regime = await autonomous_controller.detect_market_regime(mark...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:248:9: error: "AutonomousController"
has no attribute "update_performance_metrics"  [attr-defined]
            autonomous_controller.update_performance_metrics = update_perf...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:251:15: error: "AutonomousController"
has no attribute "update_performance_metrics"  [attr-defined]
            await autonomous_controller.update_performance_metrics(perform...
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:279:18: error: "type[EventType]" has
no attribute "MARKET_DATA"  [attr-defined]
                type=EventType.MARKET_DATA,
                     ^~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:280:18: error: Argument "name" to
"Event" has incompatible type "str"; expected "EventName"  [arg-type]
                name="market.update",
                     ^~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:289:9: error: "AutonomousController"
has no attribute "handle_event"  [attr-defined]
            autonomous_controller.handle_event = handle_event
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:292:24: error: "AutonomousController"
has no attribute "handle_event"  [attr-defined]
            result = await autonomous_controller.handle_event(test_event)
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:295:40: error: "type[EventType]" has
no attribute "MARKET_DATA"  [attr-defined]
            assert result["event_type"] == EventType.MARKET_DATA
                                           ^~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:313:9: error: Cannot assign to a
method  [method-assign]
            autonomous_controller._start_autonomous_loop = lambda: None
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:321:9: error: "AutonomousController"
has no attribute "_validate_config"  [attr-defined]
            autonomous_controller._validate_config = lambda: True
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:324:20: error: "AutonomousController"
has no attribute "_validate_config"  [attr-defined]
            is_valid = autonomous_controller._validate_config()
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:333:9: error: "AutonomousController"
has no attribute "optimize_performance"  [attr-defined]
            autonomous_controller.optimize_performance = optimize_performa...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:336:24: error: "AutonomousController"
has no attribute "optimize_performance"  [attr-defined]
            result = await autonomous_controller.optimize_performance()
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:348:9: error: "AutonomousController"
has no attribute "adaptive_learning"  [attr-defined]
            autonomous_controller.adaptive_learning = adaptive_learning
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:351:24: error: "AutonomousController"
has no attribute "adaptive_learning"  [attr-defined]
            result = await autonomous_controller.adaptive_learning()
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:359:9: error: "AutonomousController"
has no attribute "cleanup"  [attr-defined]
            autonomous_controller.cleanup = lambda: None
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_autonomous_controller.py:362:9: error: "AutonomousController"
has no attribute "cleanup"  [attr-defined]
            autonomous_controller.cleanup()
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shared\wavelet_tools.py:157:9: error: Dict entry 4 has incompatible type "str":
"signedinteger[Any]"; expected "str": "ndarray[Any, Any]"  [dict-item]
            "dominant_scale_idx": dominant_scale_idx,
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shared\wavelet_tools.py:238:23: error: Module has no attribute "cwt" 
[attr-defined]
        filtered_signal = signal.cwt(filtered_coeffs, scales, morlet2)
                          ^~~~~~~~~~
shared\wavelet_tools.py:238:59: error: Name "morlet2" is not defined 
[name-defined]
        filtered_signal = signal.cwt(filtered_coeffs, scales, morlet2)
                                                              ^~~~~~~
shared\metrics_analyzer.py:114:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\metrics_analyzer.py:115:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\metrics_analyzer.py:430:17: error: Unsupported target for indexed
assignment ("object")  [index]
                    report["summaries"][metric] = summary
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
shared\metrics_analyzer.py:434:21: error: Value of type "object" is not
indexable  [index]
                        report["anomalies_summary"]["by_type"][
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shared\metrics_analyzer.py:442:21: error: Value of type "object" is not
indexable  [index]
                        report["anomalies_summary"]["by_severity"][severit...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shared\metrics_analyzer.py:445:21: error: Value of type "object" is not
indexable  [index]
                        report["trends_summary"][summary.trend.direction.v...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
shared\metrics_analyzer.py:445:21: error: Unsupported target for indexed
assignment ("object")  [index]
                        report["trends_summary"][summary.trend.direction.v...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
shared\metrics_analyzer.py:448:17: error: Unsupported target for indexed
assignment ("object")  [index]
                    report["summaries"][metric] = {"error": str(e)}
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
shared\metrics_analyzer.py:449:9: error: Unsupported target for indexed
assignment ("object")  [index]
            report["anomalies_summary"]["total"] = total_anomalies
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shared\metrics_analyzer.py:484:20: error: "DataFrame" has no attribute "to_csv"
 [attr-defined]
                return df.to_csv(index=False)
                       ^~~~~~~~~
shared\metrics_analyzer.py:488:20: error: Incompatible types in assignment
(expression has type "dict[str, dict[str, list[dict[str, object]]]]", variable
has type "list[MetricPoint]")  [assignment]
                data = {
                       ^
infrastructure\simulation\market_simulator.py:209:13: error: "object" has no
attribute "mkdir"  [attr-defined]
                dir_path.mkdir(parents=True, exist_ok=True)
                ^~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:271:21: error: Unsupported
operand types for * ("object" and "float")  [operator]
                trend = self.market_state["trend_strength"] * np.random.no...
                        ^
infrastructure\simulation\market_simulator.py:272:24: error: Unsupported
operand types for * ("object" and "float")  [operator]
                mean_rev = self.market_state["mean_reversion"] * (
                           ^
infrastructure\simulation\market_simulator.py:273:45: error: Unsupported
operand types for - ("float" and "object")  [operator]
                    self.config.initial_price - self.market_state["price"]
                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:275:21: error: Unsupported
operand types for * ("object" and "float")  [operator]
                noise = self.market_state["noise_level"] * np.random.norma...
                        ^
infrastructure\simulation\market_simulator.py:288:25: error: Unsupported
operand types for * ("float" and "object")  [operator]
                movement *= self.market_state["volatility"]
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:302:23: error: Unsupported
operand types for * ("float" and "object")  [operator]
                volume *= self.market_state["liquidity_factor"]
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:304:13: error: Unsupported
operand types for * ("float" and "int")  [operator]
                volume *= 1 - self.market_state["market_impact"]
                ^
infrastructure\simulation\market_simulator.py:304:27: error: Unsupported
operand types for - ("int" and "object")  [operator]
                volume *= 1 - self.market_state["market_impact"]
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:342:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["SMA_20"] = talib.SMA(data["close"], timeperiod=20)
                ^~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:343:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["SMA_50"] = talib.SMA(data["close"], timeperiod=50)
                ^~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:344:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["SMA_200"] = talib.SMA(data["close"], timeperiod=200)
                ^~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:345:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["RSI"] = talib.RSI(data["close"], timeperiod=14)
                ^~~~~~~~~~~
infrastructure\simulation\market_simulator.py:346:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["MACD"], data["MACD_SIGNAL"], data["MACD_HIST"] = tal...
                ^~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:349:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["BBANDS_UPPER"], data["BBANDS_MIDDLE"], data["BBANDS_...
                ^~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:352:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["ATR"] = talib.ATR(
                ^~~~~~~~~~~
infrastructure\simulation\market_simulator.py:356:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["OBV"] = talib.OBV(data["close"], data["volume"])
                ^~~~~~~~~~~
infrastructure\simulation\market_simulator.py:357:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["AD"] = talib.AD(
                ^~~~~~~~~~
infrastructure\simulation\market_simulator.py:361:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["MOM"] = talib.MOM(data["close"], timeperiod=10)
                ^~~~~~~~~~~
infrastructure\simulation\market_simulator.py:362:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["ROC"] = talib.ROC(data["close"], timeperiod=10)
                ^~~~~~~~~~~
infrastructure\simulation\market_simulator.py:364:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["NATR"] = talib.NATR(
                ^~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:367:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["TRANGE"] = talib.TRANGE(data["high"], data["low"], d...
                ^~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:377:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["volatility"] = data["close"].pct_change().rolling(wi...
                ^~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:378:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["trend"] = (data["close"] - data["close"].shift(20)) ...
                ^~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:381:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["mean_reversion"] = (data["close"] - data["SMA_20"]) ...
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:392:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["regime"] = np.select(conditions, choices, default="n...
                ^~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:402:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["liquidity"] = data["volume"] * data["close"]
                ^~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:403:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["spread"] = (data["high"] - data["low"]) / data["clos...
                ^~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:405:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["volatility"] = data["close"].pct_change().rolling(wi...
                ^~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:407:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["trend"] = (data["close"] - data["close"].shift(20)) ...
                ^~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:411:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["market_quality"] = (
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:417:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["market_quality"] = (
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:429:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["base_impact"] = data["volume"] * data["close"] / dat...
                ^~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:437:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["regime_impact"] = data["regime"].map(regime_impact)
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:439:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["market_impact"] = data["base_impact"] * data["regime...
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:441:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["market_impact"] = (
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:453:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["autocorr"] = (
                ^~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:460:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["random_walk"] = (
                ^~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:467:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["market_efficiency"] = (
                ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:473:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["market_efficiency"] = (
                ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:485:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["volatility"] = data["close"].pct_change().rolling(wi...
                ^~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:487:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["trend"] = (data["close"] - data["close"].shift(20)) ...
                ^~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:491:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["mean_reversion"] = (data["close"] - data["SMA_20"]) ...
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:493:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["noise"] = (
                ^~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:500:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["liquidity"] = data["volume"] * data["close"]
                ^~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:502:13: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                data["market_impact"] = data["volume"] * data["close"] / d...
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:512:17: error: Unsupported target
for indexed assignment ("DataFrame")  [index]
                    data[col] = (data[col] - data[col].min()) / (
                    ^~~~~~~~~
infrastructure\simulation\market_simulator.py:541:13: error: "None" has no
attribute "fit"  [attr-defined]
                self.regime_model.fit(X)
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:654:9: error: "DataFrame" has no
attribute "to_csv"  [attr-defined]
            data.to_csv(path, index=False)
            ^~~~~~~~~~~
infrastructure\simulation\market_simulator.py:677:32: error: Incompatible types
in assignment (expression has type "datetime", variable has type "None") 
[assignment]
                self._start_time = datetime.now()
                                   ^~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:715:27: error: "_save_backup" of
"MarketSimulator" does not return a value (it only ever returns None) 
[func-returns-value]
                        await self._save_backup(pd.DataFrame(data), i)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:715:65: error: Argument 2 to
"_save_backup" of "MarketSimulator" has incompatible type "int"; expected "Path"
 [arg-type]
                        await self._save_backup(pd.DataFrame(data), i)
                                                                    ^
infrastructure\simulation\market_simulator.py:718:13: error: "DataFrame" has no
attribute "set_index"  [attr-defined]
                df.set_index("timestamp", inplace=True)
                ^~~~~~~~~~~~
infrastructure\simulation\market_simulator.py:732:19: error: "_save_results" of
"MarketSimulator" does not return a value (it only ever returns None) 
[func-returns-value]
                await self._save_results(metrics, self.config.data_dir / "...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\risk_analysis\risk_metrics.py:48:32: error: Unsupported
operand types for > ("int" and "Series")  [operator]
        downside_returns = returns[returns < 0]
                                   ^
infrastructure\services\risk_analysis\risk_metrics.py:60:26: error: "int" has
no attribute "cumprod"  [attr-defined]
        cumulative_returns = (1 + returns).cumprod()
                             ^~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\risk_metrics.py:60:31: error: Unsupported
operand types for + ("int" and "Series")  [operator]
        cumulative_returns = (1 + returns).cumprod()
                                  ^~~~~~~
infrastructure\services\risk_analysis\risk_metrics.py:78:20: error: "Series"
has no attribute "index"  [attr-defined]
        common_index = asset_returns.index.intersection(market_returns.ind...
                       ^~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\risk_metrics.py:81:21: error: "Series"
has no attribute "loc"; maybe "iloc"?  [attr-defined]
        asset_aligned = asset_returns.loc[common_index]
                        ^~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\risk_metrics.py:82:22: error: "Series"
has no attribute "loc"; maybe "iloc"?  [attr-defined]
        market_aligned = market_returns.loc[common_index]
                         ^~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis\risk_metrics.py:110:32: error:
Unsupported operand types for > ("int" and "Series")  [operator]
        downside_returns = returns[returns < 0]
                                   ^
infrastructure\services\risk_analysis\risk_metrics.py:118:34: error:
Unsupported operand types for < ("int" and "Series")  [operator]
            upside_returns = returns[returns > 0]
                                     ^
infrastructure\services\risk_analysis\risk_metrics.py:125:21: error:
Unsupported operand types for < ("int" and "Series")  [operator]
        gains = returns[returns > 0]
                        ^
infrastructure\services\risk_analysis\risk_metrics.py:126:22: error:
Unsupported operand types for > ("int" and "Series")  [operator]
        losses = returns[returns < 0]
                         ^
infrastructure\services\risk_analysis\risk_metrics.py:133:21: error:
Unsupported operand types for < ("int" and "Series")  [operator]
        gains = returns[returns > 0]
                        ^
infrastructure\services\risk_analysis\risk_metrics.py:134:22: error:
Unsupported operand types for > ("int" and "Series")  [operator]
        losses = returns[returns < 0]
                         ^
infrastructure\services\risk_analysis\risk_metrics.py:142:24: error: "Series"
has no attribute "sum"  [attr-defined]
            total_return = returns.sum()
                           ^~~~~~~~~~~
infrastructure\services\risk_analysis\risk_metrics.py:166:28: error:
Unsupported operand types for >= ("float" and "Series")  [operator]
        tail_returns = returns[returns <= var]
                               ^
infrastructure\ml_services\pattern_discovery.py:122:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["returns"] = df["close"].pct_change()
                ^~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:123:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["log_returns"] = np.log1p(features["returns"])
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:124:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volatility"] = features["returns"].rolling(20).s...
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:126:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["rsi"] = ta.rsi(df["close"])
                ^~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:127:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["macd"], features["macd_signal"], _ = ta.macd(df[...
                ^~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:128:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["bb_upper"], features["bb_middle"], features["bb_...
                ^~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:131:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["atr"] = ta.atr(df["high"], df["low"], df["close"...
                ^~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:132:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["adx"] = ta.adx(df["high"], df["low"], df["close"...
                ^~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:134:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volume_ma"] = df["volume"].rolling(20).mean()
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:135:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volume_std"] = df["volume"].rolling(20).std()
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:136:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volume_ratio"] = df["volume"] / features["volume...
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:138:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["momentum"] = ta.mom(df["close"], timeperiod=10)
                ^~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:139:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["roc"] = ta.roc(df["close"], timeperiod=10)
                ^~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:141:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["high_low_ratio"] = df["high"] / df["low"]
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:142:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["close_open_ratio"] = df["close"] / df["open"]
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:144:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["trend"] = ta.adx(df["high"], df["low"], df["clos...
                ^~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:145:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["trend_strength"] = abs(features["trend"])
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:149:38: error: "DataFrame" has
no attribute "fillna"  [attr-defined]
                    scaler.fit_transform(features.fillna(0)),
                                         ^~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:168:22: error: Incompatible
types in assignment (expression has type "float", variable has type "Series") 
[assignment]
                series = (series - series.mean()) / series.std()
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:168:23: error: Unsupported
operand types for - ("Series" and "float")  [operator]
                series = (series - series.mean()) / series.std()
                          ^
infrastructure\ml_services\pattern_discovery.py:171:17: error: Argument 1 to
"find_peaks" has incompatible type "Callable[[], ndarray[Any, Any]]"; expected
"CanArrayND[generic, tuple[int, ...]] | Sequence[complex | bytes | str | generic | CanArray0D[generic]]"
 [arg-type]
                    series.values,
                    ^~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:176:17: error: Unsupported
operand type for unary - ("Callable[[], ndarray[Any, Any]]")  [operator]
                    -series.values,
                    ^~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:258:35: error: "DataFrame" has
no attribute "iloc"  [attr-defined]
                            pattern = features.iloc[i : i + length][column...
                                      ^~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:280:41: error: Incompatible
types in assignment (expression has type "dict[str, dict[str, Any]]", target has
type "list[Pattern]")  [assignment]
                    self.patterns[column] = sorted_patterns
                                            ^~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:282:40: error: Incompatible
types in assignment (expression has type "dict[str, Any]", target has type
"PatternMetrics")  [assignment]
                    self.metrics[column] = PatternMetrics(
                                           ^
infrastructure\ml_services\pattern_discovery.py:328:49: error: "list[Pattern]"
has no attribute "items"  [attr-defined]
                    for pattern_id, pattern_data in patterns.items():
                                                    ^~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:366:20: error: Incompatible
return value type (got "PatternMetrics | dict[str, Any]", expected
"dict[str, Any]")  [return-value]
                return self.metrics.get(column, {})
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:429:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["rsi"] = ta.rsi(data["close"])
                ^~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:430:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["macd"], features["macd_signal"], _ = ta.macd(dat...
                ^~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:431:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["bb_upper"], features["bb_middle"], features["bb_...
                ^~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:434:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["atr"] = ta.atr(data["high"], data["low"], data["...
                ^~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:436:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["body_size"] = abs(data["close"] - data["open"])
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:437:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["upper_shadow"] = data["high"] - data[["open", "c...
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:440:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["lower_shadow"] = data[["open", "close"]].min(axi...
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:441:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["is_bullish"] = (data["close"] > data["open"]).as...
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:443:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volume_ma"] = ta.sma(data["volume"], timeperiod=...
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:444:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volume_ratio"] = data["volume"] / features["volu...
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:446:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volatility"] = data["close"].pct_change().rollin...
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:448:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["trend"] = ta.adx(data["high"], data["low"], data...
                ^~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:523:28: error: "DataFrame" has
no attribute "corr"  [attr-defined]
                correlations = data.corr().abs()
                               ^~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:760:69: error: Argument 2 to
"spearmanr" has incompatible type "Series"; expected
"CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]] | None"
 [arg-type]
    ...               correlation, _ = stats.spearmanr(features[col], target)
                                                                      ^~~~~~
infrastructure\ml_services\pattern_discovery.py:779:45: error: Incompatible
types in assignment (expression has type "dict[str, dict[Any, object]]", target
has type "dict[str, float]")  [assignment]
                self.importance_cache[symbol] = importance_scores
                                                ^~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:780:20: error: Incompatible
return value type (got "dict[str, dict[Any, object]]", expected
"dict[str, float]")  [return-value]
                return importance_scores
                       ^~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:817:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"rsi_{timeframe}"] = ta.rsi(data["close"])
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:818:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"ema_50_{timeframe}"] = ta.sma(data["close"], ti...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:819:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"ema_200_{timeframe}"] = ta.sma(data["close"], t...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:820:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"atr_{timeframe}"] = ta.atr(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:825:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"bb_upper_{timeframe}"] = bb_upper
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:826:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"bb_middle_{timeframe}"] = bb_middle
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:827:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"bb_lower_{timeframe}"] = bb_lower
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:829:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"vwap_{timeframe}"] = ta.vwap(data)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:830:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"volume_acc_{timeframe}"] = ta.volume_accelerati...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:832:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"price_velocity_{timeframe}"] = data["close"].pc...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:833:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"rsi_roc_{timeframe}"] = features[f"rsi_{timefra...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:834:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"bb_width_{timeframe}"] = (bb_upper - bb_lower) ...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:835:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features[f"volume_ratio_{timeframe}"] = (
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:856:24: error: "DataFrame" has
no attribute "copy"  [attr-defined]
                combined = base_features.copy()
                           ^~~~~~~~~~~~~~~~~~
infrastructure\ml_services\pattern_discovery.py:861:33: error: "DataFrame" has
no attribute "resample"  [attr-defined]
                        resampled = tf_features.resample(base_timeframe).l...
                                    ^~~~~~~~~~~~~~~~~~~~
infrastructure\entity_system\experiments\statistics.py:120:23: error:
Incompatible types in assignment (expression has type
"float | floating[_64Bit]", variable has type "float")  [assignment]
                z_alpha = stats.norm.ppf(1 - alpha / 2)
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\entity_system\experiments\runner.py:127:24: error: Need type
annotation for "first_result"  [var-annotated]
            first_result = next(iter(experiment.statistical_results.values...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\entity_system\experiments\runner.py:206:9: error: Incompatible
types in assignment (expression has type "float", variable has type "int") 
[assignment]
            achieved_improvement /= total_metrics if total_metrics > 0 els...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\wavelet_tools.py:34:46: error: Incompatible default for
argument "scales" (default has type "None", argument has type
"ndarray[Any, Any] | list[float]")  [assignment]
        scales: Union[np.ndarray, List[float]] = None,
                                                 ^~~~
infrastructure\core\wavelet_tools.py:34:46: note: PEP 484 prohibits implicit Optional. Accordingly, mypy has changed its default to no_implicit_optional=True
infrastructure\core\wavelet_tools.py:34:46: note: Use https://github.com/hauntsaninja/no_implicit_optional to automatically upgrade your codebase
infrastructure\core\efficiency_validator.py:145:46: error: Incompatible types
in assignment (expression has type "floating[Any]", variable has type "float") 
[assignment]
                candidate.proposed_performance = np.mean(test_results)
                                                 ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\efficiency_validator.py:269:39: error: "DataFrame" has no
attribute "values"  [attr-defined]
                    performance = np.mean(processed_data.values) + np.rand...
                                          ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\efficiency_validator.py:270:24: error: Incompatible return
value type (got "float | SupportsDunderLT[Any] | SupportsDunderGT[Any]",
expected "float")  [return-value]
                    return max(0.0, min(1.0, performance))
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\efficiency_validator.py:304:20: error: Incompatible return
value type (got
"tuple[float, float | floating[_64Bit | Any] | ndarray[Any, dtype[floating[Any]]]]",
expected "tuple[float, float]")  [return-value]
                return improvement, significance
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\efficiency_validator.py:329:20: error: Incompatible return
value type (got "float | SupportsDunderLT[Any] | SupportsDunderGT[Any]",
expected "float")  [return-value]
                return max(0.0, min(1.0, confidence))
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:74:26: error: "Series" has no
attribute "corr"  [attr-defined]
                corr = float(series1.corr(series2))
                             ^~~~~~~~~~~~
infrastructure\core\correlation_chain.py:76:41: error: Argument 1 to "pearsonr"
has incompatible type "Series"; expected
"CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]"
 [arg-type]
                _, p_value = stats.pearsonr(series1.dropna(), series2.drop...
                                            ^~~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:76:41: note: "Series" is missing following "CanArrayND" protocol member:
infrastructure\core\correlation_chain.py:76:41: note:     __array__
infrastructure\core\correlation_chain.py:76:41: note: "Series" is missing following "SequenceND" protocol member:
infrastructure\core\correlation_chain.py:76:41: note:     index
infrastructure\core\correlation_chain.py:76:41: note: Following member(s) of "Series" have conflicts:
infrastructure\core\correlation_chain.py:76:41: note:     Expected:
infrastructure\core\correlation_chain.py:76:41: note:         def __contains__(self, object, /) -> bool
infrastructure\core\correlation_chain.py:76:41: note:     Got:
infrastructure\core\correlation_chain.py:76:41: note:         def __contains__(self, str, /) -> bool
infrastructure\core\correlation_chain.py:76:41: note:     Expected:
infrastructure\core\correlation_chain.py:76:41: note:         def __contains__(self, object, /) -> bool
infrastructure\core\correlation_chain.py:76:41: note:     Got:
infrastructure\core\correlation_chain.py:76:41: note:         def __contains__(self, str, /) -> bool
infrastructure\core\correlation_chain.py:76:59: error: Argument 2 to "pearsonr"
has incompatible type "Series"; expected
"CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]"
 [arg-type]
    ...       _, p_value = stats.pearsonr(series1.dropna(), series2.dropna())
                                                            ^~~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:76:59: note:     Expected:
infrastructure\core\correlation_chain.py:76:59: note:         def __contains__(self, object, /) -> bool
infrastructure\core\correlation_chain.py:76:59: note:     Got:
infrastructure\core\correlation_chain.py:76:59: note:         def __contains__(self, str, /) -> bool
infrastructure\core\correlation_chain.py:76:59: note:     Expected:
infrastructure\core\correlation_chain.py:76:59: note:         def __contains__(self, object, /) -> bool
infrastructure\core\correlation_chain.py:76:59: note:     Got:
infrastructure\core\correlation_chain.py:76:59: note:         def __contains__(self, str, /) -> bool
infrastructure\core\correlation_chain.py:138:25: error: "DataFrame" has no
attribute "loc"  [attr-defined]
                            matrix.loc[pair1, pair2] = float(metrics.corre...
                            ^~~~~~~~~~
infrastructure\core\correlation_chain.py:140:25: error: "DataFrame" has no
attribute "loc"  [attr-defined]
                            matrix.loc[pair1, pair2] = 1.0
                            ^~~~~~~~~~
infrastructure\core\correlation_chain.py:160:20: error: Module has no attribute
"concat"  [attr-defined]
                data = pd.concat([series1, series2], axis=1)
                       ^~~~~~~~~
infrastructure\core\correlation_chain.py:178:24: error: "Series" has no
attribute "name"  [attr-defined]
                    return f"{series1.name} leads {series2.name} by {lag}"
                           ^~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:180:24: error: "Series" has no
attribute "name"  [attr-defined]
                    return f"{series2.name} leads {series1.name} by {abs(l...
                           ^~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:197:20: error: Incompatible return
value type (got "signedinteger[Any]", expected "int")  [return-value]
                return lag
                       ^~~
infrastructure\core\correlation_chain.py:212:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    window1 = series1.iloc[i : i + window_size]
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:213:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    window2 = series2.iloc[i : i + window_size]
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:250:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    window1 = series1.iloc[i : i + window_size]
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:251:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    window2 = series2.iloc[i : i + window_size]
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:254:28: error: Module has no attribute
"isna"  [attr-defined]
                        if not pd.isna(corr):
                               ^~~~~~~
infrastructure\core\correlation_chain.py:274:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    window1 = series1.iloc[i : i + window_size]
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:275:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    window2 = series2.iloc[i : i + window_size]
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\correlation_chain.py:278:28: error: Module has no attribute
"isna"  [attr-defined]
                        if not pd.isna(corr):
                               ^~~~~~~
infrastructure\agents\risk\calculators.py:19:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\agents\risk\calculators.py:20:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\agents\risk\calculators.py:108:29: error: No overload variant of
"max" matches argument types "float", "object"  [call-overload]
                return min(1.0, max(0.0, var))
                                ^~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:108:29: note: Possible overload variants:
infrastructure\agents\risk\calculators.py:108:29: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] max(SupportsRichComparisonT, SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = ...) -> SupportsRichComparisonT
infrastructure\agents\risk\calculators.py:108:29: note:     def [_T] max(_T, _T, /, *_args: _T, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
infrastructure\agents\risk\calculators.py:108:29: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any]] max(Iterable[SupportsRichComparisonT], /, *, key: None = ...) -> SupportsRichComparisonT
infrastructure\agents\risk\calculators.py:108:29: note:     def [_T] max(Iterable[_T], /, *, key: Callable[[_T], SupportsDunderLT[Any] | SupportsDunderGT[Any]]) -> _T
infrastructure\agents\risk\calculators.py:108:29: note:     def [SupportsRichComparisonT: SupportsDunderLT[Any] | SupportsDunderGT[Any], _T] max(Iterable[SupportsRichComparisonT], /, *, key: None = ..., default: _T) -> SupportsRichComparisonT | _T
infrastructure\agents\risk\calculators.py:108:29: note:     def [_T1, _T2] max(Iterable[_T1], /, *, key: Callable[[_T1], SupportsDunderLT[Any] | SupportsDunderGT[Any]], default: _T2) -> _T1 | _T2
infrastructure\agents\risk\calculators.py:125:34: error: "int" has no attribute
"cumprod"  [attr-defined]
                cumulative_returns = (1 + equity_curve.pct_change()).cumpr...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:125:39: error: Unsupported operand
types for + ("int" and "Series")  [operator]
                cumulative_returns = (1 + equity_curve.pct_change()).cumpr...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:148:40: error: Unsupported operand
types for < ("int" and "Series")  [operator]
                positive_returns = returns[returns > 0]
                                           ^
infrastructure\agents\risk\calculators.py:149:40: error: Unsupported operand
types for > ("int" and "Series")  [operator]
                negative_returns = returns[returns < 0]
                                           ^
infrastructure\agents\risk\calculators.py:180:26: error: "Series" has no
attribute "rolling"  [attr-defined]
                volatility = returns.rolling(window=window).std().iloc[-1]...
                             ^~~~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:193:30: error: Unsupported operand
types for - ("Series" and "float")  [operator]
                excess_returns = returns - risk_free_rate / 252
                                 ^
infrastructure\agents\risk\calculators.py:194:16: error: "float" has no
attribute "std"  [attr-defined]
                if excess_returns.std() == 0:
                   ^~~~~~~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:196:22: error: "float" has no
attribute "mean"  [attr-defined]
                sharpe = excess_returns.mean() / excess_returns.std() * np...
                         ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:196:46: error: "float" has no
attribute "std"  [attr-defined]
                sharpe = excess_returns.mean() / excess_returns.std() * np...
                                                 ^~~~~~~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:209:30: error: Unsupported operand
types for - ("Series" and "float")  [operator]
                excess_returns = returns - risk_free_rate / 252
                                 ^
infrastructure\agents\risk\calculators.py:210:32: error: Value of type "float"
is not indexable  [index]
                downside_returns = excess_returns[excess_returns < 0]
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:213:23: error: "float" has no
attribute "mean"  [attr-defined]
                sortino = excess_returns.mean() / downside_returns.std() *...
                          ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:388:19: error: No overload variant of
"percentile" matches argument types "Series", "float"  [call-overload]
                var = np.percentile(returns, (1 - confidence) * 100)
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:388:19: note: Possible overload variants:
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> floating[Any]
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> complexfloating[Any, Any]
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> timedelta64
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[datetime64]] | _NestedSequence[_SupportsArray[dtype[datetime64]]], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> datetime64
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> Any
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[floating[Any]]]
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[complexfloating[Any, Any]]]
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[timedelta64]]
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[datetime64]] | _NestedSequence[_SupportsArray[dtype[datetime64]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[datetime64]]
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[object_]]
infrastructure\agents\risk\calculators.py:388:19: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: bool = ...) -> Any
infrastructure\agents\risk\calculators.py:388:19: note:     def [_ArrayType: ndarray[Any, dtype[Any]]] percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: _ArrayType = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: bool = ...) -> _ArrayType
infrastructure\agents\risk\calculators.py:408:32: error: "Series" has no
attribute "quantile"  [attr-defined]
                tail1 = returns1 < returns1.quantile(threshold)
                                   ^~~~~~~~~~~~~~~~~
infrastructure\agents\risk\calculators.py:409:32: error: "Series" has no
attribute "quantile"  [attr-defined]
                tail2 = returns2 < returns2.quantile(threshold)
                                   ^~~~~~~~~~~~~~~~~
examples\strategy_usage.py:44:14: error: Argument "name" to "Strategy" has
incompatible type "object"; expected "str"  [arg-type]
            name=config["name"],
                 ^~~~~~~~~~~~~~
examples\strategy_usage.py:45:21: error: Argument "description" to "Strategy"
has incompatible type "object"; expected "str"  [arg-type]
            description=config["description"],
                        ^~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:46:23: error: Argument "strategy_type" to "Strategy"
has incompatible type "object"; expected "StrategyType"  [arg-type]
            strategy_type=config["strategy_type"],
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:47:23: error: Argument "trading_pairs" to "Strategy"
has incompatible type "object"; expected "list[str]"  [arg-type]
            trading_pairs=config["trading_pairs"]
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:51:43: error: Argument 1 to "update_parameters" of
"StrategyParameters" has incompatible type "object"; expected
"dict[str, str | int | float | Decimal | bool | list[str] | dict[str, str | int | float | Decimal | bool]]"
 [arg-type]
        strategy.parameters.update_parameters(config["parameters"])
                                              ^~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:80:14: error: Argument "name" to "Strategy" has
incompatible type "object"; expected "str"  [arg-type]
            name=config["name"],
                 ^~~~~~~~~~~~~~
examples\strategy_usage.py:81:21: error: Argument "description" to "Strategy"
has incompatible type "object"; expected "str"  [arg-type]
            description=config["description"],
                        ^~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:82:23: error: Argument "strategy_type" to "Strategy"
has incompatible type "object"; expected "StrategyType"  [arg-type]
            strategy_type=config["strategy_type"],
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:83:23: error: Argument "trading_pairs" to "Strategy"
has incompatible type "object"; expected "list[str]"  [arg-type]
            trading_pairs=config["trading_pairs"]
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:86:43: error: Argument 1 to "update_parameters" of
"StrategyParameters" has incompatible type "object"; expected
"dict[str, str | int | float | Decimal | bool | list[str] | dict[str, str | int | float | Decimal | bool]]"
 [arg-type]
        strategy.parameters.update_parameters(config["parameters"])
                                              ^~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:115:14: error: Argument "name" to "Strategy" has
incompatible type "object"; expected "str"  [arg-type]
            name=config["name"],
                 ^~~~~~~~~~~~~~
examples\strategy_usage.py:116:21: error: Argument "description" to "Strategy"
has incompatible type "object"; expected "str"  [arg-type]
            description=config["description"],
                        ^~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:117:23: error: Argument "strategy_type" to
"Strategy" has incompatible type "object"; expected "StrategyType"  [arg-type]
            strategy_type=config["strategy_type"],
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:118:23: error: Argument "trading_pairs" to
"Strategy" has incompatible type "object"; expected "list[str]"  [arg-type]
            trading_pairs=config["trading_pairs"]
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:121:43: error: Argument 1 to "update_parameters" of
"StrategyParameters" has incompatible type "object"; expected
"dict[str, str | int | float | Decimal | bool | list[str] | dict[str, str | int | float | Decimal | bool]]"
 [arg-type]
        strategy.parameters.update_parameters(config["parameters"])
                                              ^~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:150:14: error: Argument "name" to "Strategy" has
incompatible type "object"; expected "str"  [arg-type]
            name=config["name"],
                 ^~~~~~~~~~~~~~
examples\strategy_usage.py:151:21: error: Argument "description" to "Strategy"
has incompatible type "object"; expected "str"  [arg-type]
            description=config["description"],
                        ^~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:152:23: error: Argument "strategy_type" to
"Strategy" has incompatible type "object"; expected "StrategyType"  [arg-type]
            strategy_type=config["strategy_type"],
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:153:23: error: Argument "trading_pairs" to
"Strategy" has incompatible type "object"; expected "list[str]"  [arg-type]
            trading_pairs=config["trading_pairs"]
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:156:43: error: Argument 1 to "update_parameters" of
"StrategyParameters" has incompatible type "object"; expected
"dict[str, str | int | float | Decimal | bool | list[str] | dict[str, str | int | float | Decimal | bool]]"
 [arg-type]
        strategy.parameters.update_parameters(config["parameters"])
                                              ^~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:185:14: error: Argument "name" to "Strategy" has
incompatible type "object"; expected "str"  [arg-type]
            name=config["name"],
                 ^~~~~~~~~~~~~~
examples\strategy_usage.py:186:21: error: Argument "description" to "Strategy"
has incompatible type "object"; expected "str"  [arg-type]
            description=config["description"],
                        ^~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:187:23: error: Argument "strategy_type" to
"Strategy" has incompatible type "object"; expected "StrategyType"  [arg-type]
            strategy_type=config["strategy_type"],
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:188:23: error: Argument "trading_pairs" to
"Strategy" has incompatible type "object"; expected "list[str]"  [arg-type]
            trading_pairs=config["trading_pairs"]
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:191:43: error: Argument 1 to "update_parameters" of
"StrategyParameters" has incompatible type "object"; expected
"dict[str, str | int | float | Decimal | bool | list[str] | dict[str, str | int | float | Decimal | bool]]"
 [arg-type]
        strategy.parameters.update_parameters(config["parameters"])
                                              ^~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:220:14: error: Argument "name" to "Strategy" has
incompatible type "object"; expected "str"  [arg-type]
            name=config["name"],
                 ^~~~~~~~~~~~~~
examples\strategy_usage.py:221:21: error: Argument "description" to "Strategy"
has incompatible type "object"; expected "str"  [arg-type]
            description=config["description"],
                        ^~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:222:23: error: Argument "strategy_type" to
"Strategy" has incompatible type "object"; expected "StrategyType"  [arg-type]
            strategy_type=config["strategy_type"],
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:223:23: error: Argument "trading_pairs" to
"Strategy" has incompatible type "object"; expected "list[str]"  [arg-type]
            trading_pairs=config["trading_pairs"]
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:226:43: error: Argument 1 to "update_parameters" of
"StrategyParameters" has incompatible type "object"; expected
"dict[str, str | int | float | Decimal | bool | list[str] | dict[str, str | int | float | Decimal | bool]]"
 [arg-type]
        strategy.parameters.update_parameters(config["parameters"])
                                              ^~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:255:14: error: Argument "name" to "Strategy" has
incompatible type "object"; expected "str"  [arg-type]
            name=config["name"],
                 ^~~~~~~~~~~~~~
examples\strategy_usage.py:256:21: error: Argument "description" to "Strategy"
has incompatible type "object"; expected "str"  [arg-type]
            description=config["description"],
                        ^~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:257:23: error: Argument "strategy_type" to
"Strategy" has incompatible type "object"; expected "StrategyType"  [arg-type]
            strategy_type=config["strategy_type"],
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:258:23: error: Argument "trading_pairs" to
"Strategy" has incompatible type "object"; expected "list[str]"  [arg-type]
            trading_pairs=config["trading_pairs"]
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:261:43: error: Argument 1 to "update_parameters" of
"StrategyParameters" has incompatible type "object"; expected
"dict[str, str | int | float | Decimal | bool | list[str] | dict[str, str | int | float | Decimal | bool]]"
 [arg-type]
        strategy.parameters.update_parameters(config["parameters"])
                                              ^~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:290:14: error: Argument "name" to "Strategy" has
incompatible type "object"; expected "str"  [arg-type]
            name=config["name"],
                 ^~~~~~~~~~~~~~
examples\strategy_usage.py:291:21: error: Argument "description" to "Strategy"
has incompatible type "object"; expected "str"  [arg-type]
            description=config["description"],
                        ^~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:292:23: error: Argument "strategy_type" to
"Strategy" has incompatible type "object"; expected "StrategyType"  [arg-type]
            strategy_type=config["strategy_type"],
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:293:23: error: Argument "trading_pairs" to
"Strategy" has incompatible type "object"; expected "list[str]"  [arg-type]
            trading_pairs=config["trading_pairs"]
                          ^~~~~~~~~~~~~~~~~~~~~~~
examples\strategy_usage.py:296:43: error: Argument 1 to "update_parameters" of
"StrategyParameters" has incompatible type "object"; expected
"dict[str, str | int | float | Decimal | bool | list[str] | dict[str, str | int | float | Decimal | bool]]"
 [arg-type]
        strategy.parameters.update_parameters(config["parameters"])
                                              ^~~~~~~~~~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:170:18: error: Module has no
attribute "concat"  [attr-defined]
                tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
                     ^~~~~~~~~
domain\symbols\market_phase_classifier.py:431:35: error: Unsupported operand
type for unary - ("Callable[[], ndarray[Any, Any]]")  [operator]
                peaks, _ = find_peaks(-low.values, distance=5, prominence=...
                                      ^~~~~~~~~~~
domain\symbols\market_phase_classifier.py:437:30: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    return float(low.iloc[recent_peaks[-1]])
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:438:26: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                return float(low.iloc[peaks[-1]])
                             ^~~~~~~~~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:449:35: error: Argument 1 to
"find_peaks" has incompatible type "Callable[[], ndarray[Any, Any]]"; expected
"CanArrayND[generic, tuple[int, ...]] | Sequence[complex | bytes | str | generic | CanArray0D[generic]]"
 [arg-type]
                peaks, _ = find_peaks(high.values, distance=5, prominence=...
                                      ^~~~~~~~~~~
domain\symbols\market_phase_classifier.py:455:30: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                    return float(high.iloc[recent_peaks[-1]])
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:456:26: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                return float(high.iloc[peaks[-1]])
                             ^~~~~~~~~~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:468:39: error: No overload variant of
"linregress" matches argument types "ndarray[Any, dtype[signedinteger[Any]]]",
"Callable[[], ndarray[Any, Any]]"  [call-overload]
                slope, _, r_value, _, _ = stats.linregress(x, close.values...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:468:39: note: Possible overload variants:
domain\symbols\market_phase_classifier.py:468:39: note:     def linregress(x: CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], y: CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], alternative: Literal['two-sided', 'less', 'greater'] = ...) -> LinregressResult
domain\symbols\market_phase_classifier.py:468:39: note:     def linregress(x: CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], y: None = ..., alternative: Literal['two-sided', 'less', 'greater'] = ...) -> LinregressResult
domain\symbols\market_phase_classifier.py:483:39: error: No overload variant of
"linregress" matches argument types "ndarray[Any, dtype[signedinteger[Any]]]",
"Callable[[], ndarray[Any, Any]]"  [call-overload]
                slope, _, r_value, _, _ = stats.linregress(x, volume.value...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:483:39: note: Possible overload variants:
domain\symbols\market_phase_classifier.py:483:39: note:     def linregress(x: CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], y: CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], alternative: Literal['two-sided', 'less', 'greater'] = ...) -> LinregressResult
domain\symbols\market_phase_classifier.py:483:39: note:     def linregress(x: CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], y: None = ..., alternative: Literal['two-sided', 'less', 'greater'] = ...) -> LinregressResult
domain\symbols\market_phase_classifier.py:511:27: error: "Series" has no
attribute "rolling"  [attr-defined]
                mean_volume = volume.rolling(window=20).mean().iloc[-1]
                              ^~~~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:512:26: error: "Series" has no
attribute "rolling"  [attr-defined]
                std_volume = volume.rolling(window=20).std().iloc[-1]
                             ^~~~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:515:30: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                current_volume = volume.iloc[-1]
                                 ^~~~~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:531:39: error: No overload variant of
"linregress" matches argument types "ndarray[Any, dtype[signedinteger[Any]]]",
"Callable[[], ndarray[Any, Any]]"  [call-overload]
                slope, _, r_value, _, _ = stats.linregress(x, atr.dropna()...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
domain\symbols\market_phase_classifier.py:531:39: note: Possible overload variants:
domain\symbols\market_phase_classifier.py:531:39: note:     def linregress(x: CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], y: CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], alternative: Literal['two-sided', 'less', 'greater'] = ...) -> LinregressResult
domain\symbols\market_phase_classifier.py:531:39: note:     def linregress(x: CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | SequenceND[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], y: None = ..., alternative: Literal['two-sided', 'less', 'greater'] = ...) -> LinregressResult
domain\symbols\market_phase_classifier.py:545:27: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                current_atr = atr.iloc[-1]
                              ^~~~~~~~~~~~
domain\symbols\market_phase_classifier.py:546:30: error: "Series" has no
attribute "rolling"  [attr-defined]
                historical_atr = atr.rolling(window=20).mean().iloc[-1]
                                 ^~~~~~~~~~~
domain\strategies\validators.py:255:14: error: Cannot use isinstance() with
NewType type  [misc]
            elif isinstance(risk_level, RiskLevel):
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\strategies\strategy_interface.py:571:31: error: "type[SignalType]" has
no attribute "STRONG_BUY"  [attr-defined]
                    signal_type = SignalType.STRONG_BUY
                                  ^~~~~~~~~~~~~~~~~~~~~
domain\strategies\strategy_interface.py:576:31: error: "type[SignalType]" has
no attribute "STRONG_SELL"  [attr-defined]
                    signal_type = SignalType.STRONG_SELL
                                  ^~~~~~~~~~~~~~~~~~~~~~
domain\services\correlation_chain.py:245:21: error: "DataFrame" has no
attribute "loc"  [attr-defined]
                        lag_matrix.loc[asset1, asset2] = 0
                        ^~~~~~~~~~~~~~
domain\services\correlation_chain.py:250:21: error: "DataFrame" has no
attribute "loc"  [attr-defined]
                        lag_matrix.loc[asset1, asset2] = lag
                        ^~~~~~~~~~~~~~
domain\services\correlation_chain.py:265:30: error: "DataFrame" has no
attribute "loc"  [attr-defined]
                    corr_value = self.correlation_matrix.loc[symbol1, symb...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\correlation_chain.py:303:20: error: "DataFrame" has no
attribute "mean"  [attr-defined]
            avg_lags = self.lag_matrix.mean()
                       ^~~~~~~~~~~~~~~~~~~~
domain\services\correlation_chain.py:318:35: error: Argument 1 to "abs" has
incompatible type "DataFrame"; expected "SupportsAbs[Never]"  [arg-type]
            distance_matrix = 1 - abs(self.correlation_matrix)
                                      ^~~~~~~~~~~~~~~~~~~~~~~
domain\services\correlation_chain.py:336:30: error: "DataFrame" has no
attribute "loc"  [attr-defined]
                    group_corr = self.correlation_matrix.loc[group, group]
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\correlation_chain.py:360:18: error: "DataFrame" has no
attribute "values"  [attr-defined]
            values = self.correlation_matrix.values
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\services\correlation_chain.py:374:26: error: "DataFrame" has no
attribute "values"  [attr-defined]
                lag_values = self.lag_matrix.values
                             ^~~~~~~~~~~~~~~~~~~~~~
domain\services\correlation_chain.py:410:49: error: Unsupported operand types
for > ("float" and "Series")  [operator]
                    breakdown_points = rolling_corr[rolling_corr < thresho...
                                                    ^
domain\repositories\strategy_repository.py:119:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\strategy_repository.py:120:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\strategy_repository.py:121:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\strategy_protocol.py:172:20: error: Incompatible return value
type (got "Decimal | None", expected "float | None")  [return-value]
                return reward / risk if risk > 0 else None
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\protocols\strategy_protocol.py:306:62: error: Unsupported operand types
for < ("float" and "None")  [operator]
    ...rn self.success and self.status == "partial" and 0.0 < self.fill_perce...
                                                        ^
domain\protocols\strategy_protocol.py:306:62: note: Right operand is of type "float | None"
domain\protocols\strategy_protocol.py:306:62: error: Unsupported operand types
for > ("float" and "None")  [operator]
    ...rn self.success and self.status == "partial" and 0.0 < self.fill_perce...
                                                        ^
domain\protocols\strategy_protocol.py:306:62: note: Left operand is of type "float | None"
domain\protocols\strategy_protocol.py:583:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\strategy_protocol.py:584:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\strategy_protocol.py:585:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\strategy_protocol.py:586:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\strategy_protocol.py:1196:12: error: "Series" has no attribute
"shape"  [attr-defined]
            if returns.shape[0] < 2:
               ^~~~~~~~~~~~~
domain\protocols\strategy_protocol.py:1198:26: error: "Series" has no attribute
"astype"  [attr-defined]
            excess_returns = returns.astype(np.float64) - risk_free_rate /...
                             ^~~~~~~~~~~~~~
domain\protocols\strategy_protocol.py:1206:12: error: "Series" has no attribute
"shape"  [attr-defined]
            if equity_curve.shape[0] < 2:
               ^~~~~~~~~~~~~~~~~~
domain\protocols\strategy_protocol.py:1208:23: error: "Series" has no attribute
"expanding"  [attr-defined]
            rolling_max = equity_curve.expanding().max()
                          ^~~~~~~~~~~~~~~~~~~~~~
domain\protocols\strategy_protocol.py:1243:12: error: "DataFrame" has no
attribute "shape"  [attr-defined]
            if data.shape[0] == 0:
               ^~~~~~~~~~
domain\protocols\strategy_protocol.py:1245:12: error: "DataFrame" has no
attribute "isnull"  [attr-defined]
            if data.isnull().values.any():
               ^~~~~~~~~~~
domain\protocols\strategy_protocol.py:1247:12: error: "DataFrame" has no
attribute "shape"  [attr-defined]
            if data.shape[0] < 50:  # ћинимальное количество записей
               ^~~~~~~~~~
domain\protocols\repository_protocol.py:176:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\repository_protocol.py:177:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\intelligence\mirror_detector.py:70:30: error: Incompatible types in
assignment (expression has type "float", variable has type "Series") 
[assignment]
                        series = (series - mean_val) / std_val
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\intelligence\mirror_detector.py:70:31: error: Unsupported operand types
for - ("Series" and "float")  [operator]
                        series = (series - mean_val) / std_val
                                  ^
domain\intelligence\mirror_detector.py:104:30: error: Value of type
"Callable[[], ndarray[Any, Any]]" is not indexable  [index]
                        np.array(series1.values[lag:]), np.array(series2.v...
                                 ^~~~~~~~~~~~~~~~~~~~
domain\intelligence\mirror_detector.py:109:30: error: Value of type
"Callable[[], ndarray[Any, Any]]" is not indexable  [index]
                        np.array(series1.values[:-lag]), np.array(series2....
                                 ^~~~~~~~~~~~~~~~~~~~~
domain\entities\strategy_interface.py:115:24: error: Unsupported operand types
for < ("int" and "object")  [operator]
            if len(data) < min_data_points:
                           ^~~~~~~~~~~~~~~
domain\entities\strategy_interface.py:402:16: error: "Series" has no attribute
"expanding"  [attr-defined]
            peak = prices.expanding().max()
                   ^~~~~~~~~~~~~~~~
domain\entities\strategy_interface.py:472:20: error: Cannot instantiate
abstract class "BaseStrategy" with abstract attribute
"_generate_strategy_signals"  [abstract]
            strategy = BaseStrategy(
                       ^
domain\entities\strategy_interface.py:473:25: error: Argument "strategy_id" to
"BaseStrategy" has incompatible type "Any | None"; expected "StrategyId" 
[arg-type]
                strategy_id=config.get("strategy_id"),
                            ^~~~~~~~~~~~~~~~~~~~~~~~~
domain\entities\strategy_interface.py:476:20: error: Argument "config" to
"BaseStrategy" has incompatible type "dict[str, Any]"; expected "StrategyConfig"
 [arg-type]
                config=config,
                       ^~~~~~
tests\test_mirror_detector_integration.py:9:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import (
    ^
tests\test_mirror_detector_integration.py:9:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"TradingOrchestrator"  [attr-defined]
    from application.use_cases.trading_orchestrator import (
    ^
tests\conftest.py:97:13: error: Module has no attribute "date_range" 
[attr-defined]
        dates = pd.date_range(start="2024-01-01", periods=100, freq="1min"...
                ^~~~~~~~~~~~~
tests\unit\test_protocols_strategy.py:20:16: error: Unexpected keyword argument
"symbols" for "StrategyConfig"  [call-arg]
            return StrategyConfig(
                   ^
tests\unit\test_protocols_strategy.py:20:16: error: Unexpected keyword argument
"timeframe" for "StrategyConfig"  [call-arg]
            return StrategyConfig(
                   ^
tests\unit\test_protocols_strategy.py:20:16: error: Unexpected keyword argument
"enabled" for "StrategyConfig"  [call-arg]
            return StrategyConfig(
                   ^
tests\unit\test_protocols_strategy.py:34:26: error: Unexpected keyword argument
"is_active" for "StrategyState"  [call-arg]
            strategy.state = StrategyState(is_active=True)
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
venv\lib\site-packages\mypy\typeshed\stdlib\enum.pyi:214:5: note: "StrategyState" defined here
tests\unit\test_protocols_strategy.py:46:25: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                price=Price(50000.0, Currency("USDT")),
                            ^~~~~~~
tests\unit\test_protocols_strategy.py:53:25: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                price=Price(50000.0, Currency("USDT")),
                            ^~~~~~~
tests\unit\test_protocols_strategy.py:59:35: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                execution_price=Price(50000.0, Currency("USDT")),
                                      ^~~~~~~
tests\unit\test_protocols_strategy.py:65:55: error: Unexpected keyword argument
"total_pnl" for "StrategyMetrics"  [call-arg]
            strategy.get_metrics = AsyncMock(return_value=StrategyMetrics(
                                                          ^
tests\unit\test_protocols_strategy.py:70:26: error: Argument "max_drawdown" to
"StrategyMetrics" has incompatible type "Money"; expected "Decimal"  [arg-type]
                max_drawdown=Money(-200.0, Currency("USDT")),
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_strategy.py:71:26: error: Argument "sharpe_ratio" to
"StrategyMetrics" has incompatible type "float"; expected "Decimal"  [arg-type]
                sharpe_ratio=1.25,
                             ^~~~
tests\unit\test_protocols_strategy.py:72:22: error: Argument "win_rate" to
"StrategyMetrics" has incompatible type "float"; expected "Decimal"  [arg-type]
                win_rate=0.7
                         ^~~
tests\unit\test_protocols_strategy.py:75:53: error: Unexpected keyword argument
"is_active" for "StrategyState"  [call-arg]
    ...     strategy.get_state = AsyncMock(return_value=StrategyState(is_acti...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
venv\lib\site-packages\mypy\typeshed\stdlib\enum.pyi:214:5: note: "StrategyState" defined here
tests\unit\test_protocols_strategy.py:105:25: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                price=Price(50000.0, Currency("USDT")),
                            ^~~~~~~
tests\unit\test_protocols_strategy.py:117:25: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                price=Price(50000.0, Currency("USDT")),
                            ^~~~~~~
tests\unit\test_protocols_strategy.py:131:16: error: "StrategyState" has no
attribute "is_active"  [attr-defined]
            assert state.is_active is True
                   ^~~~~~~~~~~~~~~
tests\unit\test_protocols_strategy.py:160:29: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    price=Price(50000.0, Currency("USDT")),
                                ^~~~~~~
tests\unit\test_protocols_strategy.py:169:29: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    price=Price(50000.0, Currency("USDT")),
                                ^~~~~~~
tests\unit\test_protocols_strategy.py:178:29: error: Argument 1 to "Price" has
incompatible type "float"; expected "Decimal"  [arg-type]
                    price=Price(-1.0, Currency("USDT")),
                                ^~~~
tests\unit\test_protocols_repository.py:9:1: error: Module
"domain.protocols.repository_protocol" has no attribute
"TransactionalRepositoryProtocol"; maybe "PositionRepositoryProtocol",
"TradingPairRepositoryProtocol", or "TradingRepositoryProtocol"?  [attr-defined]
    from domain.protocols.repository_protocol import (
    ^
tests\unit\test_protocols_repository.py:9:1: error: Module
"domain.protocols.repository_protocol" has no attribute "RepositoryError" 
[attr-defined]
    from domain.protocols.repository_protocol import (
    ^
tests\unit\test_protocols_repository.py:9:1: error: Module
"domain.protocols.repository_protocol" has no attribute "NotFoundError" 
[attr-defined]
    from domain.protocols.repository_protocol import (
    ^
tests\unit\test_protocols_repository.py:9:1: error: Module
"domain.protocols.repository_protocol" has no attribute "DuplicateError" 
[attr-defined]
    from domain.protocols.repository_protocol import (
    ^
tests\unit\test_protocols_repository.py:20:1: error: Module
"domain.entities.trading" has no attribute "Order"; maybe "OrderId"? 
[attr-defined]
    from domain.entities.trading import Order
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_protocols_repository.py:84:46: error: Missing positional
arguments "field_name", "field_value", "validation_rule" in call to
"ValidationError"  [call-arg]
            mock_repository.update.side_effect = ValidationError("Invalid ...
                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_protocols_repository.py:109:46: error: Missing positional
arguments "field_name", "field_value", "validation_rule" in call to
"ValidationError"  [call-arg]
            mock_repository.create.side_effect = ValidationError("Invalid ...
                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_protocols_repository.py:156:52: error: Missing positional
arguments "field_name", "field_value", "validation_rule" in call to
"ValidationError"  [call-arg]
    ...      async_mock_repository.update.side_effect = ValidationError("Inva...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_efficiency_validator.py:220:9: error: "EfficiencyValidator" has
no attribute "cleanup"  [attr-defined]
            efficiency_validator.cleanup = lambda: None
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_efficiency_validator.py:221:9: error: "EfficiencyValidator" has
no attribute "cleanup"  [attr-defined]
            efficiency_validator.cleanup()
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
shared\monitoring_dashboard.py:27:5: error: Name "performance_monitor" already
defined (possibly by an import)  [no-redef]
        performance_monitor: Optional[Any] = None
        ^~~~~~~~~~~~~~~~~~~
shared\monitoring_dashboard.py:28:5: error: Name "MetricsAnalyzer" already
defined (possibly by an import)  [no-redef]
        MetricsAnalyzer: Optional[type] = None
        ^~~~~~~~~~~~~~~
shared\monitoring_dashboard.py:29:5: error: Name "config_validator" already
defined (possibly by an import)  [no-redef]
        config_validator: Optional[Any] = None
        ^~~~~~~~~~~~~~~~
shared\monitoring_dashboard.py:72:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
shared\monitoring_dashboard.py:73:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
scripts\train_window_model.py:72:9: error: Need type annotation for
"metrics_history" (hint: "metrics_history: list[<type>] = ...")  [var-annotated]
            self.metrics_history = []
            ^~~~~~~~~~~~~~~~~~~~
scripts\train_window_model.py:93:18: error: Module has no attribute "read_csv" 
[attr-defined]
                df = pd.read_csv(data_path)
                     ^~~~~~~~~~~
scripts\train_window_model.py:116:22: error: "DataFrame" has no attribute
"sample"  [attr-defined]
                    df = df.sample(
                         ^~~~~~~~~
scripts\train_window_model.py:133:27: error: "DataFrame" has no attribute
"select_dtypes"  [attr-defined]
            numeric_columns = df.select_dtypes(include=[np.number]).column...
                              ^~~~~~~~~~~~~~~~
scripts\train_window_model.py:134:9: error: Unsupported target for indexed
assignment ("DataFrame")  [index]
            df[numeric_columns] = df[numeric_columns].fillna(df[numeric_co...
            ^~~~~~~~~~~~~~~~~~~
scripts\train_window_model.py:137:31: error: "DataFrame" has no attribute
"select_dtypes"  [attr-defined]
            categorical_columns = df.select_dtypes(include=["object"]).col...
                                  ^~~~~~~~~~~~~~~~
scripts\train_window_model.py:138:9: error: Unsupported target for indexed
assignment ("DataFrame")  [index]
            df[categorical_columns] = df[categorical_columns].fillna(
            ^~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\monitoring_dashboard.py:29:1: error: Module
"infrastructure.core.logging" has no attribute "get_logger"  [attr-defined]
    from infrastructure.core.logging import get_logger
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\monitoring_dashboard.py:32:1: error: Module
"infrastructure.core.visualization" has no attribute "ChartBuilder" 
[attr-defined]
    from infrastructure.core.visualization import ChartBuilder
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\monitoring_dashboard.py:33:1: error: Module
"infrastructure.core.wavelet_tools" has no attribute "WaveletAnalyzer" 
[attr-defined]
    from infrastructure.core.wavelet_tools import WaveletAnalyzer
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\monitoring_dashboard.py:35:1: error: Module
"shared.market_regime" has no attribute "MarketRegimeDetector"  [attr-defined]
    from shared.market_regime import MarketRegimeDetector
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\monitoring_dashboard.py:36:1: error: Module
"shared.timeframes" has no attribute "TimeframeUtils"  [attr-defined]
    from shared.timeframes import TimeframeUtils
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interfaces\presentation\dashboard\monitoring_dashboard.py:37:1: error: Module
"shared.unified_cache" has no attribute "CacheManager"  [attr-defined]
    from shared.unified_cache import get_cache_manager, CacheManager
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:27:23: error:
Name "nn" is not defined  [name-defined]
    class StrategyMLModel(nn.Module):
                          ^~
infrastructure\strategies\evolution\evolvable_base_strategy.py:32:20: error:
Name "nn" is not defined  [name-defined]
            self.net = nn.Sequential(
                       ^~
infrastructure\strategies\evolution\evolvable_base_strategy.py:33:13: error:
Name "nn" is not defined  [name-defined]
                nn.Linear(input_dim, hidden_dim),
                ^~
infrastructure\strategies\evolution\evolvable_base_strategy.py:34:13: error:
Name "nn" is not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\strategies\evolution\evolvable_base_strategy.py:35:13: error:
Name "nn" is not defined  [name-defined]
                nn.Dropout(0.2),
                ^~
infrastructure\strategies\evolution\evolvable_base_strategy.py:36:13: error:
Name "nn" is not defined  [name-defined]
                nn.Linear(hidden_dim, hidden_dim // 2),
                ^~
infrastructure\strategies\evolution\evolvable_base_strategy.py:37:13: error:
Name "nn" is not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\strategies\evolution\evolvable_base_strategy.py:38:13: error:
Name "nn" is not defined  [name-defined]
                nn.Linear(hidden_dim // 2, 3),  # buy, sell, hold
                ^~
infrastructure\strategies\evolution\evolvable_base_strategy.py:50:32: error:
Name "Optional" is not defined  [name-defined]
        def __init__(self, config: Optional[EvolutionConfig] = None):
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:50:32: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Optional")
infrastructure\strategies\evolution\evolvable_base_strategy.py:52:23: error:
Incompatible types in assignment (expression has type "Any | EvolutionConfig",
variable has type "dict[str, Any]")  [assignment]
            self.config = config or EvolutionConfig()
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:62:9: error:
Need type annotation for "training_data" (hint:
"training_data: list[<type>] = ...")  [var-annotated]
            self.training_data = []
            ^~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:65:5: error:
Return type "StrategyAnalysis" of "analyze" incompatible with return type
"dict[str, Any]" in supertype "BaseStrategy"  [override]
        def analyze(self, data: pd.DataFrame) -> StrategyAnalysis:
        ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:65:29: error:
Name "pd" is not defined  [name-defined]
        def analyze(self, data: pd.DataFrame) -> StrategyAnalysis:
                                ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:96:27: error:
Name "pd" is not defined  [name-defined]
                    timestamp=pd.Timestamp.now(),
                              ^~
infrastructure\strategies\evolution\evolvable_base_strategy.py:115:37: error:
Name "pd" is not defined  [name-defined]
        def generate_signal(self, data: pd.DataFrame) -> Optional[DomainSi...
                                        ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:115:54: error:
Name "Optional" is not defined  [name-defined]
    ...def generate_signal(self, data: pd.DataFrame) -> Optional[DomainSignal...
                                                        ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:115:54: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Optional")
infrastructure\strategies\evolution\evolvable_base_strategy.py:146:39: error:
Name "pd" is not defined  [name-defined]
        def _extract_features(self, data: pd.DataFrame) -> List[float]:
                                          ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:146:56: error:
Name "List" is not defined  [name-defined]
        def _extract_features(self, data: pd.DataFrame) -> List[float]:
                                                           ^~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:146:56: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
infrastructure\strategies\evolution\evolvable_base_strategy.py:174:42: error:
Name "List" is not defined  [name-defined]
        def _get_predictions(self, features: List[float]) -> Dict[str, flo...
                                             ^~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:174:42: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
infrastructure\strategies\evolution\evolvable_base_strategy.py:174:58: error:
Name "Dict" is not defined  [name-defined]
    ...def _get_predictions(self, features: List[float]) -> Dict[str, float]:
                                                            ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:174:58: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:213:36: error:
Name "pd" is not defined  [name-defined]
        def _detect_regime(self, data: pd.DataFrame) -> MarketRegime:
                                       ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:235:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float], re...
                        ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:235:51: error:
Name "Dict" is not defined  [name-defined]
    ...       self, data: pd.DataFrame, ml_predictions: Dict[str, float], reg...
                                                        ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:235:51: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:236:10: error:
Name "List" is not defined  [name-defined]
        ) -> List[DomainSignal]:
             ^~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:236:10: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
infrastructure\strategies\evolution\evolvable_base_strategy.py:253:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                        ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:253:51: error:
Name "Dict" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                                                      ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:253:51: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:254:10: error:
Name "Optional" is not defined  [name-defined]
        ) -> Optional[DomainSignal]:
             ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:254:10: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Optional")
infrastructure\strategies\evolution\evolvable_base_strategy.py:284:25: error:
Name "Dict" is not defined  [name-defined]
            ml_predictions: Dict[str, float],
                            ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:284:25: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:301:53: error:
Name "Dict" is not defined  [name-defined]
            self, signal: DomainSignal, ml_predictions: Dict[str, float]
                                                        ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:301:53: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:315:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                        ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:315:51: error:
Name "Dict" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                                                      ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:315:51: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:334:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                        ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:334:51: error:
Name "Dict" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                                                      ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:334:51: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:350:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float], re...
                        ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:350:51: error:
Name "Dict" is not defined  [name-defined]
    ...       self, data: pd.DataFrame, ml_predictions: Dict[str, float], reg...
                                                        ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:350:51: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:351:10: error:
Name "Dict" is not defined  [name-defined]
        ) -> Dict[str, float]:
             ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:351:10: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:373:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                        ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:373:51: error:
Name "Dict" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                                                      ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:373:51: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:389:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float], re...
                        ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:389:51: error:
Name "Dict" is not defined  [name-defined]
    ...       self, data: pd.DataFrame, ml_predictions: Dict[str, float], reg...
                                                        ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:389:51: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:390:10: error:
Name "List" is not defined  [name-defined]
        ) -> List[str]:
             ^~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:390:10: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
infrastructure\strategies\evolution\evolvable_base_strategy.py:410:43: error:
Name "pd" is not defined  [name-defined]
        def _calculate_indicators(self, data: pd.DataFrame) -> Dict[str, p...
                                              ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:410:60: error:
Name "Dict" is not defined  [name-defined]
    ...alculate_indicators(self, data: pd.DataFrame) -> Dict[str, pd.Series]:
                                                        ^~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolution\evolvable_base_strategy.py:410:60: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Dict")
infrastructure\strategies\evolution\evolvable_base_strategy.py:422:5: error:
Signature of "save_state" incompatible with supertype "BaseStrategy"  [override]
        def save_state(self, path: str) -> bool:
        ^
infrastructure\strategies\evolution\evolvable_base_strategy.py:422:5: note:      Superclass:
infrastructure\strategies\evolution\evolvable_base_strategy.py:422:5: note:          def save_state(self) -> Any
infrastructure\strategies\evolution\evolvable_base_strategy.py:422:5: note:      Subclass:
infrastructure\strategies\evolution\evolvable_base_strategy.py:422:5: note:          def save_state(self, path: str) -> bool
infrastructure\repositories\trading_pair_repository.py:45:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\trading_pair_repository.py:46:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\trading_pair_repository.py:46:52: error:
Incompatible types in assignment (expression has type "dict[UUID | str, Any]",
base class "BaseRepository" defined the type as "dict[CacheKey, Any]") 
[assignment]
            self._cache: Dict[Union[UUID, str], Any] = {}
                                                       ^~
infrastructure\repositories\trading_pair_repository.py:47:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\trading_pair_repository.py:47:61: error:
Incompatible types in assignment (expression has type
"dict[UUID | str, datetime]", base class "BaseRepository" defined the type as
"dict[CacheKey, datetime]")  [assignment]
            self._cache_ttl: Dict[Union[UUID, str], datetime] = {}
                                                                ^~
infrastructure\repositories\trading_pair_repository.py:86:48: error: Argument 2
to "_apply_filters" of "InMemoryTradingPairRepository" has incompatible type
"list[domain.types.repository_types.QueryFilter]"; expected
"list[domain.protocols.repository_protocol.QueryFilter]"  [arg-type]
                pairs = self._apply_filters(pairs, options.filters)
                                                   ^~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:87:24: error:
"QueryOptions" has no attribute "sort"  [attr-defined]
            if options and options.sort:
                           ^~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:88:45: error:
"QueryOptions" has no attribute "sort"  [attr-defined]
                pairs = self._apply_sort(pairs, options.sort)
                                                ^~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:97:19: error: Missing
positional argument "entity_id" in call to "EntityNotFoundError"  [call-arg]
                raise EntityNotFoundError("TradingPair", pair_id)
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:118:27: error: Argument
1 of "count" is incompatible with supertype "BaseRepository"; supertype defines
the argument type as "list[QueryFilter] | None"  [override]
        async def count(self, filters: Optional[List[QueryFilter]] = None)...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:118:27: note: This violates the Liskov substitution principle
infrastructure\repositories\trading_pair_repository.py:118:27: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\trading_pair_repository.py:125:5: error: Return
type "AsyncIterator[TradingPair]" of "stream" incompatible with return type
"Coroutine[Any, Any, AsyncIterator[Any]]" in supertype "BaseRepository" 
[override]
        async def stream(
        ^
infrastructure\repositories\trading_pair_repository.py:125:5: error: Return
type "AsyncIterator[TradingPair]" of "stream" incompatible with return type
"Coroutine[Any, Any, AsyncIterator[Any]]" in supertype "RepositoryProtocol" 
[override]
        async def stream(
        ^
infrastructure\repositories\trading_pair_repository.py:131:48: error: Argument
2 to "_apply_filters" of "InMemoryTradingPairRepository" has incompatible type
"list[domain.types.repository_types.QueryFilter]"; expected
"list[domain.protocols.repository_protocol.QueryFilter]"  [arg-type]
                pairs = self._apply_filters(pairs, options.filters)
                                                   ^~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:138:5: error: Return
type "_AsyncGeneratorContextManager[Any, None]" of "transaction" incompatible
with return type "Coroutine[Any, Any, AsyncIterator[TransactionProtocol]]" in
supertype "RepositoryProtocol"  [override]
        async def transaction(self) -> AsyncIterator[Any]:
        ^
infrastructure\repositories\trading_pair_repository.py:143:55: error: Name
"Callable" is not defined  [name-defined]
    ...sync def execute_in_transaction(self, operation: Callable, *args, **kw...
                                                        ^
infrastructure\repositories\trading_pair_repository.py:143:55: note: Did you forget to import it from "typing"? (Suggestion: "from typing import Callable")
infrastructure\repositories\trading_pair_repository.py:159:16: error:
Unexpected keyword argument "total" for "BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\trading_pair_repository.py:163:20: error: Argument
"errors" to "BulkOperationResult" has incompatible type "list[str]"; expected
"list[dict[str, Any]]"  [arg-type]
                errors=errors,
                       ^~~~~~
infrastructure\repositories\trading_pair_repository.py:180:16: error:
Unexpected keyword argument "total" for "BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\trading_pair_repository.py:184:20: error: Argument
"errors" to "BulkOperationResult" has incompatible type "list[str]"; expected
"list[dict[str, Any]]"  [arg-type]
                errors=errors,
                       ^~~~~~
infrastructure\repositories\trading_pair_repository.py:204:16: error:
Unexpected keyword argument "total" for "BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\trading_pair_repository.py:208:20: error: Argument
"errors" to "BulkOperationResult" has incompatible type "list[str]"; expected
"list[dict[str, Any]]"  [arg-type]
                errors=errors,
                       ^~~~~~
infrastructure\repositories\trading_pair_repository.py:228:16: error:
Unexpected keyword argument "total" for "BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\trading_pair_repository.py:232:20: error: Argument
"errors" to "BulkOperationResult" has incompatible type "list[str]"; expected
"list[dict[str, Any]]"  [arg-type]
                errors=errors,
                       ^~~~~~
infrastructure\repositories\trading_pair_repository.py:277:16: error:
Unexpected keyword argument "total_entities" for "RepositoryResponse" 
[call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:277:16: error:
Unexpected keyword argument "cache_size" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:277:16: error:
Unexpected keyword argument "uptime" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:277:16: error:
Unexpected keyword argument "state" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:285:5: error: Signature
of "state" incompatible with supertype "BaseRepository"  [override]
        def state(self) -> RepositoryState:
        ^
infrastructure\repositories\trading_pair_repository.py:285:5: note:      Superclass:
infrastructure\repositories\trading_pair_repository.py:285:5: note:          domain.types.repository_types.RepositoryState
infrastructure\repositories\trading_pair_repository.py:285:5: note:      Subclass:
infrastructure\repositories\trading_pair_repository.py:285:5: note:          domain.protocols.repository_protocol.RepositoryState
infrastructure\repositories\trading_pair_repository.py:286:16: error:
Incompatible return value type (got
"domain.types.repository_types.RepositoryState", expected
"domain.protocols.repository_protocol.RepositoryState")  [return-value]
            return self._state
                   ^~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:288:29: error: Argument
1 of "find_by" is incompatible with supertype "BaseRepository"; supertype
defines the argument type as "list[QueryFilter]"  [override]
        async def find_by(self, filters: List[QueryFilter], options: Optio...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:288:29: note: This violates the Liskov substitution principle
infrastructure\repositories\trading_pair_repository.py:288:29: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\trading_pair_repository.py:298:33: error: Argument
1 of "find_one_by" is incompatible with supertype "BaseRepository"; supertype
defines the argument type as "list[QueryFilter]"  [override]
        async def find_one_by(self, filters: List[QueryFilter]) -> Optiona...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:298:33: note: This violates the Liskov substitution principle
infrastructure\repositories\trading_pair_repository.py:298:33: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\trading_pair_repository.py:302:5: error: Return
type "Coroutine[Any, Any, PerformanceMetricsDict]" of "get_performance_metrics"
incompatible with return type "Coroutine[Any, Any, PerformanceMetrics]" in
supertype "BaseRepository"  [override]
        async def get_performance_metrics(self) -> PerformanceMetricsDict:
        ^
infrastructure\repositories\trading_pair_repository.py:305:5: error: Return
type "Coroutine[Any, Any, HealthCheckDict]" of "health_check" incompatible with
return type "Coroutine[Any, Any, HealthCheckResult]" in supertype
"BaseRepository"  [override]
        async def health_check(self) -> HealthCheckDict:
        ^
infrastructure\repositories\trading_pair_repository.py:310:16: error:
Unexpected keyword argument "total_entities" for "RepositoryResponse" 
[call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:310:16: error:
Unexpected keyword argument "cache_size" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:310:16: error:
Unexpected keyword argument "uptime" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:310:16: error:
Unexpected keyword argument "state" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:409:1: error: Definition
of "_cache" in base class "BaseRepository" is incompatible with definition in
base class "RepositoryProtocol"  [misc]
    class PostgresTradingPairRepository(BaseRepository, TradingPairReposit...
    ^
infrastructure\repositories\trading_pair_repository.py:409:1: error: Definition
of "_cache_ttl" in base class "BaseRepository" is incompatible with definition
in base class "RepositoryProtocol"  [misc]
    class PostgresTradingPairRepository(BaseRepository, TradingPairReposit...
    ^
infrastructure\repositories\trading_pair_repository.py:409:1: error: Definition
of "find_by" in base class "BaseRepository" is incompatible with definition in
base class "RepositoryProtocol"  [misc]
    class PostgresTradingPairRepository(BaseRepository, TradingPairReposit...
    ^
infrastructure\repositories\trading_pair_repository.py:409:1: error: Definition
of "find_one_by" in base class "BaseRepository" is incompatible with definition
in base class "RepositoryProtocol"  [misc]
    class PostgresTradingPairRepository(BaseRepository, TradingPairReposit...
    ^
infrastructure\repositories\trading_pair_repository.py:409:1: error: Definition
of "state" in base class "BaseRepository" is incompatible with definition in
base class "RepositoryProtocol"  [misc]
    class PostgresTradingPairRepository(BaseRepository, TradingPairReposit...
    ^
infrastructure\repositories\trading_pair_repository.py:419:23: error:
Incompatible types in assignment (expression has type
"domain.protocols.repository_protocol.RepositoryState", variable has type
"domain.types.repository_types.RepositoryState")  [assignment]
            self._state = RepositoryState.DISCONNECTED
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:494:24: error:
"QueryOptions" has no attribute "sort"  [attr-defined]
            if options and options.sort:
                           ^~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:496:31: error:
"QueryOptions" has no attribute "sort"  [attr-defined]
                for sort_order in options.sort:
                                  ^~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:536:27: error: Missing
positional argument "entity_id" in call to "EntityNotFoundError"  [call-arg]
                        raise EntityNotFoundError(
                              ^
infrastructure\repositories\trading_pair_repository.py:557:27: error: Argument
1 of "count" is incompatible with supertype "BaseRepository"; supertype defines
the argument type as "list[QueryFilter] | None"  [override]
        async def count(self, filters: Optional[List[QueryFilter]] = None)...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:557:27: note: This violates the Liskov substitution principle
infrastructure\repositories\trading_pair_repository.py:557:27: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\trading_pair_repository.py:580:5: error: Return
type "AsyncIterator[TradingPair]" of "stream" incompatible with return type
"Coroutine[Any, Any, AsyncIterator[Any]]" in supertype "BaseRepository" 
[override]
        async def stream(
        ^
infrastructure\repositories\trading_pair_repository.py:580:5: error: Return
type "AsyncIterator[TradingPair]" of "stream" incompatible with return type
"Coroutine[Any, Any, AsyncIterator[Any]]" in supertype "RepositoryProtocol" 
[override]
        async def stream(
        ^
infrastructure\repositories\trading_pair_repository.py:601:24: error:
"QueryOptions" has no attribute "sort"  [attr-defined]
            if options and options.sort:
                           ^~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:603:31: error:
"QueryOptions" has no attribute "sort"  [attr-defined]
                for sort_order in options.sort:
                                  ^~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:614:5: error: Return
type "_AsyncGeneratorContextManager[Any, None]" of "transaction" incompatible
with return type "Coroutine[Any, Any, AsyncIterator[TransactionProtocol]]" in
supertype "RepositoryProtocol"  [override]
        async def transaction(self) -> AsyncIterator[Any]:
        ^
infrastructure\repositories\trading_pair_repository.py:621:55: error: Function
"builtins.callable" is not valid as a type  [valid-type]
    ...sync def execute_in_transaction(self, operation: callable, *args, **kw...
                                                        ^
infrastructure\repositories\trading_pair_repository.py:621:55: note: Perhaps you meant "typing.Callable" instead of "callable"?
infrastructure\repositories\trading_pair_repository.py:626:30: error: callable?
not callable  [misc]
                    return await operation(conn, *args, **kwargs)
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:661:24: error:
Unexpected keyword argument "total" for "BulkOperationResult"  [call-arg]
                    return BulkOperationResult(
                           ^
infrastructure\repositories\trading_pair_repository.py:665:28: error: Argument
"errors" to "BulkOperationResult" has incompatible type "list[str]"; expected
"list[dict[str, Any]]"  [arg-type]
                        errors=errors,
                               ^~~~~~
infrastructure\repositories\trading_pair_repository.py:706:24: error:
Unexpected keyword argument "total" for "BulkOperationResult"  [call-arg]
                    return BulkOperationResult(
                           ^
infrastructure\repositories\trading_pair_repository.py:710:28: error: Argument
"errors" to "BulkOperationResult" has incompatible type "list[str]"; expected
"list[dict[str, Any]]"  [arg-type]
                        errors=errors,
                               ^~~~~~
infrastructure\repositories\trading_pair_repository.py:735:24: error:
Unexpected keyword argument "total" for "BulkOperationResult"  [call-arg]
                    return BulkOperationResult(
                           ^
infrastructure\repositories\trading_pair_repository.py:739:28: error: Argument
"errors" to "BulkOperationResult" has incompatible type "list[str]"; expected
"list[dict[str, Any]]"  [arg-type]
                        errors=errors,
                               ^~~~~~
infrastructure\repositories\trading_pair_repository.py:785:24: error:
Unexpected keyword argument "total" for "BulkOperationResult"  [call-arg]
                    return BulkOperationResult(
                           ^
infrastructure\repositories\trading_pair_repository.py:789:28: error: Argument
"errors" to "BulkOperationResult" has incompatible type "list[str]"; expected
"list[dict[str, Any]]"  [arg-type]
                        errors=errors,
                               ^~~~~~
infrastructure\repositories\trading_pair_repository.py:818:20: error:
Unexpected keyword argument "total_entities" for "RepositoryResponse" 
[call-arg]
                return RepositoryResponse(
                       ^
infrastructure\repositories\trading_pair_repository.py:818:20: error:
Unexpected keyword argument "cache_size" for "RepositoryResponse"  [call-arg]
                return RepositoryResponse(
                       ^
infrastructure\repositories\trading_pair_repository.py:818:20: error:
Unexpected keyword argument "uptime" for "RepositoryResponse"  [call-arg]
                return RepositoryResponse(
                       ^
infrastructure\repositories\trading_pair_repository.py:818:20: error:
Unexpected keyword argument "state" for "RepositoryResponse"  [call-arg]
                return RepositoryResponse(
                       ^
infrastructure\repositories\trading_pair_repository.py:825:5: error: Return
type "Coroutine[Any, Any, PerformanceMetricsDict]" of "get_performance_metrics"
incompatible with return type "Coroutine[Any, Any, PerformanceMetrics]" in
supertype "BaseRepository"  [override]
        async def get_performance_metrics(self) -> PerformanceMetricsDict:
        ^
infrastructure\repositories\trading_pair_repository.py:834:16: error:
Unexpected keyword argument "total_entities" for "RepositoryResponse" 
[call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:834:16: error:
Unexpected keyword argument "cache_size" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:834:16: error:
Unexpected keyword argument "uptime" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:834:16: error:
Unexpected keyword argument "state" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\trading_pair_repository.py:838:5: error: Return
type "Coroutine[Any, Any, HealthCheckDict]" of "health_check" incompatible with
return type "Coroutine[Any, Any, HealthCheckResult]" in supertype
"BaseRepository"  [override]
        async def health_check(self) -> HealthCheckDict:
        ^
infrastructure\repositories\trading_pair_repository.py:847:27: error:
Incompatible types in assignment (expression has type
"domain.protocols.repository_protocol.RepositoryState", variable has type
"domain.types.repository_types.RepositoryState")  [assignment]
                self._state = RepositoryState.ERROR
                              ^~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:877:27: error: Argument
"base_currency" to "TradingPair" has incompatible type "Currency | None";
expected "Currency"  [arg-type]
                base_currency=Currency.from_string(row["base_currency"]),
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading_pair_repository.py:878:28: error: Argument
"quote_currency" to "TradingPair" has incompatible type "Currency | None";
expected "Currency"  [arg-type]
                quote_currency=Currency.from_string(row["quote_currency"])...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\strategy_repository.py:51:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\strategy_repository.py:52:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\strategy_repository.py:53:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\strategy_repository.py:54:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\strategy_repository.py:55:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\strategy_repository.py:55:44: error: Incompatible
types in assignment (expression has type "dict[str, Strategy]", base class
"RepositoryProtocol" defined the type as "dict[UUID | str, Strategy]") 
[assignment]
            self._cache: Dict[str, Strategy] = {}
                                               ^~
infrastructure\repositories\strategy_repository.py:56:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\strategy_repository.py:56:48: error: Incompatible
types in assignment (expression has type "dict[str, datetime]", base class
"RepositoryProtocol" defined the type as "dict[UUID | str, datetime]") 
[assignment]
            self._cache_ttl: Dict[str, datetime] = {}
                                                   ^~
infrastructure\repositories\strategy_repository.py:175:5: error: Return type
"_AsyncGeneratorContextManager[Any, None]" of "transaction" incompatible with
return type "Coroutine[Any, Any, AsyncIterator[TransactionProtocol]]" in
supertype "RepositoryProtocol"  [override]
        async def transaction(self) -> AsyncIterator[Any]:
        ^
infrastructure\repositories\strategy_repository.py:216:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\strategy_repository.py:231:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\strategy_repository.py:248:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\strategy_repository.py:268:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\strategy_repository.py:273:5: error: Return type
"AsyncIterator[Strategy]" of "stream" incompatible with return type
"Coroutine[Any, Any, AsyncIterator[Strategy]]" in supertype "RepositoryProtocol"
 [override]
        async def stream(
        ^
infrastructure\repositories\strategy_repository.py:273:5: note: Consider declaring "stream" in supertype "RepositoryProtocol" without "async"
infrastructure\repositories\strategy_repository.py:273:5: note: See https://mypy.readthedocs.io/en/stable/more_types.html#asynchronous-iterators
infrastructure\repositories\strategy_repository.py:345:31: error:
"type[StrategyStatus]" has no attribute "DELETED"  [attr-defined]
                strategy.status = StrategyStatus.DELETED
                                  ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\strategy_repository.py:353:44: error:
"type[StrategyStatus]" has no attribute "DELETED"  [attr-defined]
            if strategy and strategy.status == StrategyStatus.DELETED:
                                               ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\strategy_repository.py:374:16: error: Extra keys
("total_entities", "cache_hit_rate", "avg_response_time_ms", "error_rate") for
TypedDict "PerformanceMetricsDict"  [typeddict-unknown-key]
            return PerformanceMetricsDict(
                   ^
infrastructure\repositories\strategy_repository.py:383:16: error: Extra keys
("uptime_seconds", "memory_usage_mb", "connection_status") for TypedDict
"HealthCheckDict"  [typeddict-unknown-key]
            return HealthCheckDict(
                   ^
infrastructure\repositories\strategy_repository.py:411:5: error: Return type
"Coroutine[Any, Any, dict[str, Any]]" of "get_cache_stats" incompatible with
return type "Coroutine[Any, Any, RepositoryResponse]" in supertype
"RepositoryProtocol"  [override]
        async def get_cache_stats(self) -> Dict[str, Any]:
        ^
infrastructure\repositories\strategy_repository.py:492:5: error: Return type
"Coroutine[Any, Any, bool]" of "save_strategy" incompatible with return type
"Coroutine[Any, Any, Strategy]" in supertype "StrategyRepositoryProtocol" 
[override]
        async def save_strategy(self, strategy: Strategy) -> bool:
        ^
infrastructure\repositories\strategy_repository.py:543:17: error: Unsupported
operand types for + ("None" and "int")  [operator]
                    self._metrics["cache_hits"] += 1
                    ^
infrastructure\repositories\strategy_repository.py:543:17: note: Left operand is of type "int | None"
infrastructure\repositories\strategy_repository.py:545:13: error: Unsupported
operand types for + ("None" and "int")  [operator]
                self._metrics["cache_misses"] += 1
                ^
infrastructure\repositories\strategy_repository.py:545:13: note: Left operand is of type "int | None"
infrastructure\repositories\strategy_repository.py:662:5: error: Return type
"Coroutine[Any, Any, bool]" of "save" incompatible with return type
"Coroutine[Any, Any, Strategy]" in supertype "RepositoryProtocol"  [override]
        async def save(self, entity: Any) -> bool:
        ^
infrastructure\repositories\strategy_repository.py:672:5: error: Signature of
"get_all" incompatible with supertype "RepositoryProtocol"  [override]
        async def get_all(self) -> List[Any]:
        ^
infrastructure\repositories\strategy_repository.py:672:5: note:      Superclass:
infrastructure\repositories\strategy_repository.py:672:5: note:          def get_all(self, options: QueryOptions | None = ...) -> Coroutine[Any, Any, list[Strategy]]
infrastructure\repositories\strategy_repository.py:672:5: note:      Subclass:
infrastructure\repositories\strategy_repository.py:672:5: note:          def get_all(self) -> Coroutine[Any, Any, list[Any]]
infrastructure\repositories\strategy_repository.py:966:24: error: Argument
"parameters" to "Strategy" has incompatible type "Any | dict[Any, Any]";
expected "StrategyParameters"  [arg-type]
                parameters=row["parameters"] or {},
                           ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\risk_repository.py:14:1: error: Module
"domain.exceptions.protocol_exceptions" has no attribute "RepositoryError" 
[attr-defined]
    from domain.exceptions.protocol_exceptions import (
    ^
infrastructure\repositories\risk_repository.py:95:13: error: Unsupported
operand types for + ("object" and "int")  [operator]
                self._metrics["cache_hits"] += 1
                ^
infrastructure\repositories\risk_repository.py:97:9: error: Unsupported operand
types for + ("object" and "int")  [operator]
            self._metrics["cache_misses"] += 1
            ^
infrastructure\repositories\risk_repository.py:268:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\risk_repository.py:285:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\risk_repository.py:302:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\risk_repository.py:322:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\risk_repository.py:372:16: error: Unexpected
keyword argument "message" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\risk_repository.py:384:5: error: Return type
"Coroutine[Any, Any, dict[str, Any]]" of "get_performance_metrics" incompatible
with return type "Coroutine[Any, Any, PerformanceMetricsDict]" in supertype
"RepositoryProtocol"  [override]
        async def get_performance_metrics(self) -> Dict[str, Any]:
        ^
infrastructure\repositories\risk_repository.py:391:20: error: Unsupported left
operand type for + ("object")  [operator]
                    / (self._metrics["cache_hits"] + self._metrics["cache_...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\repositories\risk_repository.py:392:21: error: Unsupported left
operand type for + ("object")  [operator]
                    if (self._metrics["cache_hits"] + self._metrics["cache...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\repositories\risk_repository.py:395:33: error: Unsupported left
operand type for + ("object")  [operator]
                "total_operations": self._metrics["cache_hits"] + self._me...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\repositories\risk_repository.py:396:29: error: "object" has no
attribute "isoformat"  [attr-defined]
                "last_cleanup": self._metrics["last_cleanup"].isoformat(),
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\risk_repository.py:401:16: error: Unexpected
keyword argument "message" for "RepositoryResponse"  [call-arg]
            return RepositoryResponse(
                   ^
infrastructure\repositories\risk_repository.py:413:5: error: Return type
"Coroutine[Any, Any, dict[str, Any]]" of "health_check" incompatible with return
type "Coroutine[Any, Any, HealthCheckDict]" in supertype "RepositoryProtocol" 
[override]
        async def health_check(self) -> Dict[str, Any]:
        ^
infrastructure\repositories\risk_repository.py:605:44: error: Argument 1 to
"get_risk_profile" of "PostgresRiskRepository" has incompatible type
"UUID | str"; expected "RiskProfileId"  [arg-type]
            return await self.get_risk_profile(entity_id)
                                               ^~~~~~~~~
infrastructure\repositories\risk_repository.py:879:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\risk_repository.py:902:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\risk_repository.py:925:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\risk_repository.py:951:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\risk_repository.py:999:16: error: Extra keys
("total_entities", "cache_hit_rate", "avg_response_time_ms", "error_rate") for
TypedDict "PerformanceMetricsDict"  [typeddict-unknown-key]
            return PerformanceMetricsDict(
                   ^
infrastructure\repositories\risk_repository.py:1042:20: error: Extra keys
("uptime_seconds", "memory_usage_mb", "connection_status") for TypedDict
"HealthCheckDict"  [typeddict-unknown-key]
                return HealthCheckDict(
                       ^
infrastructure\repositories\portfolio_repository.py:200:5: error: Return type
"AsyncIterator[Portfolio]" of "stream" incompatible with return type
"Coroutine[Any, Any, AsyncIterator[Portfolio]]" in supertype
"RepositoryProtocol"  [override]
        async def stream(
        ^
infrastructure\repositories\portfolio_repository.py:200:5: note: Consider declaring "stream" in supertype "RepositoryProtocol" without "async"
infrastructure\repositories\portfolio_repository.py:200:5: note: See https://mypy.readthedocs.io/en/stable/more_types.html#asynchronous-iterators
infrastructure\repositories\portfolio_repository.py:250:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\portfolio_repository.py:267:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\portfolio_repository.py:286:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\portfolio_repository.py:308:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\portfolio_repository.py:376:16: error: Extra keys
("uptime_seconds", "memory_usage_mb", "connection_status") for TypedDict
"HealthCheckDict"  [typeddict-unknown-key]
            return HealthCheckDict(
                   ^
infrastructure\repositories\portfolio_repository.py:1068:20: error: Extra keys
("database", "cache") for TypedDict "HealthCheckDict"  [typeddict-unknown-key]
                return {
                       ^
infrastructure\repositories\portfolio_repository.py:1074:20: error: Extra keys
("error", "database", "cache") for TypedDict "HealthCheckDict" 
[typeddict-unknown-key]
                return {
                       ^
infrastructure\repositories\ml_repository.py:41:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\ml_repository.py:42:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\ml_repository.py:43:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\ml_repository.py:44:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\ml_repository.py:45:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\ml_repository.py:46:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\ml_repository.py:47:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\ml_repository.py:48:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\ml_repository.py:49:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\ml_repository.py:68:33: error: Invalid index type
"ModelType" for "dict[str, list[UUID]]"; expected type "str"  [index]
                self.models_by_type[model.model_type].append(model.id)
                                    ^~~~~~~~~~~~~~~~
infrastructure\repositories\ml_repository.py:75:19: error: Missing positional
argument "entity_id" in call to "EntityUpdateError"  [call-arg]
                raise EntityUpdateError(f"Failed to save model: {model.id}...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\ml_repository.py:208:5: error: Return type
"AsyncIterator[Model]" of "stream" incompatible with return type
"Coroutine[Any, Any, AsyncIterator[Model]]" in supertype "RepositoryProtocol" 
[override]
        async def stream(self, options: Optional[QueryOptions] = None, bat...
        ^
infrastructure\repositories\ml_repository.py:208:5: note: Consider declaring "stream" in supertype "RepositoryProtocol" without "async"
infrastructure\repositories\ml_repository.py:208:5: note: See https://mypy.readthedocs.io/en/stable/more_types.html#asynchronous-iterators
infrastructure\repositories\ml_repository.py:215:5: error: Return type
"AsyncIterator[TransactionProtocol]" of "transaction" incompatible with return
type "Coroutine[Any, Any, AsyncIterator[TransactionProtocol]]" in supertype
"RepositoryProtocol"  [override]
        async def transaction(self) -> AsyncIterator[TransactionProtocol]:
        ^
infrastructure\repositories\ml_repository.py:215:5: note: Consider declaring "transaction" in supertype "RepositoryProtocol" without "async"
infrastructure\repositories\ml_repository.py:215:5: note: See https://mypy.readthedocs.io/en/stable/more_types.html#asynchronous-iterators
infrastructure\repositories\ml_repository.py:232:20: error:
"AsyncIterator[TransactionProtocol]" has no attribute "__aenter__"; maybe
"__aiter__"?  [attr-defined]
            async with self.transaction():
                       ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\ml_repository.py:232:20: error:
"AsyncIterator[TransactionProtocol]" has no attribute "__aexit__"; maybe
"__anext__" or "__aiter__"?  [attr-defined]
            async with self.transaction():
                       ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\ml_repository.py:247:16: error: Missing positional
arguments "success_count", "error_count" in call to "BulkOperationResult" 
[call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\ml_repository.py:264:16: error: Missing positional
arguments "success_count", "error_count" in call to "BulkOperationResult" 
[call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\ml_repository.py:283:16: error: Missing positional
arguments "success_count", "error_count" in call to "BulkOperationResult" 
[call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\ml_repository.py:347:16: error: Extra key
"total_models" for TypedDict "PerformanceMetricsDict"  [typeddict-unknown-key]
            return {"total_models": self.metrics["total_models"]}
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\ml_repository.py:355:16: error: Extra key "state"
for TypedDict "HealthCheckDict"  [typeddict-unknown-key]
            return {"status": "healthy", "state": self._state.value}
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\ml_repository.py:489:17: error: Unsupported operand
types for + ("None" and "int")  [operator]
                    self._metrics["cache_hits"] += 1
                    ^
infrastructure\repositories\ml_repository.py:489:17: note: Left operand is of type "int | None"
infrastructure\repositories\ml_repository.py:491:13: error: Unsupported operand
types for + ("None" and "int")  [operator]
                self._metrics["cache_misses"] += 1
                ^
infrastructure\repositories\ml_repository.py:491:13: note: Left operand is of type "int | None"
infrastructure\repositories\market_repository.py:158:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\market_repository.py:234:5: error: Return type
"AsyncIterator[MarketData]" of "stream" incompatible with return type
"Coroutine[Any, Any, AsyncIterator[MarketData]]" in supertype
"RepositoryProtocol"  [override]
        async def stream(
        ^
infrastructure\repositories\market_repository.py:234:5: note: Consider declaring "stream" in supertype "RepositoryProtocol" without "async"
infrastructure\repositories\market_repository.py:234:5: note: See https://mypy.readthedocs.io/en/stable/more_types.html#asynchronous-iterators
infrastructure\repositories\market_repository.py:243:5: error: Return type
"AsyncIterator[TransactionProtocol]" of "transaction" incompatible with return
type "Coroutine[Any, Any, AsyncIterator[TransactionProtocol]]" in supertype
"RepositoryProtocol"  [override]
        async def transaction(self) -> AsyncIterator[TransactionProtocol]:
        ^
infrastructure\repositories\market_repository.py:243:5: note: Consider declaring "transaction" in supertype "RepositoryProtocol" without "async"
infrastructure\repositories\market_repository.py:243:5: note: See https://mypy.readthedocs.io/en/stable/more_types.html#asynchronous-iterators
infrastructure\repositories\market_repository.py:260:20: error:
"AsyncIterator[TransactionProtocol]" has no attribute "__aenter__"; maybe
"__aiter__"?  [attr-defined]
            async with self.transaction() as txn:
                       ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\market_repository.py:260:20: error:
"AsyncIterator[TransactionProtocol]" has no attribute "__aexit__"; maybe
"__anext__" or "__aiter__"?  [attr-defined]
            async with self.transaction() as txn:
                       ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\market_repository.py:274:84: error: Argument
"processed_ids" to "BulkOperationResult" has incompatible type "list[str]";
expected "list[UUID | str]"  [arg-type]
    ...ess_count=success, error_count=error, errors=errors, processed_ids=ids
                                                                          ^~~
infrastructure\repositories\market_repository.py:274:84: note: "list" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance
infrastructure\repositories\market_repository.py:274:84: note: Consider using "Sequence" instead, which is covariant
infrastructure\repositories\market_repository.py:341:28: error: Incompatible
types in assignment (expression has type "list[MarketData]", target has type
"MarketData")  [assignment]
            self._cache[key] = entities
                               ^~~~~~~~
infrastructure\repositories\market_repository.py:374:16: error: Extra keys
("cache_hits", "cache_misses") for TypedDict "PerformanceMetricsDict" 
[typeddict-unknown-key]
            return {"cache_hits": self._metrics["cache_hits"], "cache_miss...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\repositories\market_repository.py:388:16: error: Extra key
"state" for TypedDict "HealthCheckDict"  [typeddict-unknown-key]
            return {"status": "healthy", "state": self._state.value}
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\market_repository.py:727:5: error: Return type
"Coroutine[Any, Any, dict[str, Any]]" of "get_performance_metrics" incompatible
with return type "Coroutine[Any, Any, PerformanceMetricsDict]" in supertype
"RepositoryProtocol"  [override]
        async def get_performance_metrics(self) -> Dict[str, Any]:
        ^
infrastructure\repositories\market_repository.py:745:5: error: Return type
"Coroutine[Any, Any, dict[str, Any]]" of "health_check" incompatible with return
type "Coroutine[Any, Any, HealthCheckDict]" in supertype "RepositoryProtocol" 
[override]
        async def health_check(self) -> Dict[str, Any]:
        ^
infrastructure\repositories\market_repository.py:780:5: error: Return type
"AsyncIterator[MarketData]" of "stream" incompatible with return type
"Coroutine[Any, Any, AsyncIterator[MarketData]]" in supertype
"RepositoryProtocol"  [override]
        async def stream(
        ^
infrastructure\repositories\market_repository.py:780:5: note: Consider declaring "stream" in supertype "RepositoryProtocol" without "async"
infrastructure\repositories\market_repository.py:780:5: note: See https://mypy.readthedocs.io/en/stable/more_types.html#asynchronous-iterators
infrastructure\repositories\market_repository.py:805:20: error: Incompatible
return value type (got "None", expected "MarketData")  [return-value]
                return None
                       ^~~~
infrastructure\repositories\base_repository.py:35:1: error: Name
"HealthCheckDict" already defined (possibly by an import)  [no-redef]
    from infrastructure.shared.types import HealthCheckDict
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\base_repository.py:118:48: error: Incompatible
types in assignment (expression has type "CacheProtocol | None", base class
"RepositoryProtocol" defined the type as "dict[UUID | str, Any]")  [assignment]
            self._cache: Optional[CacheProtocol] = None
                                                   ^~~~
infrastructure\repositories\base_repository.py:218:23: error: Unexpected
keyword argument "ttl" for "set" of "CacheProtocol"  [call-arg]
                    await self._cache.set(
                          ^
infrastructure\shared\cache.py:120:5: note: "set" of "CacheProtocol" defined here
infrastructure\repositories\base_repository.py:376:38: error: Argument 1 to
"append" of "list" has incompatible type "Any | int"; expected "UUID | str" 
[arg-type]
                    processed_ids.append(entity_id)
                                         ^~~~~~~~~
infrastructure\repositories\base_repository.py:404:38: error: Argument 1 to
"append" of "list" has incompatible type "Any | int"; expected "UUID | str" 
[arg-type]
                    processed_ids.append(entity_id)
                                         ^~~~~~~~~
infrastructure\repositories\base_repository.py:454:5: error: Return type
"AsyncIterator[TransactionProtocol]" of "transaction" incompatible with return
type "Coroutine[Any, Any, AsyncIterator[TransactionProtocol]]" in supertype
"RepositoryProtocol"  [override]
        async def transaction(self) -> AsyncIterator[TransactionProtocol]:
        ^
infrastructure\repositories\base_repository.py:454:5: note: Consider declaring "transaction" in supertype "RepositoryProtocol" without "async"
infrastructure\repositories\base_repository.py:454:5: note: See https://mypy.readthedocs.io/en/stable/more_types.html#asynchronous-iterators
infrastructure\repositories\base_repository.py:469:20: error:
"AsyncIterator[TransactionProtocol]" has no attribute "__aenter__"; maybe
"__aiter__"?  [attr-defined]
            async with self.transaction() as transaction:
                       ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\base_repository.py:469:20: error:
"AsyncIterator[TransactionProtocol]" has no attribute "__aexit__"; maybe
"__anext__" or "__aiter__"?  [attr-defined]
            async with self.transaction() as transaction:
                       ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:29:1: error:
Definition of "_cache" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class InMemoryTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:29:1: error:
Definition of "_cache_ttl" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class InMemoryTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:29:1: error:
Definition of "count" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class InMemoryTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:29:1: error:
Definition of "find_by" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class InMemoryTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:29:1: error:
Definition of "find_one_by" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class InMemoryTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:29:1: error:
Definition of "get_by_id" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class InMemoryTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:29:1: error:
Definition of "get_performance_metrics" in base class "BaseRepository" is
incompatible with definition in base class "RepositoryProtocol"  [misc]
    class InMemoryTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:29:1: error:
Definition of "health_check" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class InMemoryTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:29:1: error:
Definition of "state" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class InMemoryTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:29:1: error:
Definition of "transaction" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class InMemoryTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:35:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\trading\trading_repository.py:36:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\trading\trading_repository.py:37:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\trading\trading_repository.py:38:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\trading\trading_repository.py:362:1: error:
Definition of "_cache" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class PostgresTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:362:1: error:
Definition of "_cache_ttl" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class PostgresTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:362:1: error:
Definition of "count" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class PostgresTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:362:1: error:
Definition of "find_by" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class PostgresTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:362:1: error:
Definition of "find_one_by" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class PostgresTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:362:1: error:
Definition of "get_by_id" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class PostgresTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:362:1: error:
Definition of "get_performance_metrics" in base class "BaseRepository" is
incompatible with definition in base class "RepositoryProtocol"  [misc]
    class PostgresTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:362:1: error:
Definition of "health_check" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class PostgresTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:362:1: error:
Definition of "state" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class PostgresTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:362:1: error:
Definition of "transaction" in base class "BaseRepository" is incompatible with
definition in base class "RepositoryProtocol"  [misc]
    class PostgresTradingRepository(BaseRepository, TradingRepositoryProto...
    ^
infrastructure\repositories\trading\trading_repository.py:371:25: error: Extra
keys ("queries_executed", "cache_hits", "cache_misses", "errors",
"last_health_check") for TypedDict "RepositoryMetrics"  [typeddict-unknown-key]
            self._metrics = {
                            ^
infrastructure\repositories\trading\trading_repository.py:466:35: error:
TypedDict "RepositoryMetrics" has no key "cache_hits"  [typeddict-item]
                        self._metrics["cache_hits"] += 1
                                      ^~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:468:31: error:
TypedDict "RepositoryMetrics" has no key "cache_misses"  [typeddict-item]
                    self._metrics["cache_misses"] += 1
                                  ^~~~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:681:35: error:
TypedDict "RepositoryMetrics" has no key "cache_hits"  [typeddict-item]
                        self._metrics["cache_hits"] += 1
                                      ^~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:683:31: error:
TypedDict "RepositoryMetrics" has no key "cache_misses"  [typeddict-item]
                    self._metrics["cache_misses"] += 1
                                  ^~~~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:910:26: error:
Argument "portfolio_id" to "Order" has incompatible type "UUID"; expected
"PortfolioId"  [arg-type]
                portfolio_id=UUID(row["portfolio_id"]),
                             ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:911:25: error:
Argument "strategy_id" to "Order" has incompatible type "UUID"; expected
"StrategyId"  [arg-type]
                strategy_id=UUID(row["strategy_id"]),
                            ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:912:23: error:
Argument "signal_id" to "Order" has incompatible type "UUID | None"; expected
"SignalId | None"  [arg-type]
                signal_id=UUID(row["signal_id"]) if row["signal_id"] else ...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\repositories\trading\trading_repository.py:915:26: error:
Argument "trading_pair" to "Order" has incompatible type
"domain.entities.trading_pair.TradingPair"; expected "domain.types.TradingPair" 
[arg-type]
                trading_pair=TradingPairEntity.from_dict({"symbol": row["t...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\repositories\trading\trading_repository.py:919:22: error:
Argument "quantity" to "Order" has incompatible type "Decimal"; expected
"VolumeValue"  [arg-type]
                quantity=Decimal(row["quantity"]),
                         ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:928:29: error:
Argument "filled_quantity" to "Order" has incompatible type "Decimal"; expected
"VolumeValue"  [arg-type]
                filled_quantity=Decimal(row["filled_quantity"]),
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:953:26: error:
Argument "portfolio_id" to "Position" has incompatible type "UUID"; expected
"PortfolioId"  [arg-type]
                portfolio_id=UUID(row["portfolio_id"]),
                             ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:955:18: error: Name
"PositionSide" is not defined  [name-defined]
                side=PositionSide(row["side"]),
                     ^~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:1007:47: error:
TypedDict "RepositoryMetrics" has no key "queries_executed"  [typeddict-item]
                "queries_executed": self._metrics["queries_executed"],
                                                  ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:1008:41: error:
TypedDict "RepositoryMetrics" has no key "cache_hits"  [typeddict-item]
                "cache_hits": self._metrics["cache_hits"],
                                            ^~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:1009:43: error:
TypedDict "RepositoryMetrics" has no key "cache_misses"  [typeddict-item]
                "cache_misses": self._metrics["cache_misses"],
                                              ^~~~~~~~~~~~~~
infrastructure\repositories\trading\trading_repository.py:1010:37: error:
TypedDict "RepositoryMetrics" has no key "errors"  [typeddict-item]
                "errors": self._metrics["errors"],
                                        ^~~~~~~~
infrastructure\repositories\trading\trading_repository.py:1011:48: error:
TypedDict "RepositoryMetrics" has no key "last_health_check"  [typeddict-item]
                "last_health_check": self._metrics["last_health_check"],
                                                   ^~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\window_optimizer.py:313:13: error: Need type
annotation for "importance" (hint: "importance: dict[<type>, <type>] = ...") 
[var-annotated]
                importance = {}
                ^~~~~~~~~~
infrastructure\ml_services\window_optimizer.py:317:25: error: Argument 1 to
"zip" has incompatible type "list[str] | None"; expected "Iterable[str]" 
[arg-type]
                            self.feature_names, model.feature_importances_
                            ^~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:88:9: error: Need type
annotation for "momentum_buffer" (hint:
"momentum_buffer: dict[<type>, <type>] = ...")  [var-annotated]
            self.momentum_buffer = {}
            ^~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:102:77: error: Incompatible
default for argument "learning_rate" (default has type "None", argument has type
"float")  [assignment]
    ...lf, x: torch.Tensor, target: torch.Tensor, learning_rate: float = None
                                                                         ^~~~
infrastructure\ml_services\transformer_predictor.py:102:77: note: PEP 484 prohibits implicit Optional. Accordingly, mypy has changed its default to no_implicit_optional=True
infrastructure\ml_services\transformer_predictor.py:102:77: note: Use https://github.com/hauntsaninja/no_implicit_optional to automatically upgrade your codebase
infrastructure\ml_services\transformer_predictor.py:134:9: error: Need type
annotation for "population" (hint: "population: list[<type>] = ...") 
[var-annotated]
            self.population = []
            ^~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:214:25: error: Incompatible
types in assignment (expression has type "list[Any]", variable has type
"map[Any]")  [assignment]
                offspring = list(offspring)
                            ^~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:216:39: error: Value of
type "map[Any]" is not indexable  [index]
                for child1, child2 in zip(offspring[::2], offspring[1::2])...
                                          ^~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:262:9: error: Need type
annotation for "data_buffer" (hint: "data_buffer: list[<type>] = ...") 
[var-annotated]
            self.data_buffer = []
            ^~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:263:9: error: Need type
annotation for "performance_history" (hint:
"performance_history: list[<type>] = ...")  [var-annotated]
            self.performance_history = []
            ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:269:22: error: Incompatible
types in assignment (expression has type "AdaptiveTransformer", variable has
type "None")  [assignment]
            self.model = AdaptiveTransformer(
                         ^
infrastructure\ml_services\transformer_predictor.py:375:15: error: Need type
annotation for "history"  [var-annotated]
        history = {"train_loss": [], "val_loss": []}
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:383:20: error: "Tensor" not
callable  [operator]
                mask = model.generate_square_subsequent_mask(xb.size(1)).t...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:394:24: error: "Tensor" not
callable  [operator]
                    mask = model.generate_square_subsequent_mask(xb.size(1...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:432:20: error: "Tensor" not
callable  [operator]
                mask = model.generate_square_subsequent_mask(xb.size(1)).t...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:448:16: error: "Tensor" not
callable  [operator]
            mask = model.generate_square_subsequent_mask(xb.size(1)).to(de...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:471:9: error: Incompatible
types in assignment (expression has type "ndarray[Any, dtype[Any]]", variable
has type "list[Any]")  [assignment]
        X = np.array(X)
            ^~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:472:9: error: Incompatible
types in assignment (expression has type "ndarray[Any, dtype[Any]]", variable
has type "list[Any]")  [assignment]
        y = np.array(y).reshape(-1, 1)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:475:34: error: "list[Any]"
has no attribute "reshape"  [attr-defined]
            X = scaler.fit_transform(X.reshape(-1, X.shape[-1])).reshape(X...
                                     ^~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:475:48: error: "list[Any]"
has no attribute "shape"  [attr-defined]
            X = scaler.fit_transform(X.reshape(-1, X.shape[-1])).reshape(X...
                                                   ^~~~~~~
infrastructure\ml_services\transformer_predictor.py:486:5: error: "DataFrame"
has no attribute "to_csv"  [attr-defined]
        df.to_csv(out_csv, index=False)
        ^~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:542:63: error: Argument 2
to "PositionalEncoding" has incompatible type "float"; expected "int" 
[arg-type]
    ... self.pos_encoder = PositionalEncoding(config.d_model, config.dropout)
                                                              ^~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:578:9: error: Need type
annotation for "metrics_history" (hint: "metrics_history: list[<type>] = ...") 
[var-annotated]
            self.metrics_history = []
            ^~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:580:9: error: Need type
annotation for "models" (hint: "models: dict[<type>, <type>] = ...") 
[var-annotated]
            self.models = {}
            ^~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:581:9: error: Need type
annotation for "scalers" (hint: "scalers: dict[<type>, <type>] = ...") 
[var-annotated]
            self.scalers = {}
            ^~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:582:9: error: Need type
annotation for "metrics" (hint: "metrics: dict[<type>, <type>] = ...") 
[var-annotated]
            self.metrics = {}
            ^~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:584:9: error: Need type
annotation for "_prediction_cache" (hint:
"_prediction_cache: dict[<type>, <type>] = ...")  [var-annotated]
            self._prediction_cache = {}
            ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:585:9: error: Need type
annotation for "_feature_cache" (hint:
"_feature_cache: dict[<type>, <type>] = ...")  [var-annotated]
            self._feature_cache = {}
            ^~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:619:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["returns"] = df["close"].pct_change()
                ^~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:620:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["log_returns"] = np.log1p(features["returns"])
                ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:621:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volatility"] = features["returns"].rolling(20).s...
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:623:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["rsi"] = talib.RSI(df["close"])
                ^~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:623:31: error: Name "talib"
is not defined  [name-defined]
                features["rsi"] = talib.RSI(df["close"])
                                  ^~~~~
infrastructure\ml_services\transformer_predictor.py:624:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["macd"], features["macd_signal"], _ = talib.MACD(...
                ^~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:624:60: error: Name "talib"
is not defined  [name-defined]
    ...  features["macd"], features["macd_signal"], _ = talib.MACD(df["close"...
                                                        ^~~~~
infrastructure\ml_services\transformer_predictor.py:625:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["bb_upper"], features["bb_middle"], features["bb_...
                ^~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:626:17: error: Name "talib"
is not defined  [name-defined]
                    talib.BBANDS(df["close"])
                    ^~~~~
infrastructure\ml_services\transformer_predictor.py:628:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["atr"] = talib.ATR(df["high"], df["low"], df["clo...
                ^~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:628:31: error: Name "talib"
is not defined  [name-defined]
                features["atr"] = talib.ATR(df["high"], df["low"], df["clo...
                                  ^~~~~
infrastructure\ml_services\transformer_predictor.py:629:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["adx"] = talib.ADX(df["high"], df["low"], df["clo...
                ^~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:629:31: error: Name "talib"
is not defined  [name-defined]
                features["adx"] = talib.ADX(df["high"], df["low"], df["clo...
                                  ^~~~~
infrastructure\ml_services\transformer_predictor.py:631:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volume_ma"] = df["volume"].rolling(20).mean()
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:632:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volume_std"] = df["volume"].rolling(20).std()
                ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:633:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["volume_ratio"] = df["volume"] / features["volume...
                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:635:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["momentum"] = talib.MOM(df["close"], timeperiod=1...
                ^~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:635:36: error: Name "talib"
is not defined  [name-defined]
                features["momentum"] = talib.MOM(df["close"], timeperiod=1...
                                       ^~~~~
infrastructure\ml_services\transformer_predictor.py:636:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["roc"] = talib.ROC(df["close"], timeperiod=10)
                ^~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:636:31: error: Name "talib"
is not defined  [name-defined]
                features["roc"] = talib.ROC(df["close"], timeperiod=10)
                                  ^~~~~
infrastructure\ml_services\transformer_predictor.py:638:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["high_low_ratio"] = df["high"] / df["low"]
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:639:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["close_open_ratio"] = df["close"] / df["open"]
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:641:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["trend"] = talib.ADX(df["high"], df["low"], df["c...
                ^~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:641:33: error: Name "talib"
is not defined  [name-defined]
                features["trend"] = talib.ADX(df["high"], df["low"], df["c...
                                    ^~~~~
infrastructure\ml_services\transformer_predictor.py:642:13: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                features["trend_strength"] = abs(features["trend"])
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:646:38: error: "DataFrame"
has no attribute "fillna"  [attr-defined]
                    scaler.fit_transform(features.fillna(0)),
                                         ^~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:756:32: error: Module has
no attribute "concat"  [attr-defined]
                self.data_buffer = pd.concat([self.data_buffer, df]).tail(
                                   ^~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:764:17: error: "DataFrame"
has no attribute "values"  [attr-defined]
                X = features.values
                    ^~~~~~~~~~~~~~~
infrastructure\ml_services\transformer_predictor.py:815:58: error:
"TransformerConfig" has no attribute "metrics_window"  [attr-defined]
    ...    self.metrics_history = self.metrics_history[-self.config.metrics_w...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\ml_services\transformer_predictor.py:849:57: error: "DataFrame"
has no attribute "values"  [attr-defined]
    ...          X_scaled = self.scalers[model_id].transform(features.values)
                                                             ^~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:268:25: error: Name
"TransformerEncoderLayer" is not defined  [name-defined]
            encoder_layer = TransformerEncoderLayer(
                            ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:276:28: error: Name
"TransformerEncoder" is not defined  [name-defined]
            self.transformer = TransformerEncoder(encoder_layer, config.n_...
                               ^~~~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:401:9: error: Need type
annotation for "feature_cache" (hint:
"feature_cache: dict[<type>, <type>] = ...")  [var-annotated]
            self.feature_cache = {}
            ^~~~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:402:9: error: Need type
annotation for "prediction_cache" (hint:
"prediction_cache: dict[<type>, <type>] = ...")  [var-annotated]
            self.prediction_cache = {}
            ^~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:403:9: error: Need type
annotation for "model_state" (hint: "model_state: dict[<type>, <type>] = ...") 
[var-annotated]
            self.model_state = {}
            ^~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:405:24: error: Need type
annotation for "metrics"  [var-annotated]
            self.metrics = {
                           ^
infrastructure\ml_services\advanced_price_predictor.py:417:20: error:
"DataFrame" has no attribute "copy"  [attr-defined]
            features = df.copy()
                       ^~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:425:27: error: Name
"talib" is not defined  [name-defined]
            features["rsi"] = talib.RSI(df["close"].values)
                              ^~~~~
infrastructure\ml_services\advanced_price_predictor.py:427:40: error: Name
"talib" is not defined  [name-defined]
            macd, macd_signal, macd_hist = talib.MACD(df["close"].values)
                                           ^~~~~
infrastructure\ml_services\advanced_price_predictor.py:432:41: error: Name
"talib" is not defined  [name-defined]
            bb_upper, bb_middle, bb_lower = talib.BBANDS(df["close"].value...
                                            ^~~~~
infrastructure\ml_services\advanced_price_predictor.py:438:28: error: Name
"talib" is not defined  [name-defined]
            stoch_k, stoch_d = talib.STOCH(
                               ^~~~~
infrastructure\ml_services\advanced_price_predictor.py:444:34: error: Name
"talib" is not defined  [name-defined]
            features["williams_r"] = talib.WILLR(
                                     ^~~~~
infrastructure\ml_services\advanced_price_predictor.py:448:27: error: Name
"talib" is not defined  [name-defined]
            features["atr"] = talib.ATR(
                              ^~~~~
infrastructure\ml_services\advanced_price_predictor.py:452:27: error: Name
"talib" is not defined  [name-defined]
            features["adx"] = talib.ADX(
                              ^~~~~
infrastructure\ml_services\advanced_price_predictor.py:456:27: error: Name
"talib" is not defined  [name-defined]
            features["cci"] = talib.CCI(
                              ^~~~~
infrastructure\ml_services\advanced_price_predictor.py:460:32: error: Name
"talib" is not defined  [name-defined]
            features["momentum"] = talib.MOM(df["close"].values, timeperio...
                                   ^~~~~
infrastructure\ml_services\advanced_price_predictor.py:462:27: error: Name
"talib" is not defined  [name-defined]
            features["roc"] = talib.ROC(df["close"].values, timeperiod=10)
                              ^~~~~
infrastructure\ml_services\advanced_price_predictor.py:483:28: error: Item
"Timestamp" of "Timestamp | DatetimeIndex | Any" has no attribute "hour" 
[union-attr]
            features["hour"] = pd.to_datetime(df.index).hour
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:483:28: error: Item
"DatetimeIndex" of "Timestamp | DatetimeIndex | Any" has no attribute "hour" 
[union-attr]
            features["hour"] = pd.to_datetime(df.index).hour
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:484:35: error: Item
"Timestamp" of "Timestamp | DatetimeIndex | Any" has no attribute "dayofweek" 
[union-attr]
            features["day_of_week"] = pd.to_datetime(df.index).dayofweek
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:484:35: error: Item
"DatetimeIndex" of "Timestamp | DatetimeIndex | Any" has no attribute
"dayofweek"  [union-attr]
            features["day_of_week"] = pd.to_datetime(df.index).dayofweek
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:485:29: error: Item
"Timestamp" of "Timestamp | DatetimeIndex | Any" has no attribute "month" 
[union-attr]
            features["month"] = pd.to_datetime(df.index).month
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:485:29: error: Item
"DatetimeIndex" of "Timestamp | DatetimeIndex | Any" has no attribute "month" 
[union-attr]
            features["month"] = pd.to_datetime(df.index).month
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:504:23: error:
"DataFrame" has no attribute "corr"  [attr-defined]
            corr_matrix = features.corr().abs()
                          ^~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:523:22: error:
"DataFrame" has no attribute "iloc"  [attr-defined]
                X.append(features.iloc[i - self.config.sequence_length : i...
                         ^~~~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:527:13: error:
Incompatible types in assignment (expression has type
"ndarray[Any, dtype[Any]]", variable has type "list[Any]")  [assignment]
            X = np.array(X)
                ^~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:528:13: error:
Incompatible types in assignment (expression has type
"ndarray[Any, dtype[Any]]", variable has type "list[Any]")  [assignment]
            y = np.array(y)
                ^~~~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:530:22: error:
"list[Any]" has no attribute "reshape"  [attr-defined]
            X_reshaped = X.reshape(-1, X.shape[-1])
                         ^~~~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:530:36: error:
"list[Any]" has no attribute "shape"  [attr-defined]
            X_reshaped = X.reshape(-1, X.shape[-1])
                                       ^~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:532:37: error:
"list[Any]" has no attribute "shape"  [attr-defined]
            X_scaled = X_scaled.reshape(X.shape)
                                        ^~~~~~~
infrastructure\ml_services\advanced_price_predictor.py:618:16: error:
Incompatible return value type (got "tuple[Any, floating[Any]]", expected
"tuple[ndarray[Any, Any], float]")  [return-value]
            return ensemble_pred[0], ensemble_confidence
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\entity_system\ai_enhancement\torch_models.py:21:32: error: Name
"nn" is not defined  [name-defined]
    class CodeQualityNeuralNetwork(nn.Module):
                                   ^~
infrastructure\entity_system\ai_enhancement\torch_models.py:24:67: error:
Incompatible default for argument "hidden_sizes" (default has type "None",
argument has type "list[int]")  [assignment]
    ...init__(self, input_size: int, hidden_sizes: List[int] = None) -> None:
                                                               ^~~~
infrastructure\entity_system\ai_enhancement\torch_models.py:24:67: note: PEP 484 prohibits implicit Optional. Accordingly, mypy has changed its default to no_implicit_optional=True
infrastructure\entity_system\ai_enhancement\torch_models.py:24:67: note: Use https://github.com/hauntsaninja/no_implicit_optional to automatically upgrade your codebase
infrastructure\entity_system\ai_enhancement\torch_models.py:28:22: error: Name
"nn" is not defined  [name-defined]
            layers: List[nn.Module] = []
                         ^
infrastructure\entity_system\ai_enhancement\torch_models.py:33:21: error: Name
"nn" is not defined  [name-defined]
                        nn.Linear(prev_size, hidden_size),
                        ^~
infrastructure\entity_system\ai_enhancement\torch_models.py:34:21: error: Name
"nn" is not defined  [name-defined]
                        nn.ReLU(),
                        ^~
infrastructure\entity_system\ai_enhancement\torch_models.py:35:21: error: Name
"nn" is not defined  [name-defined]
                        nn.Dropout(0.2),
                        ^~
infrastructure\entity_system\ai_enhancement\torch_models.py:36:21: error: Name
"nn" is not defined  [name-defined]
                        nn.BatchNorm1d(hidden_size),
                        ^~
infrastructure\entity_system\ai_enhancement\torch_models.py:40:23: error: Name
"nn" is not defined  [name-defined]
            layers.append(nn.Linear(prev_size, 1))
                          ^~
infrastructure\entity_system\ai_enhancement\torch_models.py:41:24: error: Name
"nn" is not defined  [name-defined]
            self.network = nn.Sequential(*layers)
                           ^~
infrastructure\entity_system\ai_enhancement\engine.py:112:23: error: Name "ort"
is not defined  [name-defined]
                session = ort.InferenceSession(str(model_path))
                          ^~~
infrastructure\entity_system\ai_enhancement\engine.py:264:39: error: Name "np"
is not defined  [name-defined]
                    return torch.tensor([[np.random.uniform(0.5, 0.8)]])
                                          ^~
infrastructure\entity_system\ai_enhancement\engine.py:339:32: error: Name "np"
is not defined  [name-defined]
                    avg_features = np.mean(features, axis=0)
                                   ^~
infrastructure\entity_system\ai_enhancement\engine.py:341:21: error: Name "np"
is not defined  [name-defined]
                        np.clip(1.0 - avg_features[4] / 20, 0.0, 1.0)
                        ^~
infrastructure\entity_system\ai_enhancement\engine.py:344:54: error: Name "np"
is not defined  [name-defined]
    ...        predictions["performance_score"] = float(np.random.uniform(0.6...
                                                        ^~
infrastructure\entity_system\ai_enhancement\engine.py:345:58: error: Name "np"
is not defined  [name-defined]
    ...    predictions["maintainability_score"] = float(np.random.uniform(0.5...
                                                        ^~
infrastructure\entity_system\ai_enhancement\engine.py:346:53: error: Name "np"
is not defined  [name-defined]
    ...         predictions["complexity_score"] = float(np.random.uniform(0.3...
                                                        ^~
infrastructure\core\evolution_manager.py:183:30: error: Name "np" is not
defined  [name-defined]
            recent_performance = np.mean(self.performance_history[-10:])
                                 ^~
infrastructure\core\evolution_manager.py:475:53: error: Incompatible types in
assignment (expression has type "float", target has type "bool")  [assignment]
    ...             proposals["adjust_learning_rate"] = current_performance *...
                                                        ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:291:17: error: "FollowSignal" has no
attribute "to_dict"  [attr-defined]
                    self.follow_signal.to_dict() if self.follow_signal els...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:294:17: error: "FollowResult" has no
attribute "to_dict"  [attr-defined]
                    self.follow_result.to_dict() if self.follow_result els...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:510:21: error: "FollowSignal" has no
attribute "position_size_modifier"  [attr-defined]
                        signal.position_size_modifier
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:513:21: error: "FollowSignal" has no
attribute "position_size_modifier"  [attr-defined]
                        signal.position_size_modifier
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:518:60: error: "FollowSignal" has no
attribute "risk_modifier"  [attr-defined]
    ...       self.strategy_modifiers.risk_multiplier *= signal.risk_modifier
                                                         ^~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:522:21: error: "FollowSignal" has no
attribute "stop_loss_modifier"  [attr-defined]
                        signal.stop_loss_modifier
                        ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:526:20: error: "FollowSignal" has no
attribute "entry_timing"  [attr-defined]
                    if signal.entry_timing == "immediate":
                       ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:528:22: error: "FollowSignal" has no
attribute "entry_timing"  [attr-defined]
                    elif signal.entry_timing == "wait":
                         ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:532:22: error: "FollowSignal" has no
attribute "entry_timing"  [attr-defined]
                    elif signal.entry_timing == "gradual":
                         ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:540:28: error: "FollowSignal" has no
attribute "position_size_modifier"  [attr-defined]
                        1.0 + (signal.position_size_modifier - 1.0) * 0.5
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:543:28: error: "FollowSignal" has no
attribute "position_size_modifier"  [attr-defined]
                        1.0 + (signal.position_size_modifier - 1.0) * 0.5
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:558:17: error: "FollowSignal" has no
attribute "position_size_modifier"  [attr-defined]
                    signal.position_size_modifier
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:561:17: error: "FollowSignal" has no
attribute "position_size_modifier"  [attr-defined]
                    signal.position_size_modifier
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:563:61: error: "FollowSignal" has no
attribute "risk_modifier"  [attr-defined]
    ...  self.mm_pattern_context.pattern_risk_modifier = signal.risk_modifier
                                                         ^~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:565:17: error: "FollowSignal" has no
attribute "stop_loss_modifier"  [attr-defined]
                    signal.stop_loss_modifier
                    ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:567:52: error: "FollowSignal" has no
attribute "pattern_type"  [attr-defined]
                self.mm_pattern_context.pattern_type = signal.pattern_type
                                                       ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:569:58: error: "FollowSignal" has no
attribute "expected_direction"  [attr-defined]
    ...    self.mm_pattern_context.expected_direction = signal.expected_direc...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:570:55: error: "FollowSignal" has no
attribute "expected_return"  [attr-defined]
    ...       self.mm_pattern_context.expected_return = signal.expected_retur...
                                                        ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:571:52: error: "FollowSignal" has no
attribute "entry_timing"  [attr-defined]
                self.mm_pattern_context.entry_timing = signal.entry_timing
                                                       ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:583:17: error: "FollowSignal" has no
attribute "pattern_type"  [attr-defined]
                    f"Applied MM pattern modifier for {self.symbol}: patte...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:583:17: error: "FollowSignal" has no
attribute "expected_direction"  [attr-defined]
                    f"Applied MM pattern modifier for {self.symbol}: patte...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:599:33: error: "FollowSignal" has no
attribute "pattern_type"  [attr-defined]
                    "pattern_type": signal.pattern_type,
                                    ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:601:39: error: "FollowSignal" has no
attribute "expected_direction"  [attr-defined]
                    "expected_direction": signal.expected_direction,
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:602:36: error: "FollowSignal" has no
attribute "expected_return"  [attr-defined]
                    "expected_return": signal.expected_return,
                                       ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:603:33: error: "FollowSignal" has no
attribute "entry_timing"  [attr-defined]
                    "entry_timing": signal.entry_timing,
                                    ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:606:43: error: "FollowSignal" has no
attribute "position_size_modifier"  [attr-defined]
                    "position_size_modifier": signal.position_size_modifie...
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:607:34: error: "FollowSignal" has no
attribute "risk_modifier"  [attr-defined]
                    "risk_modifier": signal.risk_modifier,
                                     ^~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:608:39: error: "FollowSignal" has no
attribute "stop_loss_modifier"  [attr-defined]
                    "stop_loss_modifier": signal.stop_loss_modifier,
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:609:41: error: "FollowSignal" has no
attribute "take_profit_modifier"  [attr-defined]
                    "take_profit_modifier": signal.take_profit_modifier,
                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:639:18: error: "FollowResult" has no
attribute "actual_return"  [attr-defined]
                ] += result.actual_return
                     ^~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:641:16: error: "FollowResult" has no
attribute "success"  [attr-defined]
                if result.success:
                   ^~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:660:17: error: "FollowResult" has no
attribute "success"  [attr-defined]
                    f"Updated MM pattern result for {self.symbol}: success...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:660:17: error: "FollowResult" has no
attribute "actual_return"  [attr-defined]
                    f"Updated MM pattern result for {self.symbol}: success...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:685:50: error: Invalid index type
"SessionType" for "dict[str, SessionInfluenceSignal]"; expected type "str" 
[index]
                self.session_context.session_signals[signal.session_type] ...
                                                     ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:752:17: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                    self.strategy_modifiers.execution_delay_ms *= 1.5
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1067:29: error: Argument 1 to "set" has
incompatible type "list[float]"; expected "Iterable[str]"  [arg-type]
                return list(set(mirror_assets))  # ”бираем дубликаты
                                ^~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1103:17: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                    self.strategy_modifiers.execution_delay_ms *= 2.5
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1346:17: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                    self.strategy_modifiers.execution_delay_ms *= 1.5
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1350:17: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                    self.strategy_modifiers.execution_delay_ms *= 2.0
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1368:36: error: "SessionInfluenceResult"
has no attribute "influence_score"  [attr-defined]
                    "influence_score": self.session_influence_result.influ...
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:1370:34: error: "SessionInfluenceResult"
has no attribute "volume_impact"  [attr-defined]
                    "volume_impact": self.session_influence_result.volume_...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:1371:38: error: "SessionInfluenceResult"
has no attribute "volatility_impact"  [attr-defined]
                    "volatility_impact": self.session_influence_result.vol...
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:1372:37: error: "SessionInfluenceResult"
has no attribute "liquidity_impact"  [attr-defined]
                    "liquidity_impact": self.session_influence_result.liqu...
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:1373:33: error: "SessionInfluenceResult"
has no attribute "price_impact"  [attr-defined]
                    "price_impact": self.session_influence_result.price_im...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:1374:30: error: "Timestamp" has no
attribute "isoformat"  [attr-defined]
                    "timestamp": self.session_influence_result.timestamp.i...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:1377:24: error: "SessionInfluenceResult"
has no attribute "influence_score"  [attr-defined]
                        if self.session_influence_result.influence_score >...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1391:17: error: "SessionInfluenceResult"
has no attribute "influence_score"  [attr-defined]
                    f"Updated session influence result for {self.symbol}: ...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:1507:13: error: "object" has no
attribute "extend"  [attr-defined]
                recommendations["analytical_signals"].extend(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1513:13: error: "object" has no
attribute "append"  [attr-defined]
                recommendations["market_conditions"].append(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1518:13: error: "object" has no
attribute "append"  [attr-defined]
                recommendations["market_conditions"].append(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1523:13: error: "object" has no
attribute "append"  [attr-defined]
                recommendations["market_conditions"].append(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1529:13: error: "object" has no
attribute "append"  [attr-defined]
                recommendations["analytical_signals"].append(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1534:13: error: "object" has no
attribute "append"  [attr-defined]
                recommendations["analytical_signals"].append(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1539:13: error: "object" has no
attribute "append"  [attr-defined]
                recommendations["analytical_signals"].append(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1602:17: error: Property "confidence"
defined in "Signal" is read-only  [misc]
                    modified_signal.confidence = Percentage(
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1602:46: error: Incompatible types in
assignment (expression has type "Percentage", variable has type "Decimal") 
[assignment]
                    modified_signal.confidence = Percentage(
                                                 ^
infrastructure\agents\agent_context.py:1605:25: error: "Decimal" has no
attribute "value"  [attr-defined]
                            modified_signal.confidence.value * Decimal("1....
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1614:25: error: Property "strength"
defined in "Signal" is read-only  [misc]
                            modified_signal.strength = Percentage(
                            ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1614:52: error: Incompatible types in
assignment (expression has type "Percentage", variable has type "Decimal") 
[assignment]
                            modified_signal.strength = Percentage(
                                                       ^
infrastructure\agents\agent_context.py:1617:33: error: "Decimal" has no
attribute "value"  [attr-defined]
                                    modified_signal.strength.value * Decim...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1622:25: error: Property "strength"
defined in "Signal" is read-only  [misc]
                            modified_signal.strength = Percentage(
                            ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1622:52: error: Incompatible types in
assignment (expression has type "Percentage", variable has type "Decimal") 
[assignment]
                            modified_signal.strength = Percentage(
                                                       ^
infrastructure\agents\agent_context.py:1625:33: error: "Decimal" has no
attribute "value"  [attr-defined]
                                    modified_signal.strength.value * Decim...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1638:25: error: Property "confidence"
defined in "Signal" is read-only  [misc]
                            modified_signal.confidence = Percentage(
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1638:54: error: Incompatible types in
assignment (expression has type "Percentage", variable has type "Decimal") 
[assignment]
                            modified_signal.confidence = Percentage(
                                                         ^
infrastructure\agents\agent_context.py:1641:33: error: "Decimal" has no
attribute "value"  [attr-defined]
                                    modified_signal.confidence.value
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1645:25: error: Property "strength"
defined in "Signal" is read-only  [misc]
                            modified_signal.strength = Percentage(
                            ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1645:52: error: Incompatible types in
assignment (expression has type "Percentage", variable has type "Decimal") 
[assignment]
                            modified_signal.strength = Percentage(
                                                       ^
infrastructure\agents\agent_context.py:1648:33: error: "Decimal" has no
attribute "value"  [attr-defined]
                                    modified_signal.strength.value
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1654:17: error: Property "metadata"
defined in "Signal" is read-only  [misc]
                    modified_signal.metadata = modified_signal.metadata or...
                    ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:1723:25: error: "AggregatedSignal" has
no attribute "direction"  [attr-defined]
                direction = self.decision_reasoning_result.direction
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:2129:17: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                    self.strategy_modifiers.execution_delay_ms *= 1.5
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:2975:17: error: "StrategyModifiers" has
no attribute "entanglement_risk_multiplier"  [attr-defined]
                    modifiers.entanglement_risk_multiplier = result[
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3589:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very low order aggre...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3591:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very high order aggr...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3594:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very low position si...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3596:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very high position s...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3599:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["errors"].append("Invalid confidence mul...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3602:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very high confidence...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3605:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["errors"].append("Invalid risk multiplie...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3608:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very high risk multi...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3611:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["errors"].append("Invalid execution dela...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3614:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very high execution ...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3618:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["warnings"].append("High aggressiveness ...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3624:13: error: "object" has no
attribute "append"  [attr-defined]
                validation_result["warnings"].append(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3824:17: error: Incompatible types in
assignment (expression has type "float", variable has type "int")  [assignment]
                    self.strategy_modifiers.execution_delay_ms *= 2.0
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3837:64: error: Unsupported operand
types for * ("Decimal" and "float")  [operator]
    ...dified_confidence = min(1.0, signal.confidence * self.strategy_modifie...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:3838:60: error: Unsupported operand
types for * ("Decimal" and "float")  [operator]
    ...  modified_strength = min(1.0, signal.strength * self.strategy_modifie...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context.py:3841:31: error: Unexpected keyword
argument "timestamp" for "Signal"  [call-arg]
                modified_signal = Signal(
                                  ^
domain\value_objects\signal.py:47:5: note: "Signal" defined here
infrastructure\agents\agent_context.py:3308:25: error: Cannot determine type of
"base_signal"  [has-type]
                            self.base_signal
                            ^~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3364:21: error: "AgentContext" has no
attribute "apply_advanced_market_maker_modifier"  [attr-defined]
                        self.apply_advanced_market_maker_modifier()
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3843:28: error: Argument "confidence" to
"Signal" has incompatible type "Percentage"; expected "Decimal"  [arg-type]
                    confidence=Percentage(Decimal(str(modified_confidence)...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3844:26: error: Argument "strength" to
"Signal" has incompatible type "Percentage"; expected "Decimal"  [arg-type]
                    strength=Percentage(Decimal(str(modified_strength))),
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context.py:3860:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\agents\whales\detectors.py:8:1: error: Module
"infrastructure.core.logging" has no attribute "setup_logger"  [attr-defined]
    from infrastructure.core.logging import setup_logger
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\whales\detectors.py:15:20: error: Name "nn" is not
defined  [name-defined]
    class WhaleMLModel(nn.Module):
                       ^~
infrastructure\agents\whales\detectors.py:20:20: error: Name "nn" is not
defined  [name-defined]
            self.net = nn.Sequential(
                       ^~
infrastructure\agents\whales\detectors.py:21:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(input_dim, hidden_dim),
                ^~
infrastructure\agents\whales\detectors.py:22:13: error: Name "nn" is not
defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\whales\detectors.py:23:13: error: Name "nn" is not
defined  [name-defined]
                nn.Dropout(0.2),
                ^~
infrastructure\agents\whales\detectors.py:24:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(hidden_dim, hidden_dim // 2),
                ^~
infrastructure\agents\whales\detectors.py:25:13: error: Name "nn" is not
defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\whales\detectors.py:26:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(hidden_dim // 2, 4),
                ^~
infrastructure\agents\whales\detectors.py:35:73: error: Name "pd" is not
defined  [name-defined]
    ...et_market_data(self, pair: str, interval: str = "1m") -> pd.DataFrame:
                                                                ^
infrastructure\agents\whales\detectors.py:46:9: error: Need type annotation for
"whale_data" (hint: "whale_data: dict[<type>, <type>] = ...")  [var-annotated]
            self.whale_data = {}
            ^~~~~~~~~~~~~~~
infrastructure\agents\whales\detectors.py:49:73: error: Name "pd" is not
defined  [name-defined]
    ...et_market_data(self, pair: str, interval: str = "1m") -> pd.DataFrame:
                                                                ^
infrastructure\agents\whales\detectors.py:77:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\agents\whales\detectors.py:102:22: error: Name "np" is not
defined  [name-defined]
                prices = np.array([o["price"] for o in all_orders]).reshap...
                         ^~
infrastructure\agents\whales\detectors.py:103:21: error: Name "np" is not
defined  [name-defined]
                sizes = np.array([o["size"] for o in all_orders]).reshape(...
                        ^~
infrastructure\agents\whales\detectors.py:104:17: error: Name "np" is not
defined  [name-defined]
                X = np.hstack([prices, sizes])
                    ^~
infrastructure\agents\whales\detectors.py:114:36: error: Name "np" is not
defined  [name-defined]
                    if label != -1 and np.sum(db.labels_ == label) > 1
                                       ^~
infrastructure\agents\whales\detectors.py:134:31: error: Name "pd" is not
defined  [name-defined]
                        timestamp=pd.Timestamp(datetime.now()),
                                  ^~
infrastructure\agents\whales\detectors.py:135:34: error: Name "np" is not
defined  [name-defined]
                        volume=float(np.sum(sizes)),
                                     ^~
infrastructure\agents\whales\detectors.py:136:33: error: Name "np" is not
defined  [name-defined]
                        price=float(np.mean(prices)),
                                    ^~
infrastructure\agents\whales\detectors.py:139:28: error: Name "np" is not
defined  [name-defined]
                            if np.sum([o["size"] for o in bids])
                               ^~
infrastructure\agents\whales\detectors.py:140:27: error: Name "np" is not
defined  [name-defined]
                            > np.sum([o["size"] for o in asks])
                              ^~
infrastructure\agents\news\services.py:146:49: error: Name "NewsItem" is not
defined  [name-defined]
        def calculate_impact_score(self, news_item: "NewsItem") -> float:
                                                    ^
infrastructure\agents\news\services.py:169:42: error: Name "NewsSource" is not
defined  [name-defined]
        def _get_source_weight(self, source: "NewsSource") -> float:
                                             ^
infrastructure\agents\market_maker\ml_predictor.py:38:43: error: Name "nn" is
not defined  [name-defined]
        def _create_spread_predictor(self) -> nn.Module:
                                              ^
infrastructure\agents\market_maker\ml_predictor.py:40:16: error: Name "nn" is
not defined  [name-defined]
            return nn.Sequential(
                   ^~
infrastructure\agents\market_maker\ml_predictor.py:41:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(self.config["input_dim"], 64),
                ^~
infrastructure\agents\market_maker\ml_predictor.py:42:13: error: Name "nn" is
not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\market_maker\ml_predictor.py:43:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(64, 32),
                ^~
infrastructure\agents\market_maker\ml_predictor.py:44:13: error: Name "nn" is
not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\market_maker\ml_predictor.py:45:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(32, 1),
                ^~
infrastructure\agents\market_maker\ml_predictor.py:48:45: error: Name "nn" is
not defined  [name-defined]
        def _create_liquidity_analyzer(self) -> nn.Module:
                                                ^
infrastructure\agents\market_maker\ml_predictor.py:50:16: error: Name "nn" is
not defined  [name-defined]
            return nn.Sequential(
                   ^~
infrastructure\agents\market_maker\ml_predictor.py:51:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(self.config["input_dim"], 128),
                ^~
infrastructure\agents\market_maker\ml_predictor.py:52:13: error: Name "nn" is
not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\market_maker\ml_predictor.py:53:13: error: Name "nn" is
not defined  [name-defined]
                nn.Dropout(0.2),
                ^~
infrastructure\agents\market_maker\ml_predictor.py:54:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(128, 64),
                ^~
infrastructure\agents\market_maker\ml_predictor.py:55:13: error: Name "nn" is
not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\market_maker\ml_predictor.py:56:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(64, 3),  # support, resistance, neutral
                ^~
infrastructure\agents\market_maker\ml_predictor.py:103:20: error: Name "nn" is
not defined  [name-defined]
                loss = nn.MSELoss()(prediction, target_tensor)
                       ^~
infrastructure\agents\market_maker\ml_predictor.py:120:20: error: Name "nn" is
not defined  [name-defined]
                loss = nn.MSELoss()(prediction, targets_tensor)
                       ^~
infrastructure\agents\market_maker\ml_predictor.py:129:28: error: Name "pd" is
not defined  [name-defined]
            self, market_data: pd.DataFrame, order_book: Dict[str, Any]
                               ^
infrastructure\agents\market_maker\ml_predictor.py:152:28: error: Name "pd" is
not defined  [name-defined]
                        if not pd.isna(sma_20.iloc[-1])
                               ^~
infrastructure\agents\market_maker\ml_predictor.py:161:53: error: Name "pd" is
not defined  [name-defined]
    ...             features.append(rsi.iloc[-1] if not pd.isna(rsi.iloc[-1])...
                                                        ^~
examples\mirror_neuron_signal_example_backup.py:89:35: error: Argument
"timestamp" to "MirrorSignal" has incompatible type "datetime"; expected
"Timestamp"  [arg-type]
                            timestamp=datetime.now()
                                      ^~~~~~~~~~~~~~
examples\mirror_neuron_signal_example_backup.py:114:31: error: Incompatible
types (expression has type "datetime", TypedDict item "timestamp" has type
"Timestamp")  [typeddict-item]
                        timestamp=datetime.now(),
                                  ^~~~~~~~~~~~~~
examples\mirror_neuron_signal_example_backup.py:293:13: error: Module has no
attribute "date_range"  [attr-defined]
        dates = pd.date_range(start="2023-01-01", periods=periods, freq="1...
                ^~~~~~~~~~~~~
examples\mirror_neuron_signal_example_backup.py:313:49: error: Unsupported
operand types for - ("Series" and "float")  [operator]
            eth_adjustment = 1 + eth_correlation * (btc_series - btc_serie...
                                                    ^
examples\mirror_neuron_signal_example_backup.py:314:25: error: No overload
variant of "__rmul__" of "ndarray" matches argument type "Series"  [operator]
            trends["ETH"] = trends["ETH"] * eth_adjustment
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example_backup.py:314:25: note: Possible overload variants:
examples\mirror_neuron_signal_example_backup.py:314:25: note:     def __rmul__(self, _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], /) -> ndarray[Any, dtype[floating[Any]]]
examples\mirror_neuron_signal_example_backup.py:314:25: note:     def __rmul__(self, _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], /) -> ndarray[Any, dtype[complexfloating[Any, Any]]]
examples\mirror_neuron_signal_example_backup.py:314:25: note:     def __rmul__(self, _SupportsArray[dtype[bool_ | number[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | number[Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], /) -> ndarray[Any, dtype[number[Any]]]
examples\mirror_neuron_signal_example_backup.py:314:25: note:     def __rmul__(self, _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], /) -> ndarray[Any, dtype[timedelta64]]
examples\mirror_neuron_signal_example_backup.py:314:25: note:     def __rmul__(self, _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], /) -> Any
examples\mirror_neuron_signal_example_backup.py:321:49: error: Unsupported
operand types for - ("Series" and "float")  [operator]
            dot_adjustment = 1 + dot_correlation * (ada_series - ada_serie...
                                                    ^
examples\mirror_neuron_signal_example_backup.py:322:25: error: No overload
variant of "__rmul__" of "ndarray" matches argument type "Series"  [operator]
            trends["DOT"] = trends["DOT"] * dot_adjustment
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example_backup.py:322:25: note: Possible overload variants:
examples\mirror_neuron_signal_example_backup.py:322:25: note:     def __rmul__(self, _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], /) -> ndarray[Any, dtype[floating[Any]]]
examples\mirror_neuron_signal_example_backup.py:322:25: note:     def __rmul__(self, _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], /) -> ndarray[Any, dtype[complexfloating[Any, Any]]]
examples\mirror_neuron_signal_example_backup.py:322:25: note:     def __rmul__(self, _SupportsArray[dtype[bool_ | number[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | number[Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], /) -> ndarray[Any, dtype[number[Any]]]
examples\mirror_neuron_signal_example_backup.py:322:25: note:     def __rmul__(self, _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], /) -> ndarray[Any, dtype[timedelta64]]
examples\mirror_neuron_signal_example_backup.py:322:25: note:     def __rmul__(self, _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], /) -> Any
examples\mirror_neuron_signal_example_backup.py:352:22: error: "MirrorDetector"
has no attribute "detect_mirror_signals"; maybe "detect_mirror_signal"? 
[attr-defined]
        mirror_signals = detector.detect_mirror_signals(price_data, min_co...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\mirror_neuron_signal_example_backup.py:534:57: error: Argument 1 to
"generate_trading_signals" of "MirrorTradingStrategy" has incompatible type
"str"; expected "Symbol"  [arg-type]
    ...ding_signals = strategy.generate_trading_signals("BTC", btc_price_chan...
                                                        ^~~~~
examples\analytical_integration_example.py:96:24: error:
"MarketMakerModelAgent" has no attribute "should_proceed_with_trade" 
[attr-defined]
            should_trade = agent.should_proceed_with_trade(symbol, trade_a...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:100:27: error:
"MarketMakerModelAgent" has no attribute "get_trading_recommendations" 
[attr-defined]
            recommendations = agent.get_trading_recommendations(symbol)
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:104:24: error:
"MarketMakerModelAgent" has no attribute "calculate_with_analytics" 
[attr-defined]
            result = await agent.calculate_with_analytics(
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:129:12: error:
"MarketMakerModelAgent" has no attribute "analytical_integration" 
[attr-defined]
            if agent.analytical_integration:
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:150:23: error:
"MarketMakerModelAgent" has no attribute "analytical_integration" 
[attr-defined]
                context = agent.analytical_integration.analytical_integrat...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:158:24: error:
"MarketMakerModelAgent" has no attribute "should_proceed_with_trade" 
[attr-defined]
            should_trade = agent.should_proceed_with_trade(symbol, trade_a...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:162:31: error:
"MarketMakerModelAgent" has no attribute "get_adjusted_aggressiveness" 
[attr-defined]
            adjusted_aggression = agent.get_adjusted_aggressiveness(symbol...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:166:24: error:
"MarketMakerModelAgent" has no attribute "calculate_with_analytics" 
[attr-defined]
            result = await agent.calculate_with_analytics(
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:191:12: error:
"MarketMakerModelAgent" has no attribute "analytical_integration" 
[attr-defined]
            if agent.analytical_integration:
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:218:23: error:
"MarketMakerModelAgent" has no attribute "analytical_integration" 
[attr-defined]
                context = agent.analytical_integration.analytical_integrat...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:226:24: error:
"MarketMakerModelAgent" has no attribute "should_proceed_with_trade" 
[attr-defined]
            should_trade = agent.should_proceed_with_trade(symbol, trade_a...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:231:22: error:
"MarketMakerModelAgent" has no attribute "get_price_offset"  [attr-defined]
            buy_offset = agent.get_price_offset(symbol, base_price, "buy")
                         ^~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:232:23: error:
"MarketMakerModelAgent" has no attribute "get_price_offset"  [attr-defined]
            sell_offset = agent.get_price_offset(symbol, base_price, "sell...
                          ^~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:237:24: error:
"MarketMakerModelAgent" has no attribute "calculate_with_analytics" 
[attr-defined]
            result = await agent.calculate_with_analytics(
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:262:12: error:
"MarketMakerModelAgent" has no attribute "analytical_integration" 
[attr-defined]
            if agent.analytical_integration:
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:284:23: error:
"MarketMakerModelAgent" has no attribute "analytical_integration" 
[attr-defined]
                context = agent.analytical_integration.analytical_integrat...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:292:31: error:
"MarketMakerModelAgent" has no attribute "get_adjusted_confidence"; maybe
"get_confidence"?  [attr-defined]
            adjusted_confidence = agent.get_adjusted_confidence(symbol, 0....
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:296:25: error:
"MarketMakerModelAgent" has no attribute "get_adjusted_position_size" 
[attr-defined]
            adjusted_size = agent.get_adjusted_position_size(symbol, 1.0)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:300:24: error:
"MarketMakerModelAgent" has no attribute "calculate_with_analytics" 
[attr-defined]
            result = await agent.calculate_with_analytics(
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:325:12: error:
"MarketMakerModelAgent" has no attribute "analytical_integration" 
[attr-defined]
            if agent.analytical_integration:
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:331:30: error: Missing positional
arguments "bid_ask_forces", "gravity_distribution", "timestamp",
"volume_imbalance", "price_momentum", "volatility_score", "liquidity_score",
"market_efficiency" in call to "LiquidityGravityResult"  [call-arg]
                gravity_result = LiquidityGravityResult(
                                 ^
examples\analytical_integration_example.py:334:26: error: Extra keys
("data_points", "confidence", "processing_time_ms", "algorithm_version",
"parameters", "quality_metrics") for TypedDict "MarketMetadataDict" 
[typeddict-unknown-key]
                    metadata={
                             ^
examples\analytical_integration_example.py:345:31: error: Missing positional
arguments "symbol", "liquidity_score", "volatility_score", "overall_risk",
"timestamp" in call to "RiskAssessmentResult"  [call-arg]
                risk_assessment = RiskAssessmentResult(
                                  ^
examples\analytical_integration_example.py:360:23: error:
"MarketMakerModelAgent" has no attribute "analytical_integration" 
[attr-defined]
                context = agent.analytical_integration.analytical_integrat...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:369:24: error:
"MarketMakerModelAgent" has no attribute "should_proceed_with_trade" 
[attr-defined]
            should_trade = agent.should_proceed_with_trade(symbol, trade_a...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:373:31: error:
"MarketMakerModelAgent" has no attribute "get_adjusted_aggressiveness" 
[attr-defined]
            adjusted_aggression = agent.get_adjusted_aggressiveness(symbol...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:374:25: error:
"MarketMakerModelAgent" has no attribute "get_adjusted_position_size" 
[attr-defined]
            adjusted_size = agent.get_adjusted_position_size(symbol, 1.0)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:380:24: error:
"MarketMakerModelAgent" has no attribute "calculate_with_analytics" 
[attr-defined]
            result = await agent.calculate_with_analytics(
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
examples\analytical_integration_example.py:398:17: error: Module has no
attribute "date_range"  [attr-defined]
            dates = pd.date_range(start="2024-01-01", periods=100, freq="1...
                    ^~~~~~~~~~~~~
domain\strategies\strategy_registry.py:48:30: error: Incompatible types in
assignment (expression has type "dict[Never, Never]", variable has type
"MetadataDict")  [assignment]
        metadata: MetadataDict = field(default_factory=dict)
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\strategies\strategy_registry.py:95:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_registry.py:96:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_registry.py:97:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_registry.py:98:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_registry.py:99:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_registry.py:100:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_registry.py:101:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_registry.py:157:29: error: Argument "performance" to
"StrategyMetadata" has incompatible type
"domain.entities.strategy_performance.StrategyPerformance"; expected
"domain.types.evolution_types.StrategyPerformance"  [arg-type]
                    performance=strategy.get_performance(),
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~
domain\strategies\strategy_adapter.py:55:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_adapter.py:56:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_adapter.py:57:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_adapter.py:190:9: error: Incompatible types in
assignment (expression has type "InfrastructureStrategyProtocol", variable has
type "StrategyInterface")  [assignment]
            for strategy_id, strategy in self._infrastructure_strategies.i...
            ^
domain\services\ml_predictor.py:31:49: error: Name "pd" is not defined 
[name-defined]
        async def train_models(self, training_data: pd.DataFrame) -> bool:
                                                    ^
domain\services\ml_predictor.py:66:39: error: Name "nn" is not defined 
[name-defined]
        def _create_spread_model(self) -> nn.Module:
                                          ^
domain\services\ml_predictor.py:68:16: error: Name "nn" is not defined 
[name-defined]
            return nn.Sequential(
                   ^~
domain\services\ml_predictor.py:69:13: error: Name "nn" is not defined 
[name-defined]
                nn.Linear(10, 64),
                ^~
domain\services\ml_predictor.py:70:13: error: Name "nn" is not defined 
[name-defined]
                nn.ReLU(),
                ^~
domain\services\ml_predictor.py:71:13: error: Name "nn" is not defined 
[name-defined]
                nn.Dropout(0.2),
                ^~
domain\services\ml_predictor.py:72:13: error: Name "nn" is not defined 
[name-defined]
                nn.Linear(64, 32),
                ^~
domain\services\ml_predictor.py:73:13: error: Name "nn" is not defined 
[name-defined]
                nn.ReLU(),
                ^~
domain\services\ml_predictor.py:74:13: error: Name "nn" is not defined 
[name-defined]
                nn.Linear(32, 1),
                ^~
domain\services\ml_predictor.py:77:42: error: Name "nn" is not defined 
[name-defined]
        def _create_liquidity_model(self) -> nn.Module:
                                             ^
domain\services\ml_predictor.py:79:16: error: Name "nn" is not defined 
[name-defined]
            return nn.Sequential(
                   ^~
domain\services\ml_predictor.py:80:13: error: Name "nn" is not defined 
[name-defined]
                nn.Linear(15, 128),
                ^~
domain\services\ml_predictor.py:81:13: error: Name "nn" is not defined 
[name-defined]
                nn.ReLU(),
                ^~
domain\services\ml_predictor.py:82:13: error: Name "nn" is not defined 
[name-defined]
                nn.Dropout(0.2),
                ^~
domain\services\ml_predictor.py:83:13: error: Name "nn" is not defined 
[name-defined]
                nn.Linear(128, 64),
                ^~
domain\services\ml_predictor.py:84:13: error: Name "nn" is not defined 
[name-defined]
                nn.ReLU(),
                ^~
domain\services\ml_predictor.py:85:13: error: Name "nn" is not defined 
[name-defined]
                nn.Linear(64, 3),  # support, resistance, neutral
                ^~
domain\services\ml_predictor.py:150:49: error: Name "pd" is not defined 
[name-defined]
        async def train_models(self, training_data: pd.DataFrame) -> bool:
                                                    ^
domain\services\ml_predictor.py:185:21: error: Name "pd" is not defined 
[name-defined]
            self, data: pd.DataFrame
                        ^
domain\services\ml_predictor.py:215:21: error: Name "pd" is not defined 
[name-defined]
            self, data: pd.DataFrame
                        ^
domain\services\ml_predictor.py:276:24: error: Name "nn" is not defined 
[name-defined]
                    loss = nn.MSELoss()(predictions, train_targets)
                           ^~
domain\services\ml_predictor.py:284:36: error: Name "nn" is not defined 
[name-defined]
                            val_loss = nn.MSELoss()(val_predictions, val_t...
                                       ^~
domain\services\ml_predictor.py:317:24: error: Name "nn" is not defined 
[name-defined]
                    loss = nn.CrossEntropyLoss()(predictions, train_target...
                           ^~
domain\services\ml_predictor.py:325:36: error: Name "nn" is not defined 
[name-defined]
                            val_loss = nn.CrossEntropyLoss()(val_predictio...
                                       ^~
domain\repositories\trading_repository.py:177:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\trading_repository.py:178:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\trading_repository.py:179:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\portfolio_repository.py:82:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\portfolio_repository.py:83:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\portfolio_repository.py:86:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\ml_repository.py:61:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\ml_repository.py:62:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\market_repository.py:62:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\repositories\market_repository.py:63:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\integration.py:21:1: error: Module
"domain.protocols.exchange_protocol" has no attribute "ConnectionManager" 
[attr-defined]
    from domain.protocols.exchange_protocol import (
    ^
domain\protocols\integration.py:79:16: error: Unexpected keyword argument
"bid_price" for "MarketData"  [call-arg]
            return MarketData(
                   ^
domain\protocols\integration.py:79:16: error: Unexpected keyword argument
"ask_price" for "MarketData"  [call-arg]
            return MarketData(
                   ^
domain\protocols\integration.py:79:16: error: Unexpected keyword argument
"last_price" for "MarketData"  [call-arg]
            return MarketData(
                   ^
domain\protocols\integration.py:80:20: error: Argument "symbol" to "MarketData"
has incompatible type "str"; expected "Symbol"  [arg-type]
                symbol=symbol,
                       ^~~~~~
domain\protocols\integration.py:84:20: error: Argument "volume" to "MarketData"
has incompatible type "float"; expected "Volume"  [arg-type]
                volume=1000.0,
                       ^~~~~~
domain\protocols\integration.py:85:23: error: Argument "timestamp" to
"MarketData" has incompatible type "datetime"; expected "TimestampValue" 
[arg-type]
                timestamp=datetime.now(),
                          ^~~~~~~~~~~~~~
domain\protocols\integration.py:88:34: error: Argument 1 of "create_order" is
incompatible with supertype "ExchangeProtocol"; supertype defines the argument
type as "Order"  [override]
        async def create_order(self, order_data: Dict[str, Any]) -> Dict[s...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~
domain\protocols\integration.py:88:34: note: This violates the Liskov substitution principle
domain\protocols\integration.py:88:34: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
domain\protocols\integration.py:114:20: error: Argument "id" to "Order" has
incompatible type "str"; expected "OrderId"  [arg-type]
                    id=order_id,
                       ^~~~~~~~
domain\protocols\integration.py:131:5: error: Return type
"Coroutine[Any, Any, dict[str, Any]]" of "train_model" incompatible with return
type "Coroutine[Any, Any, Model]" in supertype "MLProtocol"  [override]
        async def train_model(self, model_id: str, training_data: Any, con...
        ^
domain\protocols\integration.py:131:33: error: Argument 1 of "train_model" is
incompatible with supertype "MLProtocol"; supertype defines the argument type as
"ModelId"  [override]
        async def train_model(self, model_id: str, training_data: Any, con...
                                    ^~~~~~~~~~~~~
domain\protocols\integration.py:131:33: note: This violates the Liskov substitution principle
domain\protocols\integration.py:131:33: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
domain\protocols\integration.py:131:68: error: Argument 3 of "train_model" is
incompatible with supertype "MLProtocol"; supertype defines the argument type as
"TrainingConfig"  [override]
    ...n_model(self, model_id: str, training_data: Any, config: Dict[str, Any...
                                                        ^~~~~~~~~~~~~~~~~~~~~~
domain\protocols\integration.py:145:5: error: Return type
"Coroutine[Any, Any, dict[str, Any] | None]" of "predict" incompatible with
return type "Coroutine[Any, Any, Prediction | None]" in supertype "MLProtocol" 
[override]
        async def predict(self, model_id: str, features: Dict[str, Any], c...
        ^
domain\protocols\integration.py:145:29: error: Argument 1 of "predict" is
incompatible with supertype "MLProtocol"; supertype defines the argument type as
"ModelId"  [override]
        async def predict(self, model_id: str, features: Dict[str, Any], c...
                                ^~~~~~~~~~~~~
domain\protocols\integration.py:145:29: note: This violates the Liskov substitution principle
domain\protocols\integration.py:145:29: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
domain\protocols\integration.py:145:70: error: Argument 3 of "predict" is
incompatible with supertype "MLProtocol"; supertype defines the argument type as
"PredictionConfig | None"  [override]
    ...t(self, model_id: str, features: Dict[str, Any], config: Optional[Dict...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
domain\protocols\integration.py:171:5: error: Return type
"Coroutine[Any, Any, dict[str, Any]]" of "analyze_market" incompatible with
return type "Coroutine[Any, Any, MarketAnalysisResult]" in supertype
"StrategyProtocol"  [override]
        async def analyze_market(self, market_data: Any, strategy_type: st...
        ^
domain\protocols\integration.py:171:54: error: Argument 2 of "analyze_market"
is incompatible with supertype "StrategyProtocol"; supertype defines the
argument type as "StrategyType"  [override]
    ...async def analyze_market(self, market_data: Any, strategy_type: str, a...
                                                        ^~~~~~~~~~~~~~~~~~
domain\protocols\integration.py:171:54: note: This violates the Liskov substitution principle
domain\protocols\integration.py:171:54: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
domain\protocols\integration.py:211:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\integration.py:234:28: error: Argument 1 of "delete" is
incompatible with supertype "RepositoryProtocol"; supertype defines the argument
type as "UUID | str"  [override]
        async def delete(self, entity_id: str) -> bool:
                               ^~~~~~~~~~~~~~
domain\protocols\integration.py:234:28: note: This violates the Liskov substitution principle
domain\protocols\integration.py:234:28: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
domain\protocols\examples.py:149:25: error: "TradingPair" has no attribute
"symbol"  [attr-defined]
            validate_symbol(order.trading_pair.symbol)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~
domain\protocols\examples.py:165:29: error: "VolumeValue" has no attribute
"value"  [attr-defined]
                "quantity": str(order.quantity.value),
                                ^~~~~~~~~~~~~~~~~~~~
domain\protocols\examples.py:272:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\protocols\examples.py:273:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
application\strategy_advisor\mirror_map_builder.py:32:43: error:
"type[Timestamp]" has no attribute "now"  [attr-defined]
            default_factory=lambda: Timestamp(pd.Timestamp.now().timestamp...
                                              ^~~~~~~~~~~~~~~~
application\strategy_advisor\mirror_map_builder.py:151:20: error: "Series" has
no attribute "isna"  [attr-defined]
                    if series.isna().all():
                       ^~~~~~~~~~~
application\strategy_advisor\mirror_map_builder.py:227:37: error:
"type[Timestamp]" has no attribute "now"  [attr-defined]
                    timestamp=Timestamp(pd.Timestamp.now().timestamp()),
                                        ^~~~~~~~~~~~~~~~
application\strategy_advisor\mirror_map_builder.py:305:28: error:
"type[Timestamp]" has no attribute "now"  [attr-defined]
                current_time = pd.Timestamp.now().timestamp()
                               ^~~~~~~~~~~~~~~~
application\strategy_advisor\mirror_map_builder.py:511:33: error:
"type[Timestamp]" has no attribute "now"  [attr-defined]
                time_since_update = pd.Timestamp.now().timestamp() - self....
                                    ^~~~~~~~~~~~~~~~
application\services\trading_service.py:293:22: error: Argument "side" to
"Trade" has incompatible type "domain.entities.order.OrderSide"; expected
"domain.entities.trading.OrderSide"  [arg-type]
                    side=order.side,
                         ^~~~~~~~~~
application\services\trading_service.py:480:22: error: Argument "side" to
"Trade" has incompatible type "domain.entities.order.OrderSide"; expected
"domain.entities.trading.OrderSide"  [arg-type]
                    side=order.side,
                         ^~~~~~~~~~
application\services\risk_service.py:128:34: error: Need type annotation for
"existing_positions"  [var-annotated]
                existing_positions = getattr(portfolio, 'get_positions', l...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\risk_service.py:163:34: error: Need type annotation for
"existing_positions"  [var-annotated]
                existing_positions = getattr(portfolio, 'get_positions', l...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\risk_service.py:195:34: error: Need type annotation for
"existing_positions"  [var-annotated]
                existing_positions = getattr(portfolio, 'get_positions', l...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\risk_service.py:221:34: error: Need type annotation for
"existing_positions"  [var-annotated]
                existing_positions = getattr(portfolio, 'get_positions', l...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\risk_service.py:249:34: error: Need type annotation for
"existing_positions"  [var-annotated]
                existing_positions = getattr(portfolio, 'get_positions', l...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\risk_service.py:285:30: error: Argument "trading_pair" to
"Order" has incompatible type "Symbol"; expected "TradingPair"  [arg-type]
                    trading_pair=position.trading_pair.symbol,
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\risk_service.py:302:35: error: "<typing special form>" has
no attribute "CLOSED"  [attr-defined]
                    position.status = PositionStatusType.CLOSED
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~
application\filters\orderbook_filter.py:146:56: error: Argument 1 to
"analyze_noise" of "NoiseAnalyzer" has incompatible type
"domain.entities.orderbook.OrderBookSnapshot"; expected
"domain.types.intelligence_types.OrderBookSnapshot"  [arg-type]
                result = self.noise_analyzer.analyze_noise(order_book)
                                                           ^~~~~~~~~~
application\evolution\evolution_orchestrator.py:61:59: error: Missing
positional argument "storage" in call to "EvolutionMigration"  [call-arg]
    ...self.evolution_migration = evolution_migration or EvolutionMigration()
                                                         ^~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:128:52: error: No overload
variant of "int" matches argument type "object"  [call-overload]
    ...      self.stats["total_candidates_generated"] = int(self.stats.get("t...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
application\evolution\evolution_orchestrator.py:128:52: note: Possible overload variants:
application\evolution\evolution_orchestrator.py:128:52: note:     def __new__(cls, str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc = ..., /) -> int
application\evolution\evolution_orchestrator.py:128:52: note:     def __new__(cls, str | bytes | bytearray, /, base: SupportsIndex) -> int
application\evolution\evolution_orchestrator.py:142:21: error: Unsupported
target for indexed assignment ("DataFrame")  [index]
                        data["trading_pair"] = pair
                        ^~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:149:25: error: Module has no
attribute "concat"  [attr-defined]
            combined_data = pd.concat(all_data, ignore_index=True)
                            ^~~~~~~~~
application\evolution\evolution_orchestrator.py:185:41: error:
"type[EvolutionStatus]" has no attribute "ERROR"  [attr-defined]
                    candidate.update_status(EvolutionStatus.ERROR)
                                            ^~~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:187:52: error: No overload
variant of "int" matches argument type "object"  [call-overload]
    ...      self.stats["total_candidates_evaluated"] = int(self.stats.get("t...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
application\evolution\evolution_orchestrator.py:187:52: note: Possible overload variants:
application\evolution\evolution_orchestrator.py:187:52: note:     def __new__(cls, str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc = ..., /) -> int
application\evolution\evolution_orchestrator.py:187:52: note:     def __new__(cls, str | bytes | bytearray, /, base: SupportsIndex) -> int
application\evolution\evolution_orchestrator.py:242:9: error: Unsupported
operand types for + ("object" and "int")  [operator]
            self.stats["total_candidates_generated"] += len(children) + le...
            ^
application\evolution\evolution_orchestrator.py:249:43: error: No overload
variant of "int" matches argument type "object"  [call-overload]
            self.stats["total_generations"] = int(self.stats.get("total_ge...
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\evolution\evolution_orchestrator.py:249:43: note: Possible overload variants:
application\evolution\evolution_orchestrator.py:249:43: note:     def __new__(cls, str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc = ..., /) -> int
application\evolution\evolution_orchestrator.py:249:43: note:     def __new__(cls, str | bytes | bytearray, /, base: SupportsIndex) -> int
application\evolution\evolution_orchestrator.py:301:9: error: No return value
expected  [return-value]
            return final_report
            ^~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:311:17: error: Unsupported
operand types for + ("object" and "int")  [operator]
                    self.stats["total_strategies_approved"] += 1
                    ^
application\evolution\evolution_orchestrator.py:335:28: error: List
comprehension has incompatible type List[dict[str, Any]]; expected List[str] 
[misc]
                "indicators": [ind.to_dict() for ind in candidate.indicato...
                               ^~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:336:25: error: List
comprehension has incompatible type List[dict[str, Any]]; expected List[str] 
[misc]
                "filters": [filt.to_dict() for filt in candidate.filters],
                            ^~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:337:29: error: List
comprehension has incompatible type List[dict[str, Any]]; expected List[str] 
[misc]
                "entry_rules": [rule.to_dict() for rule in candidate.entry...
                                ^~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:338:28: error: List
comprehension has incompatible type List[dict[str, Any]]; expected List[str] 
[misc]
                "exit_rules": [rule.to_dict() for rule in candidate.exit_r...
                               ^~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:355:17: error: Incompatible
types in "await" (actual type "None", expected type "Awaitable[Any]")  [misc]
                    await self.on_strategy_approved(candidate, evaluation)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:368:31: error: "object" has no
attribute "isoformat"  [attr-defined]
                    "start_time": self.stats["start_time"].isoformat(),
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:371:21: error: No overload
variant of "__sub__" of "datetime" matches argument type "object"  [operator]
                        datetime.now() - self.stats["start_time"]
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:371:21: note: Possible overload variants:
application\evolution\evolution_orchestrator.py:371:21: note:     def __sub__(self, datetime, /) -> timedelta
application\evolution\evolution_orchestrator.py:371:21: note:     def __sub__(self, timedelta, /) -> datetime
application\evolution\evolution_orchestrator.py:467:19: error:
"StrategyStorage" has no attribute "save_candidate"; maybe
"save_strategy_candidate"?  [attr-defined]
                await self.strategy_storage.save_candidate(candidate)
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:477:32: error:
"StrategyStorage" has no attribute "get_all_candidates"; maybe
"get_strategy_candidates"?  [attr-defined]
                candidates = await self.strategy_storage.get_all_candidate...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:489:19: error: "set_evaluation"
of "EvolutionCache" does not return a value (it only ever returns None) 
[func-returns-value]
                await self.evolution_cache.set_evaluation(candidate_id, ev...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\evolution\evolution_orchestrator.py:500:20: error: Incompatible
types in "await" (actual type "Any | None", expected type "Awaitable[Any]") 
[misc]
                return await self.evolution_cache.get_evaluation(candidate...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\evolution\evolution_orchestrator.py:518:13: error: Incompatible
types in "await" (actual type "BackupMetadata", expected type "Awaitable[Any]") 
[misc]
                await self.evolution_backup.create_backup(backup_data)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:518:55: error: Argument 1 to
"create_backup" of "EvolutionBackup" has incompatible type "dict[str, object]";
expected "str | Path | None"  [arg-type]
                await self.evolution_backup.create_backup(backup_data)
                                                          ^~~~~~~~~~~
application\evolution\evolution_orchestrator.py:528:27: error: Incompatible
types in "await" (actual type "bool", expected type "Awaitable[Any]")  [misc]
                backup_data = await self.evolution_backup.restore_backup(b...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\evolution\evolution_orchestrator.py:553:19: error:
"EvolutionMigration" has no attribute "run_migration"  [attr-defined]
                await self.evolution_migration.run_migration()
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:563:27: error: Incompatible
types in "await" (actual type "dict[str, Any]", expected type "Awaitable[Any]") 
[misc]
                cache_stats = await self.evolution_cache.get_statistics()
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:564:29: error: Incompatible
types in "await" (actual type "StorageStatistics", expected type
"Awaitable[Any]")  [misc]
                storage_stats = await self.strategy_storage.get_statistics...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\evolution\evolution_orchestrator.py:565:34: error:
"EvolutionBackup" has no attribute "get_statistics"  [attr-defined]
                backup_stats = await self.evolution_backup.get_statistics(...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\test_session_marker_integration.py:7:1: error: Module
"domain.sessions.session_marker" has no attribute "SessionContext"; maybe
"MarketSessionContext"?  [attr-defined]
    from domain.sessions.session_marker import SessionMarker, SessionConte...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_session_marker_integration.py:7:1: error: Module
"domain.sessions.session_marker" has no attribute "TradingSession" 
[attr-defined]
    from domain.sessions.session_marker import SessionMarker, SessionConte...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_session_marker_integration.py:14:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_session_influence_analyzer_integration.py:9:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_reversal_prediction_integration.py:20:37: error: Name "pd" is not
defined  [name-defined]
        def sample_market_data(self) -> pd.DataFrame:
                                        ^
tests\test_reversal_prediction_integration.py:22:17: error: Name "pd" is not
defined  [name-defined]
            dates = pd.date_range(start="2024-01-01", periods=200, freq="1...
                    ^~
tests\test_reversal_prediction_integration.py:24:17: error: Name "np" is not
defined  [name-defined]
            trend = np.linspace(100, 120, 100)  # ¬осход€щий тренд
                    ^~
tests\test_reversal_prediction_integration.py:25:20: error: Name "np" is not
defined  [name-defined]
            reversal = np.linspace(120, 110, 100)  # Ќисход€щий тренд посл...
                       ^~
tests\test_reversal_prediction_integration.py:26:18: error: Name "np" is not
defined  [name-defined]
            prices = np.concatenate([trend, reversal])
                     ^~
tests\test_reversal_prediction_integration.py:28:17: error: Name "np" is not
defined  [name-defined]
            noise = np.random.normal(0, 0.5, 200)
                    ^~
tests\test_reversal_prediction_integration.py:31:16: error: Name "pd" is not
defined  [name-defined]
            data = pd.DataFrame(
                   ^~
tests\test_reversal_prediction_integration.py:34:34: error: Name "np" is not
defined  [name-defined]
                    "high": prices + np.random.uniform(0, 1, 200),
                                     ^~
tests\test_reversal_prediction_integration.py:35:33: error: Name "np" is not
defined  [name-defined]
                    "low": prices - np.random.uniform(0, 1, 200),
                                    ^~
tests\test_reversal_prediction_integration.py:37:27: error: Name "np" is not
defined  [name-defined]
                    "volume": np.random.uniform(1000, 5000, 200),
                              ^~
tests\test_reversal_prediction_integration.py:105:16: error: Too many arguments
for "ReversalController"  [call-arg]
            return ReversalController(mock_agent_context, mock_global_pred...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_reversal_prediction_integration.py:112:63: error: Name "pd" is not
defined  [name-defined]
    ...f test_pivot_point_extraction(self, sample_market_data: pd.DataFrame):
                                                               ^
tests\test_reversal_prediction_integration.py:127:69: error: Name "pd" is not
defined  [name-defined]
    ..._fibonacci_levels_calculation(self, sample_market_data: pd.DataFrame):
                                                               ^
tests\test_reversal_prediction_integration.py:141:66: error: Name "pd" is not
defined  [name-defined]
    ...est_volume_profile_extraction(self, sample_market_data: pd.DataFrame):
                                                               ^
tests\test_reversal_prediction_integration.py:176:74: error: Name "pd" is not
defined  [name-defined]
    ...eversal_predictor: ReversalPredictor, sample_market_data: pd.DataFrame
                                                                 ^
tests\test_reversal_prediction_integration.py:264:90: error: Name "pd" is not
defined  [name-defined]
    ...arket_service.return_value.get_ohlcv_data.return_value = pd.DataFrame(
                                                                ^~
tests\test_reversal_prediction_integration.py:283:25: error: Name "Price" is
not defined  [name-defined]
                pivot_price=Price(50000.0),
                            ^~~~~
tests\test_reversal_prediction_integration.py:284:24: error: Argument
"confidence" to "ReversalSignal" has incompatible type "float"; expected
"ConfidenceScore"  [arg-type]
                confidence=0.8,
                           ^~~
tests\test_reversal_prediction_integration.py:286:29: error: Argument
"signal_strength" to "ReversalSignal" has incompatible type "float"; expected
"SignalStrengthScore"  [arg-type]
                signal_strength=0.7,
                                ^~~
tests\test_reversal_prediction_integration.py:287:23: error: Name "Timestamp"
is not defined  [name-defined]
                timestamp=Timestamp(datetime.now().timestamp()),
                          ^~~~~~~~~
tests\test_reversal_prediction_integration.py:311:25: error: Name "Price" is
not defined  [name-defined]
                pivot_price=Price(50000.0),
                            ^~~~~
tests\test_reversal_prediction_integration.py:312:24: error: Argument
"confidence" to "ReversalSignal" has incompatible type "float"; expected
"ConfidenceScore"  [arg-type]
                confidence=0.7,
                           ^~~
tests\test_reversal_prediction_integration.py:314:29: error: Argument
"signal_strength" to "ReversalSignal" has incompatible type "float"; expected
"SignalStrengthScore"  [arg-type]
                signal_strength=0.6,
                                ^~~
tests\test_reversal_prediction_integration.py:315:23: error: Name "Timestamp"
is not defined  [name-defined]
                timestamp=Timestamp(datetime.now().timestamp()),
                          ^~~~~~~~~
tests\test_reversal_prediction_integration.py:337:25: error: Name "Price" is
not defined  [name-defined]
                pivot_price=Price(50000.0),
                            ^~~~~
tests\test_reversal_prediction_integration.py:338:24: error: Argument
"confidence" to "ReversalSignal" has incompatible type "float"; expected
"ConfidenceScore"  [arg-type]
                confidence=0.3,
                           ^~~
tests\test_reversal_prediction_integration.py:340:29: error: Argument
"signal_strength" to "ReversalSignal" has incompatible type "float"; expected
"SignalStrengthScore"  [arg-type]
                signal_strength=0.3,  # Ќизка€ сила
                                ^~~
tests\test_reversal_prediction_integration.py:341:23: error: Name "Timestamp"
is not defined  [name-defined]
                timestamp=Timestamp(datetime.now().timestamp()),
                          ^~~~~~~~~
tests\test_reversal_prediction_integration.py:365:29: error: Name "pd" is not
defined  [name-defined]
            sample_market_data: pd.DataFrame,
                                ^
tests\test_reversal_prediction_integration.py:439:25: error: Name "Price" is
not defined  [name-defined]
                pivot_price=Price(50000.0),
                            ^~~~~
tests\test_reversal_prediction_integration.py:440:24: error: Argument
"confidence" to "ReversalSignal" has incompatible type "float"; expected
"ConfidenceScore"  [arg-type]
                confidence=0.8,
                           ^~~
tests\test_reversal_prediction_integration.py:442:29: error: Argument
"signal_strength" to "ReversalSignal" has incompatible type "float"; expected
"SignalStrengthScore"  [arg-type]
                signal_strength=0.7,
                                ^~~
tests\test_reversal_prediction_integration.py:443:23: error: Name "Timestamp"
is not defined  [name-defined]
                timestamp=Timestamp(old_timestamp.timestamp()),
                          ^~~~~~~~~
tests\test_pattern_discovery_integration.py:11:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_noise_analyzer_integration.py:20:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import (
    ^
tests\test_mm_pattern_integration.py:15:1: error: Module
"infrastructure.market_profiles" has no attribute "MarketMakerStorage" 
[attr-defined]
    from infrastructure.market_profiles import MarketMakerStorage
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\test_mm_pattern_integration.py:17:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_mm_pattern_integration.py:411:5: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\test_mirror_neuron_integration.py:48:36: error: Value of type
"Callable[[], Any]" is not indexable  [index]
                        noise[lag:] += price_data[assets[i - 1]].iloc[:-la...
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\test_mirror_neuron_integration.py:51:31: error: Module has no attribute
"date_range"  [attr-defined]
                    prices, index=pd.date_range("2024-01-01", periods=peri...
                                  ^~~~~~~~~~~~~
tests\test_market_pattern_recognizer_integration.py:9:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_live_adaptation_integration.py:7:1: error: Module
"infrastructure.ml_services.live_adaptation" has no attribute
"LiveAdaptationModel"; maybe "LiveAdaptation"?  [attr-defined]
    from infrastructure.ml_services.live_adaptation import LiveAdaptationM...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_live_adaptation_integration.py:7:1: error: Module
"infrastructure.ml_services.live_adaptation" has no attribute
"AdaptationMetrics"  [attr-defined]
    from infrastructure.ml_services.live_adaptation import LiveAdaptationM...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_live_adaptation_integration.py:14:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_live_adaptation_integration.py:212:31: error: "await" outside
coroutine ("async def")  [await-not-async]
                modified_signal = await mock_trading_orchestrator._apply_l...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_evolutionary_transformer_integration.py:12:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import (
    ^
tests\test_decision_reasoner_integration.py:7:1: error: Module
"infrastructure.ml_services.decision_reasoner" has no attribute "TradeDecision" 
[attr-defined]
    from infrastructure.ml_services.decision_reasoner import DecisionReaso...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_decision_reasoner_integration.py:9:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_ddd_architecture.py:15:1: error: Module "domain.entities.risk" has
no attribute "RiskLimit"  [attr-defined]
    from domain.entities.risk import (RiskLevel, RiskLimit, RiskManager,
    ^
tests\test_ddd_architecture.py:20:1: error: Module "domain.entities.trading"
has no attribute "Order"; maybe "OrderId"?  [attr-defined]
    from domain.entities.trading import Order, OrderSide, OrderStatus, Ord...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\test_analytical_integration.py:13:1: error: Module
"infrastructure.agents.agent_market_maker_model" has no attribute
"MarketMakerModelAgent"  [attr-defined]
    from infrastructure.agents.agent_market_maker_model import \
    ^
tests\test_analytical_integration.py:15:1: error: Module
"infrastructure.agents.analytical_integration" has no attribute
"AnalyticalIntegration"  [attr-defined]
    from infrastructure.agents.analytical_integration import (
    ^
tests\test_analytical_integration.py:15:1: error: Module
"infrastructure.agents.analytical_integration" has no attribute
"AnalyticalIntegrationConfig"  [attr-defined]
    from infrastructure.agents.analytical_integration import (
    ^
tests\validation\test_business_logic.py:8:1: error: Module
"domain.entities.trading" has no attribute "Order"; maybe "OrderId"? 
[attr-defined]
    from domain.entities.trading import Signal, SignalType, Order, OrderSi...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\validation\test_business_logic.py:11:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_repositories.py:8:1: error: Module "domain.entities.trading"
has no attribute "Order"; maybe "OrderId"?  [attr-defined]
    from domain.entities.trading import Order, Trade, Position, OrderSide,...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "IntegrationProtocol"; maybe
"IntegrationTestMLProtocol", "IntegrationTestExchangeProtocol", or
"IntegrationTestStrategyProtocol"?  [attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "ProtocolOrchestrator" 
[attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "ServiceCoordinator" 
[attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "EventBus"  [attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "MessageQueue"  [attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "IntegrationConfig" 
[attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "OrchestrationResult" 
[attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "CoordinationResult" 
[attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "EventData"  [attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "MessageData"  [attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "IntegrationError" 
[attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "OrchestrationError" 
[attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "CoordinationError" 
[attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "EventBusError"  [attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\test_protocols_integration.py:9:1: error: Module
"domain.protocols.integration" has no attribute "MessageQueueError" 
[attr-defined]
    from domain.protocols.integration import (
    ^
tests\unit\application_tests\test_strategy_advisor.py:28:16: error: Too many
arguments for "MirrorMapBuilder"  [call-arg]
            return MirrorMapBuilder(market_repo, pattern_repo, strategy_re...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:51:22: error:
Incompatible types in "await" (actual type "MirrorMap", expected type
"Awaitable[Any]")  [misc]
            mirror_map = await builder.build_mirror_map(symbols, timeframe...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:51:62: error: Argument 2
to "build_mirror_map" of "MirrorMapBuilder" has incompatible type "str";
expected "dict[str, Series]"  [arg-type]
    ...       mirror_map = await builder.build_mirror_map(symbols, timeframe)
                                                                   ^~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:75:30: error:
"MirrorMapBuilder" has no attribute "_analyze_correlations"  [attr-defined]
            correlations = await builder._analyze_correlations(symbols, ti...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:95:33: error:
"MirrorMapBuilder" has no attribute "_analyze_pattern_mirrors"  [attr-defined]
            pattern_mirrors = await builder._analyze_pattern_mirrors(symbo...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:117:34: error:
"MirrorMapBuilder" has no attribute "_analyze_strategy_mirrors"  [attr-defined]
            strategy_mirrors = await builder._analyze_strategy_mirrors(sym...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:138:25: error:
"MirrorMapBuilder" has no attribute "_group_mirrors"  [attr-defined]
            mirror_groups = builder._group_mirrors(pattern_mirrors, strate...
                            ^~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:159:27: error:
"MirrorMapBuilder" has no attribute "_generate_recommendations"  [attr-defined]
            recommendations = builder._generate_recommendations(mirror_gro...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:174:20: error:
"MirrorMapBuilder" has no attribute "_calculate_mirror_strength"  [attr-defined]
            strength = builder._calculate_mirror_strength(pattern1, patter...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:186:31: error:
"MirrorMapBuilder" has no attribute "_find_strong_correlations"  [attr-defined]
            strong_correlations = builder._find_strong_correlations(correl...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:197:28: error:
"MirrorMapBuilder" has no attribute "_calculate_overall_strength" 
[attr-defined]
            overall_strength = builder._calculate_overall_strength(pattern...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:210:17: error:
Incompatible types in "await" (actual type "dict[str, Any]", expected type
"Awaitable[Any]")  [misc]
            stats = await builder.get_mirror_map_statistics(symbols, timef...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\application_tests\test_strategy_advisor.py:210:23: error: Too many
arguments for "get_mirror_map_statistics" of "MirrorMapBuilder"  [call-arg]
            stats = await builder.get_mirror_map_statistics(symbols, timef...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\application_tests\test_strategy_advisor.py:225:16: error:
"MirrorMapBuilder" has no attribute "_validate_symbols"  [attr-defined]
            assert builder._validate_symbols(valid_symbols) is True
                   ^~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:227:9: error: Need type
annotation for "empty_symbols" (hint: "empty_symbols: list[<type>] = ...") 
[var-annotated]
            empty_symbols = []
            ^~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:228:16: error:
"MirrorMapBuilder" has no attribute "_validate_symbols"  [attr-defined]
            assert builder._validate_symbols(empty_symbols) is False
                   ^~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:231:16: error:
"MirrorMapBuilder" has no attribute "_validate_symbols"  [attr-defined]
            assert builder._validate_symbols(single_symbol) is False
                   ^~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_strategy_advisor.py:236:22: error:
"MirrorMapBuilder" has no attribute "_calculate_confidence_score" 
[attr-defined]
            confidence = builder._calculate_confidence_score(pattern_mirro...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:35:30: error: "OrderBookPreFilter"
has no attribute "filter_by_price_range"  [attr-defined]
            filtered_orderbook = filter_instance.filter_by_price_range(
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:49:30: error: "OrderBookPreFilter"
has no attribute "filter_by_quantity_threshold"  [attr-defined]
            filtered_orderbook = filter_instance.filter_by_quantity_thresh...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:61:30: error: "OrderBookPreFilter"
has no attribute "filter_by_spread"  [attr-defined]
            filtered_orderbook = filter_instance.filter_by_spread(
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:74:30: error: "OrderBookPreFilter"
has no attribute "filter_by_depth"  [attr-defined]
            filtered_orderbook = filter_instance.filter_by_depth(
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:85:30: error: "OrderBookPreFilter"
has no attribute "remove_outliers"  [attr-defined]
            filtered_orderbook = filter_instance.remove_outliers(sample_or...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:94:32: error: "OrderBookPreFilter"
has no attribute "normalize_orderbook"  [attr-defined]
            normalized_orderbook = filter_instance.normalize_orderbook(sam...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:106:19: error:
"OrderBookPreFilter" has no attribute "calculate_orderbook_metrics" 
[attr-defined]
            metrics = filter_instance.calculate_orderbook_metrics(sample_o...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:127:30: error:
"OrderBookPreFilter" has no attribute "filter_invalid_data"  [attr-defined]
            filtered_orderbook = filter_instance.filter_invalid_data(inval...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:138:30: error:
"OrderBookPreFilter" has no attribute "apply_multiple_filters"  [attr-defined]
            filtered_orderbook = filter_instance.apply_multiple_filters(
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:143:51: error: Unsupported operand
types for <= ("int" and "object")  [operator]
    ...       assert len(filtered_orderbook["bids"]) <= filters_config["max_d...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
tests\unit\application_tests\test_filters.py:144:51: error: Unsupported operand
types for <= ("int" and "object")  [operator]
    ...       assert len(filtered_orderbook["asks"]) <= filters_config["max_d...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
tests\unit\application_tests\test_filters.py:146:48: error: Unsupported operand
types for >= ("Decimal" and "object")  [operator]
                assert Decimal(bid["quantity"]) >= filters_config["min_qua...
                                                   ^~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\application_tests\test_filters.py:148:48: error: Unsupported operand
types for >= ("Decimal" and "object")  [operator]
                assert Decimal(ask["quantity"]) >= filters_config["min_qua...
                                                   ^~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\application_tests\test_filters.py:157:29: error:
"OrderBookPreFilter" has no attribute "filter_by_price_range"  [attr-defined]
            filtered_by_price = filter_instance.filter_by_price_range(
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_filters.py:162:32: error:
"OrderBookPreFilter" has no attribute "filter_by_quantity_threshold" 
[attr-defined]
            filtered_by_quantity = filter_instance.filter_by_quantity_thre...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\application_tests\test_filters.py:167:19: error:
"OrderBookPreFilter" has no attribute "calculate_orderbook_metrics" 
[attr-defined]
            metrics = filter_instance.calculate_orderbook_metrics(empty_or...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:64:24: error:
"EvolutionOrchestrator" has no attribute "run_evolution_cycle"; maybe
"evolution_cache"?  [attr-defined]
            result = await orchestrator.run_evolution_cycle(population_siz...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:85:38: error:
"EvolutionOrchestrator" has no attribute "evaluate_population"; maybe
"_evaluate_population"?  [attr-defined]
            evaluated_population = await orchestrator.evaluate_population(...
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:97:19: error:
"EvolutionOrchestrator" has no attribute "_select_parents"  [attr-defined]
            parents = orchestrator._select_parents(sample_strategies, tour...
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:111:21: error:
"EvolutionOrchestrator" has no attribute "_crossover_strategies"  [attr-defined]
            offspring = orchestrator._crossover_strategies(parent1, parent...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:115:43: error: Unsupported
operand types for + ("object" and "int")  [operator]
            assert offspring["generation"] == parent1["generation"] + 1
                                              ^
tests\unit\application_tests\test_evolution.py:117:27: error: "object" has no
attribute "__iter__"; maybe "__dir__" or "__str__"? (not iterable) 
[attr-defined]
            for param_name in parent1["parameters"]:
                              ^~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:128:28: error:
"EvolutionOrchestrator" has no attribute "_mutate_strategy"  [attr-defined]
            mutated_strategy = orchestrator._mutate_strategy(strategy, mut...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:145:25: error:
"EvolutionOrchestrator" has no attribute "_calculate_fitness_score" 
[attr-defined]
            fitness_score = orchestrator._calculate_fitness_score(performa...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:151:18: error:
"EvolutionOrchestrator" has no attribute "_tournament_selection"  [attr-defined]
            winner = orchestrator._tournament_selection(sample_strategies,...
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:161:32: error:
"EvolutionOrchestrator" has no attribute "_create_new_generation"; maybe
"_create_next_generation"?  [attr-defined]
            new_generation = await orchestrator._create_new_generation(
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:175:16: error:
"EvolutionOrchestrator" has no attribute "_validate_strategy_parameters" 
[attr-defined]
            assert orchestrator._validate_strategy_parameters(valid_parame...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:178:16: error:
"EvolutionOrchestrator" has no attribute "_validate_strategy_parameters" 
[attr-defined]
            assert orchestrator._validate_strategy_parameters(invalid_para...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:180:9: error: Need type
annotation for "empty_parameters" (hint:
"empty_parameters: dict[<type>, <type>] = ...")  [var-annotated]
            empty_parameters = {}
            ^~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:181:16: error:
"EvolutionOrchestrator" has no attribute "_validate_strategy_parameters" 
[attr-defined]
            assert orchestrator._validate_strategy_parameters(empty_parame...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:187:23: error:
"EvolutionOrchestrator" has no attribute "get_evolution_statistics"; maybe
"get_selection_statistics", "get_evolution_metrics", or "get_evolution_history"?
 [attr-defined]
            stats = await orchestrator.get_evolution_statistics()
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:198:21: error:
"EvolutionOrchestrator" has no attribute "_calculate_population_diversity" 
[attr-defined]
            diversity = orchestrator._calculate_population_diversity(sampl...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:207:24: error:
"EvolutionOrchestrator" has no attribute "_save_generation"; maybe
"run_single_generation"?  [attr-defined]
            result = await orchestrator._save_generation(sample_strategies...
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\application_tests\test_evolution.py:213:17: error:
"EvolutionOrchestrator" has no attribute "_elite_selection"  [attr-defined]
            elite = orchestrator._elite_selection(sample_strategies, elite...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\performance\test_benchmarks.py:8:1: error: Module
"domain.entities.trading" has no attribute "Order"; maybe "OrderId"? 
[attr-defined]
    from domain.entities.trading import Order, Trade
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\performance\test_benchmarks.py:19:1: error: Module
"infrastructure.messaging.optimized_event_bus" has no attribute
"OptimizedEventBus"  [attr-defined]
    from infrastructure.messaging.optimized_event_bus import OptimizedEven...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\performance\test_benchmarks.py:33:42: error: Argument 1 to "TradingPair"
has incompatible type "str"; expected "Currency"  [arg-type]
                    trading_pair=TradingPair("BTC", "USDT"),
                                             ^~~~~
tests\performance\test_benchmarks.py:33:49: error: Argument 2 to "TradingPair"
has incompatible type "str"; expected "Currency"  [arg-type]
                    trading_pair=TradingPair("BTC", "USDT"),
                                                    ^~~~~~
tests\performance\test_benchmarks.py:37:23: error: Missing positional argument
"currency" in call to "Price"  [call-arg]
                    price=Price(50000 + i),
                          ^~~~~~~~~~~~~~~~
tests\performance\test_benchmarks.py:37:29: error: Argument 1 to "Price" has
incompatible type "int"; expected "Decimal"  [arg-type]
                    price=Price(50000 + i),
                                ^~~~~~~~~
tests\performance\test_benchmarks.py:209:21: error: Unexpected keyword argument
"volume" for "Trade"  [call-arg]
                trade = Trade(
                        ^
tests\performance\test_benchmarks.py:209:21: error: Unexpected keyword argument
"executed_at" for "Trade"  [call-arg]
                trade = Trade(
                        ^
tests\performance\test_benchmarks.py:210:20: error: Argument "id" to "Trade"
has incompatible type "str"; expected "TradeId"  [arg-type]
                    id=f"trade_{i}",
                       ^~~~~~~~~~~~
tests\performance\test_benchmarks.py:211:26: error: Argument "order_id" to
"Trade" has incompatible type "str"; expected "OrderId"  [arg-type]
                    order_id=f"order_{i}",
                             ^~~~~~~~~~~~
tests\performance\test_benchmarks.py:212:30: error: Argument "trading_pair" to
"Trade" has incompatible type "domain.value_objects.trading_pair.TradingPair";
expected "domain.types.TradingPair"  [arg-type]
                    trading_pair=TradingPair("BTC", "USDT"),
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\performance\test_benchmarks.py:212:42: error: Argument 1 to "TradingPair"
has incompatible type "str"; expected "Currency"  [arg-type]
                    trading_pair=TradingPair("BTC", "USDT"),
                                             ^~~~~
tests\performance\test_benchmarks.py:212:49: error: Argument 2 to "TradingPair"
has incompatible type "str"; expected "Currency"  [arg-type]
                    trading_pair=TradingPair("BTC", "USDT"),
                                                    ^~~~~~
tests\performance\test_benchmarks.py:213:22: error: Argument "side" to "Trade"
has incompatible type "str"; expected "OrderSide"  [arg-type]
                    side="buy" if i % 2 == 0 else "sell",
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\performance\test_benchmarks.py:215:23: error: Missing positional argument
"currency" in call to "Price"  [call-arg]
                    price=Price(50000 + i),
                          ^~~~~~~~~~~~~~~~
tests\performance\test_benchmarks.py:215:29: error: Argument 1 to "Price" has
incompatible type "int"; expected "Decimal"  [arg-type]
                    price=Price(50000 + i),
                                ^~~~~~~~~
tests\performance\test_benchmarks.py:226:20: error: Argument "id" to "Strategy"
has incompatible type "str"; expected "UUID"  [arg-type]
                    id=f"strategy_{i}",
                       ^~~~~~~~~~~~~~~
tests\performance\test_benchmarks.py:230:28: error: Argument "parameters" to
"Strategy" has incompatible type "dict[str, str]"; expected "StrategyParameters"
 [arg-type]
                    parameters={"param1": f"value{i}"},
                               ^~~~~~~~~~~~~~~~~~~~~~~
tests\performance\test_benchmarks.py:231:28: error: Argument "created_at" to
"Strategy" has incompatible type "Timestamp"; expected "datetime"  [arg-type]
                    created_at=Timestamp.now()
                               ^~~~~~~~~~~~~~~
tests\integration\test_session_influence_integration.py:3:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"TradingOrchestrator"  [attr-defined]
    from application.use_cases.trading_orchestrator import TradingOrchestr...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\domain\test_symbols_domain_integration.py:8:1: error: Module
"domain.symbols" has no attribute "OrderBookMetrics"; maybe
"OrderBookMetricsData"?  [attr-defined]
    from domain.symbols import (
    ^
tests\integration\domain\test_symbols_domain_integration.py:8:1: error: Module
"domain.symbols" has no attribute "PatternMetrics"; maybe "PatternMetricsData"? 
[attr-defined]
    from domain.symbols import (
    ^
tests\integration\domain\test_symbols_domain_integration.py:8:1: error: Module
"domain.symbols" has no attribute "SessionMetrics"; maybe "SessionMetricsData"? 
[attr-defined]
    from domain.symbols import (
    ^
tests\domain\services\test_ml_predictor.py:82:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result["performance"], ModelPerformance)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_ml_predictor.py:83:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result["feature_importance"], FeatureImporta...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\domain\services\test_ml_predictor.py:138:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(result, PredictionResult)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_ml_predictor.py:182:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(performance, ModelPerformance)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_ml_predictor.py:206:16: error: Cannot use
isinstance() with TypedDict type  [misc]
            assert isinstance(importance, FeatureImportance)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_ml_predictor.py:382:20: error: Cannot use
isinstance() with TypedDict type  [misc]
                assert isinstance(result, PredictionResult)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\services\test_ml_predictor.py:414:20: error: Cannot use
isinstance() with TypedDict type  [misc]
                assert isinstance(prediction_result, PredictionResult)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\protocols\test_protocols.py:10:1: error: Module
"domain.entities.trading" has no attribute "Order"; maybe "OrderId"? 
[attr-defined]
    from domain.entities.trading import Order, OrderSide, OrderType, Order...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\domain\protocols\test_protocols.py:15:1: error: Module "domain.protocols"
has no attribute "ExchangeProtocol"  [attr-defined]
    from domain.protocols import (
    ^
tests\domain\protocols\test_protocols.py:15:1: error: Module "domain.protocols"
has no attribute "MLProtocol"  [attr-defined]
    from domain.protocols import (
    ^
tests\domain\protocols\test_protocols.py:15:1: error: Module "domain.protocols"
has no attribute "RepositoryProtocol"  [attr-defined]
    from domain.protocols import (
    ^
tests\domain\protocols\test_protocols.py:15:1: error: Module "domain.protocols"
has no attribute "TradingRepositoryProtocol"  [attr-defined]
    from domain.protocols import (
    ^
tests\domain\protocols\test_protocols.py:15:1: error: Module "domain.protocols"
has no attribute "PortfolioRepositoryProtocol"  [attr-defined]
    from domain.protocols import (
    ^
tests\domain\protocols\test_protocols.py:15:1: error: Module "domain.protocols"
has no attribute "StrategyRepositoryProtocol"; maybe "StrategyProtocol"? 
[attr-defined]
    from domain.protocols import (
    ^
tests\domain\protocols\test_protocols.py:15:1: error: Module "domain.protocols"
has no attribute "MarketRepositoryProtocol"  [attr-defined]
    from domain.protocols import (
    ^
tests\domain\protocols\test_protocols.py:15:1: error: Module "domain.protocols"
has no attribute "RiskRepositoryProtocol"  [attr-defined]
    from domain.protocols import (
    ^
tests\domain\protocols\test_protocols.py:15:1: error: Module "domain.protocols"
has no attribute "MLRepositoryProtocol"  [attr-defined]
    from domain.protocols import (
    ^
tests\domain\protocols\test_protocols.py:77:29: error: Name "List" is not
defined  [name-defined]
    def sample_market_data() -> List[MarketData]:
                                ^~~~~~~~~~~~~~~~
tests\domain\protocols\test_protocols.py:77:29: note: Did you forget to import it from "typing"? (Suggestion: "from typing import List")
tests\domain\protocols\test_protocols.py:82:23: error: Argument "timestamp" to
"MarketData" has incompatible type "datetime"; expected "TimestampValue" 
[arg-type]
                timestamp=datetime.now() - timedelta(minutes=i),
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\protocols\test_protocols.py:83:18: error: Argument "open" to
"MarketData" has incompatible type "Decimal"; expected "Price"  [arg-type]
                open=Decimal("50000") + Decimal(i),
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\protocols\test_protocols.py:84:18: error: Argument "high" to
"MarketData" has incompatible type "Decimal"; expected "Price"  [arg-type]
                high=Decimal("50100") + Decimal(i),
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\protocols\test_protocols.py:85:17: error: Argument "low" to
"MarketData" has incompatible type "Decimal"; expected "Price"  [arg-type]
                low=Decimal("49900") + Decimal(i),
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\protocols\test_protocols.py:86:19: error: Argument "close" to
"MarketData" has incompatible type "Decimal"; expected "Price"  [arg-type]
                close=Decimal("50050") + Decimal(i),
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\protocols\test_protocols.py:87:20: error: Argument "volume" to
"MarketData" has incompatible type "Decimal"; expected "Volume"  [arg-type]
                volume=Decimal("1000") + Decimal(i * 10)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\domain\protocols\test_protocols.py:362:16: error: Cannot use isinstance()
with NewType type  [misc]
            assert isinstance(symbol, Symbol)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:46:23: error: Name "nn" is
not defined  [name-defined]
    class StrategyMLModel(nn.Module):
                          ^~
infrastructure\strategies\evolvable_base_strategy.py:51:20: error: Name "nn" is
not defined  [name-defined]
            self.net = nn.Sequential(
                       ^~
infrastructure\strategies\evolvable_base_strategy.py:52:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(input_dim, hidden_dim),
                ^~
infrastructure\strategies\evolvable_base_strategy.py:53:13: error: Name "nn" is
not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\strategies\evolvable_base_strategy.py:54:13: error: Name "nn" is
not defined  [name-defined]
                nn.Dropout(0.2),
                ^~
infrastructure\strategies\evolvable_base_strategy.py:55:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(hidden_dim, hidden_dim // 2),
                ^~
infrastructure\strategies\evolvable_base_strategy.py:56:13: error: Name "nn" is
not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\strategies\evolvable_base_strategy.py:57:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(hidden_dim // 2, 3),  # buy, sell, hold
                ^~
infrastructure\strategies\evolvable_base_strategy.py:64:22: error: Name "nn" is
not defined  [name-defined]
    class RLTradingAgent(nn.Module):
                         ^~
infrastructure\strategies\evolvable_base_strategy.py:92:23: error: Incompatible
types in assignment (expression has type "EvolvableStrategyConfig", variable has
type "dict[str, Any]")  [assignment]
            self.config = config or EvolvableStrategyConfig()
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:96:41: error:
"dict[str, Any]" has no attribute "learning_rate"  [attr-defined]
                self.model.parameters(), lr=self.config.learning_rate
                                            ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:101:9: error: Need type
annotation for "training_data" (hint: "training_data: list[<type>] = ...") 
[var-annotated]
            self.training_data = []
            ^~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:102:9: error: Need type
annotation for "signal_history" (hint: "signal_history: list[<type>] = ...") 
[var-annotated]
            self.signal_history = []
            ^~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:107:5: error: Return type
"StrategyAnalysis" of "analyze" incompatible with return type "dict[str, Any]"
in supertype "BaseStrategy"  [override]
        def analyze(self, data: pd.DataFrame) -> StrategyAnalysis:
        ^
infrastructure\strategies\evolvable_base_strategy.py:107:29: error: Name "pd"
is not defined  [name-defined]
        def analyze(self, data: pd.DataFrame) -> StrategyAnalysis:
                                ^
infrastructure\strategies\evolvable_base_strategy.py:142:27: error: Name "pd"
is not defined  [name-defined]
                    timestamp=pd.Timestamp.now(),
                              ^~
infrastructure\strategies\evolvable_base_strategy.py:163:5: error: Return type
"domain.types.strategy_types.Signal | None" of "generate_signal" incompatible
with return type "infrastructure.strategies.base_strategy.Signal | None" in
supertype "BaseStrategy"  [override]
        def generate_signal(self, data: pd.DataFrame) -> Optional[DomainSi...
        ^
infrastructure\strategies\evolvable_base_strategy.py:163:37: error: Name "pd"
is not defined  [name-defined]
        def generate_signal(self, data: pd.DataFrame) -> Optional[DomainSi...
                                        ^
infrastructure\strategies\evolvable_base_strategy.py:194:55: error: Name "pd"
is not defined  [name-defined]
    ...ef _extract_strategy_features(self, market_data: pd.DataFrame) -> List...
                                                        ^
infrastructure\strategies\evolvable_base_strategy.py:265:17: error: Dict entry
0 has incompatible type "str": "str"; expected "str": "float"  [dict-item]
                    "direction": direction,
                    ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:275:17: error: Dict entry
0 has incompatible type "str": "str"; expected "str": "float"  [dict-item]
                    "direction": "hold",
                    ^~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:283:43: error: Name "pd"
is not defined  [name-defined]
        def _detect_market_regime(self, data: pd.DataFrame) -> MarketRegim...
                                              ^
infrastructure\strategies\evolvable_base_strategy.py:307:21: error: Name "pd"
is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float], re...
                        ^
infrastructure\strategies\evolvable_base_strategy.py:327:21: error: Name "pd"
is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                        ^
infrastructure\strategies\evolvable_base_strategy.py:333:52: error:
"dict[str, Any]" has no attribute "confidence_threshold"  [attr-defined]
    ...          if direction == "hold" or confidence < self.config.confidenc...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\evolvable_base_strategy.py:389:36: error:
"dict[str, Any]" has no attribute "confidence_threshold"  [attr-defined]
                if signal.confidence < self.config.confidence_threshold:
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:392:35: error:
"dict[str, Any]" has no attribute "evolution_threshold"  [attr-defined]
                if self.performance < self.config.evolution_threshold:
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:403:21: error: Name "pd"
is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                        ^
infrastructure\strategies\evolvable_base_strategy.py:426:21: error: Name "pd"
is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                        ^
infrastructure\strategies\evolvable_base_strategy.py:447:21: error: Name "pd"
is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float], re...
                        ^
infrastructure\strategies\evolvable_base_strategy.py:479:21: error: Name "pd"
is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                        ^
infrastructure\strategies\evolvable_base_strategy.py:497:21: error: Name "pd"
is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float], re...
                        ^
infrastructure\strategies\evolvable_base_strategy.py:544:43: error: Name "pd"
is not defined  [name-defined]
        def _calculate_indicators(self, data: pd.DataFrame) -> Dict[str, p...
                                              ^
infrastructure\strategies\evolvable_base_strategy.py:557:5: error: Missing
return statement  [return]
        async def adapt(self, data: Any) -> bool:
        ^
infrastructure\strategies\evolvable_base_strategy.py:565:17: error:
"dict[str, Any]" has no attribute "confidence_threshold"  [attr-defined]
                    self.config.confidence_threshold = max(
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:567:30: error:
"dict[str, Any]" has no attribute "confidence_threshold"  [attr-defined]
                        min(0.8, self.config.confidence_threshold * (1 + v...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:571:21: error:
"dict[str, Any]" has no attribute "max_signals"  [attr-defined]
                        self.config.max_signals = min(15, self.config.max_...
                        ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:573:21: error:
"dict[str, Any]" has no attribute "max_signals"  [attr-defined]
                        self.config.max_signals = max(5, self.config.max_s...
                        ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:575:21: error:
"dict[str, Any]" has no attribute "confidence_threshold"  [attr-defined]
                        f"Strategy adapted: confidence_threshold={self.con...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\evolvable_base_strategy.py:575:21: error:
"dict[str, Any]" has no attribute "max_signals"  [attr-defined]
                        f"Strategy adapted: confidence_threshold={self.con...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\evolvable_base_strategy.py:582:5: error: Missing
return statement  [return]
        async def learn(self, data: Any) -> bool:
        ^
infrastructure\strategies\evolvable_base_strategy.py:595:28: error: Name "nn"
is not defined  [name-defined]
                        loss = nn.MSELoss()(predictions, targets_tensor)
                               ^~
infrastructure\strategies\evolvable_base_strategy.py:641:5: error: Signature of
"save_state" incompatible with supertype "BaseStrategy"  [override]
        def save_state(self, path: str) -> bool:
        ^
infrastructure\strategies\evolvable_base_strategy.py:641:5: note:      Superclass:
infrastructure\strategies\evolvable_base_strategy.py:641:5: note:          def save_state(self) -> Any
infrastructure\strategies\evolvable_base_strategy.py:641:5: note:      Subclass:
infrastructure\strategies\evolvable_base_strategy.py:641:5: note:          def save_state(self, path: str) -> bool
infrastructure\strategies\evolvable_base_strategy.py:683:20: error: "Signal"
has no attribute "direction"  [attr-defined]
                    if signal.direction == "buy":
                       ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:685:22: error: "Signal"
has no attribute "direction"  [attr-defined]
                    elif signal.direction == "sell":
                         ^~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:758:53: error: Name "np"
is not defined  [name-defined]
    ... async def train_rl_agent(self, historical_data: np.ndarray, reward_fn...
                                                        ^
infrastructure\strategies\evolvable_base_strategy.py:775:52: error: Invalid
index type "tuple[int, int | float]" for "Tensor"; expected type
"SupportsIndex | bool | int | slice[Any, Any, Any] | EllipsisType | Tensor | _NestedSequence[bool | int | slice[Any, Any, Any] | EllipsisType | Tensor | None] | tuple[SupportsIndex | bool | int | slice[Any, Any, Any] | EllipsisType | Tensor | _NestedSequence[bool | int | slice[Any, Any, Any] | EllipsisType | Tensor | None] | None, ...] | None"
 [index]
    ...                   loss = -torch.log(action_probs[0, action]) * reward
                                                         ^~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:786:57: error: Name "np"
is not defined  [name-defined]
    ...nc def _validate_rl_agent(self, validation_data: np.ndarray, reward_fn...
                                                        ^
infrastructure\strategies\evolvable_base_strategy.py:805:51: error: Name "pd"
is not defined  [name-defined]
    ...   async def generate_signals(self, market_data: pd.DataFrame) -> List...
                                                        ^
infrastructure\strategies\evolvable_base_strategy.py:852:45: error:
"dict[str, Any]" has no attribute "confidence_threshold"  [attr-defined]
                        "confidence_threshold": self.config.confidence_thr...
                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\evolvable_base_strategy.py:853:38: error:
"dict[str, Any]" has no attribute "learning_rate"  [attr-defined]
                        "learning_rate": self.config.learning_rate,
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\evolvable_base_strategy.py:854:44: error:
"dict[str, Any]" has no attribute "evolution_threshold"  [attr-defined]
                        "evolution_threshold": self.config.evolution_thres...
                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\adaptive_strategy_generator.py:16:1: error: Module
"infrastructure.agents.market_regime" has no attribute "MarketRegimeAgent" 
[attr-defined]
    from infrastructure.agents.market_regime import MarketRegimeAgent
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:21:1: error: Module
"infrastructure.strategies.reversal_strategies" has no attribute
"reversal_strategy_fibo_pinbar"  [attr-defined]
    from infrastructure.strategies.reversal_strategies import reversal_str...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\adaptive_strategy_generator.py:67:48: error: Name
"trend_strategy_price_action" is not defined  [name-defined]
                "trend": [trend_strategy_ema_macd, trend_strategy_price_ac...
                                                   ^~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\adaptive_strategy_generator.py:68:52: error: Name
"sideways_strategy_stoch_obv" is not defined  [name-defined]
    ...          "sideways": [sideways_strategy_bb_rsi, sideways_strategy_sto...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\adaptive_strategy_generator.py:70:17: error: Name
"reversal_strategy_rsi_divergence" is not defined  [name-defined]
                    reversal_strategy_rsi_divergence,
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:75:17: error: Name
"volatility_strategy_ema_keltner" is not defined  [name-defined]
                    volatility_strategy_ema_keltner,
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:78:17: error: Name
"manipulation_strategy_stop_hunt" is not defined  [name-defined]
                    manipulation_strategy_stop_hunt,
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:79:17: error: Name
"manipulation_strategy_fake_breakout" is not defined  [name-defined]
                    manipulation_strategy_fake_breakout,
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:84:30: error: Name
"MetaLearning" is not defined  [name-defined]
            self.meta_learning = MetaLearning()
                                 ^~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:85:9: error: Need type
annotation for "strategy_cache" (hint:
"strategy_cache: dict[<type>, <type>] = ...")  [var-annotated]
            self.strategy_cache = {}
            ^~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:95:5: error: Return
type "StrategyAnalysis" of "analyze" incompatible with return type
"dict[str, Any]" in supertype "BaseStrategy"  [override]
        def analyze(self, data: pd.DataFrame) -> StrategyAnalysis:
        ^
infrastructure\strategies\adaptive_strategy_generator.py:95:29: error: Name
"pd" is not defined  [name-defined]
        def analyze(self, data: pd.DataFrame) -> StrategyAnalysis:
                                ^
infrastructure\strategies\adaptive_strategy_generator.py:115:24: error:
"discover_patterns" of "PatternDiscovery" does not return a value (it only ever
returns None)  [func-returns-value]
                patterns = self.pattern_discovery.discover_patterns(data)
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:134:27: error: Name
"pd" is not defined  [name-defined]
                    timestamp=pd.Timestamp.now(),
                              ^~
infrastructure\strategies\adaptive_strategy_generator.py:156:5: error: Return
type "domain.types.strategy_types.Signal | None" of "generate_signal"
incompatible with return type
"infrastructure.strategies.base_strategy.Signal | None" in supertype
"BaseStrategy"  [override]
        def generate_signal(self, data: pd.DataFrame) -> Optional[Signal]:
        ^
infrastructure\strategies\adaptive_strategy_generator.py:156:37: error: Name
"pd" is not defined  [name-defined]
        def generate_signal(self, data: pd.DataFrame) -> Optional[Signal]:
                                        ^
infrastructure\strategies\adaptive_strategy_generator.py:189:43: error: Name
"pd" is not defined  [name-defined]
        def _detect_market_regime(self, data: pd.DataFrame) -> MarketRegim...
                                              ^
infrastructure\strategies\adaptive_strategy_generator.py:202:48: error: Name
"pd" is not defined  [name-defined]
        def _fallback_regime_detection(self, data: pd.DataFrame) -> Market...
                                                   ^
infrastructure\strategies\adaptive_strategy_generator.py:232:21: error: Name
"pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime
                        ^
infrastructure\strategies\adaptive_strategy_generator.py:260:34: error: Name
"pd" is not defined  [name-defined]
                correlation_matrix = pd.DataFrame()  # Placeholder
                                     ^~
infrastructure\strategies\adaptive_strategy_generator.py:265:32: error:
Argument "volume_profile" to "MarketContext" has incompatible type
"dict[str, float | str]"; expected "dict[str, float]"  [arg-type]
                    volume_profile=volume_profile,
                                   ^~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:279:36: error: Name
"pd" is not defined  [name-defined]
                    correlation_matrix=pd.DataFrame(),
                                       ^~
infrastructure\strategies\adaptive_strategy_generator.py:282:41: error: Name
"pd" is not defined  [name-defined]
        def _get_ml_predictions(self, data: pd.DataFrame) -> Dict[str, flo...
                                            ^
infrastructure\strategies\adaptive_strategy_generator.py:287:31: error:
"Tensor" not callable  [operator]
                    predictions = self.meta_learner.predict(features)
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:295:39: error: Name
"pd" is not defined  [name-defined]
        def _extract_features(self, data: pd.DataFrame) -> Dict[str, float...
                                          ^
infrastructure\strategies\adaptive_strategy_generator.py:300:37: error: Name
"calculate_rsi" is not defined  [name-defined]
                features["rsi"] = float(calculate_rsi(data["close"], 14).i...
                                        ^~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:321:21: error: Name
"pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime, ml_predictions...
                        ^
infrastructure\strategies\adaptive_strategy_generator.py:324:9: error: Need
type annotation for "signals" (hint: "signals: list[<type>] = ...") 
[var-annotated]
            signals = []
            ^~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:343:43: error: Name
"pd" is not defined  [name-defined]
            self, regime: MarketRegime, data: pd.DataFrame
                                              ^
infrastructure\strategies\adaptive_strategy_generator.py:351:27: error: Name
"np" is not defined  [name-defined]
                best_score = -np.inf
                              ^~
infrastructure\strategies\adaptive_strategy_generator.py:371:41: error: Name
"pd" is not defined  [name-defined]
            self, strategy: Callable, data: pd.DataFrame
                                            ^
infrastructure\strategies\adaptive_strategy_generator.py:386:45: error: Name
"pd" is not defined  [name-defined]
            self, result: Dict[str, Any], data: pd.DataFrame
                                                ^
infrastructure\strategies\adaptive_strategy_generator.py:461:21: error: Name
"pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime, ml_predictions...
                        ^
infrastructure\strategies\adaptive_strategy_generator.py:485:21: error: Name
"pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime, ml_predictions...
                        ^
infrastructure\strategies\adaptive_strategy_generator.py:502:21: error: Name
"pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime
                        ^
infrastructure\strategies\adaptive_strategy_generator.py:522:15: error: Name
"pd" is not defined  [name-defined]
            data: pd.DataFrame,
                  ^
infrastructure\strategies\adaptive_strategy_generator.py:549:21: error: Name
"pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime, ml_predictions...
                        ^
infrastructure\strategies\adaptive_strategy_generator.py:568:15: error: Name
"pd" is not defined  [name-defined]
            data: pd.DataFrame,
                  ^
infrastructure\strategies\adaptive_strategy_generator.py:638:17: error:
"Tensor" not callable  [operator]
                    self.meta_learner.predict(
                    ^
infrastructure\strategies\adaptive_strategy_generator.py:675:23: error: Name
"np" is not defined  [name-defined]
            best_score = -np.inf
                          ^~
infrastructure\strategies\adaptive_strategy_generator.py:702:16: error:
Function "strategy" could always be true in boolean context  [truthy-function]
            if not strategy:
                   ^~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:805:16: error:
Function "strategy" could always be true in boolean context  [truthy-function]
            if not strategy:
                   ^~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:819:13: error: Name
"np" is not defined  [name-defined]
                np.mean(list(meta_predictions.values())) if meta_predictio...
                ^~
infrastructure\strategies\adaptive_strategy_generator.py:872:24: error: Name
"generate_features" is not defined  [name-defined]
                features = generate_features(market_data, indicators, pair...
                           ^~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:892:17: error:
"Tensor" not callable  [operator]
                    self.meta_learner.get_strategy_for_regime(regime)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:1024:31: error: Name
"pd" is not defined  [name-defined]
            ml_features: Optional[pd.DataFrame],
                                  ^
infrastructure\strategies\adaptive_strategy_generator.py:1047:31: error: Name
"pd" is not defined  [name-defined]
            ml_features: Optional[pd.DataFrame],
                                  ^
infrastructure\strategies\adaptive_strategy_generator.py:1091:62: error: Name
"pd" is not defined  [name-defined]
    ...def _get_market_data(self, pair: str, timeframe: str) -> pd.DataFrame:
                                                                ^
infrastructure\strategies\adaptive_strategy_generator.py:1107:24: error: Name
"pd" is not defined  [name-defined]
                    return pd.DataFrame()
                           ^~
infrastructure\strategies\adaptive_strategy_generator.py:1114:18: error: Name
"pd" is not defined  [name-defined]
                df = pd.DataFrame(market_data)
                     ^~
infrastructure\strategies\adaptive_strategy_generator.py:1118:25: error: Too
many arguments for "calculate_atr" of "TechnicalAnalysisService"  [call-arg]
                df["atr"] = self.technical_analysis.calculate_atr(
                            ^
infrastructure\strategies\adaptive_strategy_generator.py:1134:30: error: Name
"calculate_ema" is not defined  [name-defined]
                df["ema_fast"] = calculate_ema(df["close"], 20)
                                 ^~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:1135:32: error: Name
"calculate_ema" is not defined  [name-defined]
                df["ema_medium"] = calculate_ema(df["close"], 50)
                                   ^~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:1136:30: error: Name
"calculate_ema" is not defined  [name-defined]
                df["ema_slow"] = calculate_ema(df["close"], 200)
                                 ^~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:1161:26: error: Name
"pd" is not defined  [name-defined]
                df["hour"] = pd.to_datetime(df["timestamp"]).dt.hour
                             ^~
infrastructure\strategies\adaptive_strategy_generator.py:1162:33: error: Name
"pd" is not defined  [name-defined]
                df["day_of_week"] = pd.to_datetime(df["timestamp"]).dt.day...
                                    ^~
infrastructure\strategies\adaptive_strategy_generator.py:1165:54: error: Name
"np" is not defined  [name-defined]
    ...          numeric_cols = df.select_dtypes(include=[np.number]).columns
                                                          ^~
infrastructure\strategies\adaptive_strategy_generator.py:1174:20: error: Name
"pd" is not defined  [name-defined]
                return pd.DataFrame()
                       ^~
infrastructure\strategies\adaptive_strategy_generator.py:1177:54: error: Name
"pd" is not defined  [name-defined]
            self, strategy: Dict[str, Any], market_data: pd.DataFrame
                                                         ^
infrastructure\strategies\adaptive_strategy_generator.py:1189:23: error: Need
type annotation for "signals"  [var-annotated]
                signals = {
                          ^
infrastructure\strategies\adaptive_strategy_generator.py:1211:60: error: Name
"pd" is not defined  [name-defined]
    ...  liquidity = market_data.get("liquidity_ratio", pd.Series([1.0])).ilo...
                                                        ^~
infrastructure\strategies\adaptive_strategy_generator.py:1267:25: error: Dict
entry 0 has incompatible type "str": "str"; expected "str":
"dict[Any, Any] | float | None"  [dict-item]
                            "entry": best_entry,
                            ^~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:1268:25: error: Dict
entry 1 has incompatible type "str": "str | None"; expected "str":
"dict[Any, Any] | float | None"  [dict-item]
                            "exit": exit_conditions[0] if exit_conditions ...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\adaptive_strategy_generator.py:1291:43: error: Name
"pd" is not defined  [name-defined]
        def _calculate_indicators(self, data: pd.DataFrame) -> pd.DataFram...
                                              ^
infrastructure\strategies\adaptive_strategy_generator.py:1296:23: error: Too
many arguments for "calculate_atr" of "TechnicalAnalysisService"  [call-arg]
            data["atr"] = self.technical_analysis.calculate_atr(
                          ^
infrastructure\strategies\adaptive_strategy_generator.py:1325:39: error: Name
"pd" is not defined  [name-defined]
        def get_best_strategy(self, data: pd.DataFrame) -> Optional[Callab...
                                          ^
infrastructure\strategies\adaptive_strategy_generator.py:1337:22: error:
Missing positional arguments "timeframe", "regime" in call to
"generate_hybrid_strategy" of "AdaptiveStrategyGenerator"  [call-arg]
                hybrid = self.generate_hybrid_strategy(data)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:1339:24: error:
Incompatible return value type (got "dict[str, Any]", expected
"Callable[..., Any] | None")  [return-value]
                    return hybrid
                           ^~~~~~
infrastructure\strategies\adaptive_strategy_generator.py:1341:20: error:
Missing positional argument "timeframe" in call to "_select_best_strategy" of
"AdaptiveStrategyGenerator"  [call-arg]
                return self._select_best_strategy(self.base_strategies, da...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive\ml_signal_processor.py:19:37: error: Name
"pd" is not defined  [name-defined]
        def get_predictions(self, data: pd.DataFrame) -> Dict[str, float]:
                                        ^
infrastructure\strategies\adaptive\ml_signal_processor.py:24:31: error:
"Tensor" not callable  [operator]
                    predictions = self.meta_learner.predict(features)
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive\ml_signal_processor.py:32:39: error: Name
"pd" is not defined  [name-defined]
        def _extract_features(self, data: pd.DataFrame) -> Dict[str, float...
                                          ^
infrastructure\strategies\adaptive\ml_signal_processor.py:37:37: error: Value
of type "Callable[[], Any]" is not indexable  [index]
                features["rsi"] = float(calculate_rsi(data["close"], 14).i...
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\strategies\adaptive\ml_signal_processor.py:85:21: error: Name
"pd" is not defined  [name-defined]
            self, data: pd.DataFrame, ml_predictions: Dict[str, float]
                        ^
infrastructure\services\risk_analysis_service.py:221:66: error: "Series" has no
attribute "name"  [attr-defined]
    ...e_key = self._generate_cache_key("risk_metrics", returns.name, str(ris...
                                                        ^~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:222:16: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                if self.cache_manager.cache is not None:
                   ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:223:33: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                    cached_result = self.cache_manager.cache.get(cache_key...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:230:16: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                if self.cache_manager.cache is not None:
                   ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:231:17: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                    self.cache_manager.cache.set(cache_key, metrics, ttl=s...
                    ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:296:20: error: Too many
arguments for "validate_market_data"  [call-arg]
                if not validate_market_data(prices, self.config.min_data_p...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\risk_analysis_service.py:296:41: error: Argument 1 to
"validate_market_data" has incompatible type "Series"; expected "DataFrame" 
[arg-type]
                if not validate_market_data(prices, self.config.min_data_p...
                                            ^~~~~~
infrastructure\services\risk_analysis_service.py:322:20: error: Too many
arguments for "validate_market_data"  [call-arg]
                if not validate_market_data(returns_df, self.config.min_da...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\risk_analysis_service.py:324:20: error: "DataFrame" has
no attribute "corr"  [attr-defined]
                return returns_df.corr()
                       ^~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:329:5: error: Return type
"domain.types.risk_types.RiskMetrics" of "calculate_portfolio_risk" incompatible
with return type "domain.entities.risk.RiskMetrics" in supertype
"RiskAnalysisService"  [override]
        def calculate_portfolio_risk(
        ^
infrastructure\services\risk_analysis_service.py:329:5: error: Return type
"domain.types.risk_types.RiskMetrics" of "calculate_portfolio_risk" incompatible
with return type "domain.entities.risk.RiskMetrics" in supertype
"RiskAnalysisProtocol"  [override]
        def calculate_portfolio_risk(
        ^
infrastructure\services\risk_analysis_service.py:330:35: error: Argument 2 of
"calculate_portfolio_risk" is incompatible with supertype "RiskAnalysisService";
supertype defines the argument type as "ndarray[Any, Any] | None"  [override]
            self, returns: pd.Series, weights: Optional[Dict[str, float]] ...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:330:35: note: This violates the Liskov substitution principle
infrastructure\services\risk_analysis_service.py:330:35: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\services\risk_analysis_service.py:330:35: error: Argument 2 of
"calculate_portfolio_risk" is incompatible with supertype
"RiskAnalysisProtocol"; supertype defines the argument type as
"ndarray[Any, Any] | None"  [override]
            self, returns: pd.Series, weights: Optional[Dict[str, float]] ...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:337:68: error: "Series" has no
attribute "name"  [attr-defined]
    ...key = self._generate_cache_key("portfolio_risk", returns.name, str(wei...
                                                        ^~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:338:16: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                if self.cache_manager.cache is not None:
                   ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:339:33: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                    cached_result = self.cache_manager.cache.get(cache_key...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:346:16: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                if self.cache_manager.cache is not None:
                   ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:347:17: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                    self.cache_manager.cache.set(cache_key, metrics, ttl=s...
                    ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:353:5: error: Return type
"tuple[dict[str, float], domain.types.risk_types.RiskMetrics]" of
"optimize_portfolio" incompatible with return type
"tuple[ndarray[Any, Any], domain.entities.risk.RiskMetrics]" in supertype
"RiskAnalysisService"  [override]
        def optimize_portfolio(
        ^
infrastructure\services\risk_analysis_service.py:353:5: error: Return type
"tuple[dict[str, float], domain.types.risk_types.RiskMetrics]" of
"optimize_portfolio" incompatible with return type
"tuple[ndarray[Any, Any], domain.entities.risk.RiskMetrics]" in supertype
"RiskAnalysisProtocol"  [override]
        def optimize_portfolio(
        ^
infrastructure\services\risk_analysis_service.py:354:15: error: Argument 1 of
"optimize_portfolio" is incompatible with supertype "RiskAnalysisService";
supertype defines the argument type as "DataFrame"  [override]
            self, returns: pd.Series, risk_free_rate: float = 0.02
                  ^~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:354:15: note: This violates the Liskov substitution principle
infrastructure\services\risk_analysis_service.py:354:15: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\services\risk_analysis_service.py:354:15: error: Argument 1 of
"optimize_portfolio" is incompatible with supertype "RiskAnalysisProtocol";
supertype defines the argument type as "DataFrame"  [override]
            self, returns: pd.Series, risk_free_rate: float = 0.02
                  ^~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:361:76: error: "Series" has no
attribute "name"  [attr-defined]
    ...lf._generate_cache_key("portfolio_optimization", returns.name, str(ris...
                                                        ^~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:362:16: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                if self.cache_manager.cache is not None:
                   ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:363:33: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                    cached_result = self.cache_manager.cache.get(cache_key...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:368:33: error: "DataFrame" has
no attribute "cov"  [attr-defined]
                covariance_matrix = returns_df.cov()
                                    ^~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:371:34: error: "DataFrame" has
no attribute "mean"  [attr-defined]
                    expected_returns=returns_df.mean(),
                                     ^~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:376:34: error: Unsupported
left operand type for * ("DataFrame")  [operator]
                portfolio_returns = (returns_df * pd.Series(optimal_weight...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:380:16: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                if self.cache_manager.cache is not None:
                   ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:381:17: error: "CacheManager"
has no attribute "cache"; maybe "_caches"?  [attr-defined]
                    self.cache_manager.cache.set(cache_key, result, ttl=se...
                    ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:382:20: error: Incompatible
return value type (got "tuple[ndarray[Any, Any], RiskMetrics]", expected
"tuple[dict[str, float], RiskMetrics]")  [return-value]
                return result
                       ^~~~~~
infrastructure\services\risk_analysis_service.py:403:26: error: Unexpected
keyword argument "cvar_change" for "StressTestResult"; did you mean
"var_change"?  [call-arg]
                    result = StressTestResult(
                             ^
infrastructure\services\risk_analysis_service.py:403:26: error: Unexpected
keyword argument "volatility_change" for "StressTestResult"  [call-arg]
                    result = StressTestResult(
                             ^
infrastructure\services\risk_analysis_service.py:403:26: error: Unexpected
keyword argument "scenario_applied_at" for "StressTestResult"  [call-arg]
                    result = StressTestResult(
                             ^
infrastructure\services\risk_analysis_service.py:430:22: error: Unexpected
keyword argument "recommendations" for "RiskReport"; did you mean
"risk_recommendations"?  [call-arg]
                report = RiskReport(
                         ^
infrastructure\services\risk_analysis_service.py:430:22: error: Unexpected
keyword argument "alerts" for "RiskReport"  [call-arg]
                report = RiskReport(
                         ^
infrastructure\services\risk_analysis_service.py:430:22: error: Unexpected
keyword argument "report_type" for "RiskReport"  [call-arg]
                report = RiskReport(
                         ^
infrastructure\services\risk_analysis_service.py:434:31: error: Argument
"report_period" to "RiskReport" has incompatible type "datetime"; expected "str"
 [arg-type]
                    report_period=datetime.now(),
                                  ^~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:440:20: error: Unexpected
keyword argument "recommendations" for "RiskReport"; did you mean
"risk_recommendations"?  [call-arg]
                return RiskReport(
                       ^
infrastructure\services\risk_analysis_service.py:440:20: error: Unexpected
keyword argument "alerts" for "RiskReport"  [call-arg]
                return RiskReport(
                       ^
infrastructure\services\risk_analysis_service.py:440:20: error: Unexpected
keyword argument "report_type" for "RiskReport"  [call-arg]
                return RiskReport(
                       ^
infrastructure\services\risk_analysis_service.py:444:31: error: Argument
"report_period" to "RiskReport" has incompatible type "datetime"; expected "str"
 [arg-type]
                    report_period=datetime.now(),
                                  ^~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:459:20: error: Unexpected
keyword argument "calculated_at" for "RiskMetrics"  [call-arg]
                return RiskMetrics(
                       ^
infrastructure\services\risk_analysis_service.py:464:24: error: Argument
"var_95" to "RiskMetrics" has incompatible type "Decimal"; expected "Money" 
[arg-type]
                    var_95=convert_to_decimal(var_95),
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:465:25: error: Argument
"cvar_95" to "RiskMetrics" has incompatible type "Decimal"; expected "Money" 
[arg-type]
                    cvar_95=convert_to_decimal(cvar_95),
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:503:34: error: "DataFrame" has
no attribute "corr"  [attr-defined]
                correlation_matrix = returns_df.corr()
                                     ^~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:504:37: error: Missing
positional argument "correlation_matrix" in call to "calc_diversification_ratio"
 [call-arg]
                diversification_ratio = calc_diversification_ratio(weights...
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\services\risk_analysis_service.py:504:64: error: Argument 1 to
"calc_diversification_ratio" has incompatible type "Series"; expected
"ndarray[Any, Any]"  [arg-type]
    ...versification_ratio = calc_diversification_ratio(weights_series, corre...
                                                        ^~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:519:53: error: Argument 1 to
"calc_concentration_risk" has incompatible type "Series"; expected
"ndarray[Any, Any]"  [arg-type]
    ...           concentration = calc_concentration_risk(pd.Series(weights))
                                                          ^~~~~~~~~~~~~~~~~~
infrastructure\services\risk_analysis_service.py:563:20: error: Unexpected
keyword argument "expected_volatility" for "RiskOptimizationResult"  [call-arg]
                return RiskOptimizationResult(
                       ^
infrastructure\services\risk_analysis_service.py:568:37: error: Argument
"constraints_applied" to "RiskOptimizationResult" has incompatible type "bool";
expected "list[str]"  [arg-type]
                    constraints_applied=True,
                                        ^~~~
infrastructure\services\risk_analysis_service.py:574:20: error: Incompatible
return value type (got "dict[str, Any]", expected "RiskOptimizationResult") 
[return-value]
                return create_empty_optimization_result()
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:48:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\position_repository.py:49:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\position_repository.py:50:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\position_repository.py:51:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\position_repository.py:52:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\position_repository.py:53:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\position_repository.py:53:39: error: Incompatible
types in assignment (expression has type "dict[str, Any]", base class
"RepositoryProtocol" defined the type as "dict[UUID | str, Any]")  [assignment]
            self._cache: Dict[str, Any] = {}
                                          ^~
infrastructure\repositories\position_repository.py:54:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
infrastructure\repositories\position_repository.py:54:48: error: Incompatible
types in assignment (expression has type "dict[str, datetime]", base class
"RepositoryProtocol" defined the type as "dict[UUID | str, datetime]") 
[assignment]
            self._cache_ttl: Dict[str, datetime] = {}
                                                   ^~
infrastructure\repositories\position_repository.py:70:5: error: Return type
"Coroutine[Any, Any, Position]" of "save" incompatible with return type
"Coroutine[Any, Any, bool]" in supertype "PositionRepository"  [override]
        async def save(self, position: Position) -> Position:
        ^
infrastructure\repositories\position_repository.py:70:26: error: Argument 1 of
"save" is incompatible with supertype "PositionRepository"; supertype defines
the argument type as "Position"  [override]
        async def save(self, position: Position) -> Position:
                             ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:70:26: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:70:26: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:75:9: error:
"InMemoryPositionRepository" has no attribute "_update_position_indexes" 
[attr-defined]
            self._update_position_indexes(entity_id, position)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:78:9: error:
"InMemoryPositionRepository" has no attribute "_update_position_metrics" 
[attr-defined]
            self._update_position_metrics()
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:83:5: error: Return type
"Coroutine[Any, Any, domain.entities.position.Position | None]" of "get_by_id"
incompatible with return type
"Coroutine[Any, Any, domain.entities.trading.Position | None]" in supertype
"PositionRepository"  [override]
        async def get_by_id(self, position_id: Union[UUID, str]) -> Option...
        ^
infrastructure\repositories\position_repository.py:102:5: error: Return type
"Coroutine[Any, Any, list[domain.entities.position.Position]]" of
"get_by_trading_pair" incompatible with return type
"Coroutine[Any, Any, list[domain.entities.trading.Position]]" in supertype
"PositionRepository"  [override]
        async def get_by_trading_pair(
        ^
infrastructure\repositories\position_repository.py:103:15: error: Argument 1 of
"get_by_trading_pair" is incompatible with supertype "PositionRepository";
supertype defines the argument type as "TradingPair"  [override]
            self, trading_pair: TradingPair, open_only: bool = True
                  ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:103:15: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:103:15: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:120:5: error: Return type
"Coroutine[Any, Any, list[domain.entities.position.Position]]" of
"get_open_positions" incompatible with return type
"Coroutine[Any, Any, list[domain.entities.trading.Position]]" in supertype
"PositionRepository"  [override]
        async def get_open_positions(
        ^
infrastructure\repositories\position_repository.py:121:15: error: Argument 1 of
"get_open_positions" is incompatible with supertype "PositionRepository";
supertype defines the argument type as "TradingPair | None"  [override]
            self, trading_pair: Optional[TradingPair] = None
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:121:15: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:121:15: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:137:19: error:
"InMemoryPositionRepository" has no attribute "_analyze_position_risk" 
[attr-defined]
                await self._analyze_position_risk(position)
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:141:5: error: Return type
"Coroutine[Any, Any, list[domain.entities.position.Position]]" of
"get_closed_positions" incompatible with return type
"Coroutine[Any, Any, list[domain.entities.trading.Position]]" in supertype
"PositionRepository"  [override]
        async def get_closed_positions(
        ^
infrastructure\repositories\position_repository.py:143:9: error: Argument 1 of
"get_closed_positions" is incompatible with supertype "PositionRepository";
supertype defines the argument type as "TradingPair | None"  [override]
            trading_pair: Optional[TradingPair] = None,
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:143:9: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:143:9: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:156:50: error: "Position"
has no attribute "entry_time"; maybe "entry_price"?  [attr-defined]
                positions = [p for p in positions if p.entry_time >= start...
                                                     ^~~~~~~~~~~~
infrastructure\repositories\position_repository.py:158:50: error: "Position"
has no attribute "entry_time"; maybe "entry_price"?  [attr-defined]
                positions = [p for p in positions if p.entry_time <= end_d...
                                                     ^~~~~~~~~~~~
infrastructure\repositories\position_repository.py:161:5: error: Return type
"Coroutine[Any, Any, list[domain.entities.position.Position]]" of
"get_positions_by_side" incompatible with return type
"Coroutine[Any, Any, list[domain.entities.trading.Position]]" in supertype
"PositionRepository"  [override]
        async def get_positions_by_side(
        ^
infrastructure\repositories\position_repository.py:163:9: error: Argument 1 of
"get_positions_by_side" is incompatible with supertype "PositionRepository";
supertype defines the argument type as "PositionSide"  [override]
            side: PositionSide,
            ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:163:9: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:163:9: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:164:9: error: Argument 2 of
"get_positions_by_side" is incompatible with supertype "PositionRepository";
supertype defines the argument type as "TradingPair | None"  [override]
            trading_pair: Optional[TradingPair] = None,
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:164:9: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:164:9: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:179:5: error: Return type
"Coroutine[Any, Any, list[domain.entities.position.Position]]" of
"get_positions_by_date_range" incompatible with return type
"Coroutine[Any, Any, list[domain.entities.trading.Position]]" in supertype
"PositionRepository"  [override]
        async def get_positions_by_date_range(
        ^
infrastructure\repositories\position_repository.py:183:9: error: Argument 3 of
"get_positions_by_date_range" is incompatible with supertype
"PositionRepository"; supertype defines the argument type as
"TradingPair | None"  [override]
            trading_pair: Optional[TradingPair] = None,
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:183:9: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:183:9: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:189:30: error: "Position"
has no attribute "entry_time"; maybe "entry_price"?  [attr-defined]
                if start_date <= p.entry_time <= end_date
                                 ^~~~~~~~~~~~
infrastructure\repositories\position_repository.py:196:5: error: Return type
"Coroutine[Any, Any, domain.entities.position.Position]" of "update"
incompatible with return type
"Coroutine[Any, Any, domain.entities.trading.Position]" in supertype
"PositionRepository"  [override]
        async def update(self, position: Position) -> Position:
        ^
infrastructure\repositories\position_repository.py:196:28: error: Argument 1 of
"update" is incompatible with supertype "PositionRepository"; supertype defines
the argument type as "Position"  [override]
        async def update(self, position: Position) -> Position:
                               ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:196:28: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:196:28: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:200:19: error: Missing
positional arguments "entity_type", "entity_id" in call to "EntityNotFoundError"
 [call-arg]
                raise EntityNotFoundError("Position not found")
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:203:9: error:
"InMemoryPositionRepository" has no attribute "_remove_from_indexes" 
[attr-defined]
            self._remove_from_indexes(entity_id, old_position)
            ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:206:9: error:
"InMemoryPositionRepository" has no attribute "_update_position_indexes" 
[attr-defined]
            self._update_position_indexes(entity_id, position)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:221:13: error:
"InMemoryPositionRepository" has no attribute "_remove_from_indexes" 
[attr-defined]
                self._remove_from_indexes(entity_id, position)
                ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:225:13: error:
"InMemoryPositionRepository" has no attribute "_update_position_metrics" 
[attr-defined]
                self._update_position_metrics()
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:231:28: error: Argument 1 of
"exists" is incompatible with supertype "PositionRepository"; supertype defines
the argument type as "UUID | str"  [override]
        async def exists(self, position_id: str) -> bool:
                               ^~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:231:28: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:231:28: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:231:28: error: Argument 1 of
"exists" is incompatible with supertype "RepositoryProtocol"; supertype defines
the argument type as "UUID | str"  [override]
        async def exists(self, position_id: str) -> bool:
                               ^~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:239:5: error: Signature of
"count" incompatible with supertype "PositionRepository"  [override]
        async def count(
        ^
infrastructure\repositories\position_repository.py:239:5: note:      Superclass:
infrastructure\repositories\position_repository.py:239:5: note:          def count(self, filters: list[QueryFilter] | None = ...) -> Coroutine[Any, Any, int]
infrastructure\repositories\position_repository.py:239:5: note:      Subclass:
infrastructure\repositories\position_repository.py:239:5: note:          def count(self, open_only: bool = ..., trading_pair: TradingPair | None = ...) -> Coroutine[Any, Any, int]
infrastructure\repositories\position_repository.py:239:5: error: Signature of
"count" incompatible with supertype "RepositoryProtocol"  [override]
        async def count(
        ^
infrastructure\repositories\position_repository.py:239:5: note:      Superclass:
infrastructure\repositories\position_repository.py:239:5: note:          def count(self, filters: list[QueryFilter] | None = ...) -> Coroutine[Any, Any, int]
infrastructure\repositories\position_repository.py:239:5: note:      Subclass:
infrastructure\repositories\position_repository.py:239:5: note:          def count(self, open_only: bool = ..., trading_pair: TradingPair | None = ...) -> Coroutine[Any, Any, int]
infrastructure\repositories\position_repository.py:251:5: error: Return type
"Coroutine[Any, Any, list[domain.entities.position.Position]]" of
"get_profitable_positions" incompatible with return type
"Coroutine[Any, Any, list[domain.entities.trading.Position]]" in supertype
"PositionRepository"  [override]
        async def get_profitable_positions(
        ^
infrastructure\repositories\position_repository.py:253:9: error: Argument 1 of
"get_profitable_positions" is incompatible with supertype "PositionRepository";
supertype defines the argument type as "TradingPair | None"  [override]
            trading_pair: Optional[TradingPair] = None,
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:253:9: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:253:9: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:265:50: error: "Position"
has no attribute "entry_time"; maybe "entry_price"?  [attr-defined]
                positions = [p for p in positions if p.entry_time >= start...
                                                     ^~~~~~~~~~~~
infrastructure\repositories\position_repository.py:267:50: error: "Position"
has no attribute "entry_time"; maybe "entry_price"?  [attr-defined]
                positions = [p for p in positions if p.entry_time <= end_d...
                                                     ^~~~~~~~~~~~
infrastructure\repositories\position_repository.py:270:5: error: Return type
"Coroutine[Any, Any, list[domain.entities.position.Position]]" of
"get_losing_positions" incompatible with return type
"Coroutine[Any, Any, list[domain.entities.trading.Position]]" in supertype
"PositionRepository"  [override]
        async def get_losing_positions(
        ^
infrastructure\repositories\position_repository.py:272:9: error: Argument 1 of
"get_losing_positions" is incompatible with supertype "PositionRepository";
supertype defines the argument type as "TradingPair | None"  [override]
            trading_pair: Optional[TradingPair] = None,
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:272:9: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:272:9: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:282:50: error: "Position"
has no attribute "entry_time"; maybe "entry_price"?  [attr-defined]
                positions = [p for p in positions if p.entry_time >= start...
                                                     ^~~~~~~~~~~~
infrastructure\repositories\position_repository.py:284:50: error: "Position"
has no attribute "entry_time"; maybe "entry_price"?  [attr-defined]
                positions = [p for p in positions if p.entry_time <= end_d...
                                                     ^~~~~~~~~~~~
infrastructure\repositories\position_repository.py:287:5: error: Return type
"Coroutine[Any, Any, list[domain.entities.position.Position]]" of
"get_positions_with_stop_loss" incompatible with return type
"Coroutine[Any, Any, list[domain.entities.trading.Position]]" in supertype
"PositionRepository"  [override]
        async def get_positions_with_stop_loss(
        ^
infrastructure\repositories\position_repository.py:288:15: error: Argument 1 of
"get_positions_with_stop_loss" is incompatible with supertype
"PositionRepository"; supertype defines the argument type as
"TradingPair | None"  [override]
            self, trading_pair: Optional[TradingPair] = None
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:288:15: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:288:15: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:295:5: error: Return type
"Coroutine[Any, Any, list[domain.entities.position.Position]]" of
"get_positions_with_take_profit" incompatible with return type
"Coroutine[Any, Any, list[domain.entities.trading.Position]]" in supertype
"PositionRepository"  [override]
        async def get_positions_with_take_profit(
        ^
infrastructure\repositories\position_repository.py:296:15: error: Argument 1 of
"get_positions_with_take_profit" is incompatible with supertype
"PositionRepository"; supertype defines the argument type as
"TradingPair | None"  [override]
            self, trading_pair: Optional[TradingPair] = None
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:296:15: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:296:15: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:305:9: error: Argument 1 of
"get_statistics" is incompatible with supertype "PositionRepository"; supertype
defines the argument type as "TradingPair | None"  [override]
            trading_pair: Optional[TradingPair] = None,
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:305:9: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:305:9: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:313:50: error: "Position"
has no attribute "entry_time"; maybe "entry_price"?  [attr-defined]
                positions = [p for p in positions if p.entry_time >= start...
                                                     ^~~~~~~~~~~~
infrastructure\repositories\position_repository.py:315:50: error: "Position"
has no attribute "entry_time"; maybe "entry_price"?  [attr-defined]
                positions = [p for p in positions if p.entry_time <= end_d...
                                                     ^~~~~~~~~~~~
infrastructure\repositories\position_repository.py:329:15: error: Argument 1 of
"get_total_exposure" is incompatible with supertype "PositionRepository";
supertype defines the argument type as "TradingPair | None"  [override]
            self, trading_pair: Optional[TradingPair] = None
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:329:15: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:329:15: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:334:30: error: "Position"
has no attribute "quantity"  [attr-defined]
            total_exposure = sum(p.quantity.value for p in positions)
                                 ^~~~~~~~~~
infrastructure\repositories\position_repository.py:339:58: error: "Position"
has no attribute "entry_time"; maybe "entry_price"?  [attr-defined]
    ...    pid for pid, p in self._positions.items() if p.entry_time < before...
                                                        ^~~~~~~~~~~~
infrastructure\repositories\position_repository.py:345:5: error: Return type
"Coroutine[Any, Any, domain.entities.position.Position | None]" of
"get_by_symbol" incompatible with return type
"Coroutine[Any, Any, domain.entities.trading.Position | None]" in supertype
"PositionRepository"  [override]
        async def get_by_symbol(
        ^
infrastructure\repositories\position_repository.py:351:21: error: "Position"
has no attribute "symbol"  [attr-defined]
                    and position.symbol == symbol
                        ^~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:377:26: error: Argument 1 of
"save" is incompatible with supertype "PositionRepository"; supertype defines
the argument type as "Position"  [override]
        async def save(self, position: Position) -> bool:
                             ^~~~~~~~~~~~~~~~~~
infrastructure\repositories\position_repository.py:377:26: note: This violates the Liskov substitution principle
infrastructure\repositories\position_repository.py:377:26: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\position_repository.py:409:13: error: Unsupported
operand types for + ("None" and "int")  [operator]
                self._metrics["total_queries"] += 1
                ^
infrastructure\repositories\position_repository.py:409:13: note: Left operand is of type "int | None"
infrastructure\repositories\position_repository.py:412:13: error: Unsupported
operand types for + ("None" and "int")  [operator]
                self._metrics["errors"] += 1
                ^
infrastructure\repositories\position_repository.py:412:13: note: Left operand is of type "int | None"
infrastructure\repositories\position_repository.py:413:43: error: Incompatible
types in assignment (expression has type "str", target has type "int | None") 
[assignment]
                self._metrics["last_error"] = str(e)
                                              ^~~~~~
infrastructure\repositories\position_repository.py:416:5: error: Return type
"Coroutine[Any, Any, domain.entities.position.Position | None]" of "get_by_id"
incompatible with return type
"Coroutine[Any, Any, domain.entities.trading.Position | None]" in supertype
"PositionRepository"  [override]
        async def get_by_id(self, position_id: Union[UUID, str]) -> Option...
        ^
infrastructure\repositories\position_repository.py:423:17: error: Unsupported
operand types for + ("None" and "int")  [operator]
                    self._metrics["total_queries"] += 1
                    ^
infrastructure\repositories\position_repository.py:423:17: note: Left operand is of type "int | None"
infrastructure\repositories\position_repository.py:425:28: error: Unexpected
keyword argument "quantity" for "Position"  [call-arg]
                        return Position(
                               ^
infrastructure\repositories\position_repository.py:425:28: error: Unexpected
keyword argument "entry_time" for "Position"; did you mean "entry_price"? 
[call-arg]
                        return Position(
                               ^
infrastructure\repositories\position_repository.py:425:28: error: Unexpected
keyword argument "exit_time" for "Position"  [call-arg]
                        return Position(
                               ^
infrastructure\repositories\position_repository.py:425:28: error: Unexpected
keyword argument "is_open" for "Position"  [call-arg]
                        return Position(
                               ^
infrastructure\repositories\position_repository.py:425:28: error: Unexpected
keyword argument "is_profitable" for "Position"  [call-arg]
                        return Position(
                               ^
infrastructure\repositories\position_repository.py:440:13: error: Unsupported
operand types for + ("None" and "int")  [operator]
                self._metrics["errors"] += 1
                ^
infrastructure\repositories\position_repository.py:440:13: note: Left operand is of type "int | None"
infrastructure\repositories\position_repository.py:441:43: error: Incompatible
types in assignment (expression has type "str", target has type "int | None") 
[assignment]
                self._metrics["last_error"] = str(e)
                                              ^~~~~~
infrastructure\repositories\order_repository.py:75:44: error: Argument 1 of
"_get_entity_by_id_impl" is incompatible with supertype "BaseRepositoryImpl";
supertype defines the argument type as "UUID | str"  [override]
        async def _get_entity_by_id_impl(self, order_id: OrderId) -> Optio...
                                               ^~~~~~~~~~~~~~~~~
infrastructure\repositories\order_repository.py:75:44: note: This violates the Liskov substitution principle
infrastructure\repositories\order_repository.py:75:44: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\order_repository.py:95:41: error: Argument 1 of
"_delete_entity_impl" is incompatible with supertype "BaseRepositoryImpl";
supertype defines the argument type as "UUID | str"  [override]
        async def _delete_entity_impl(self, order_id: OrderId) -> bool:
                                            ^~~~~~~~~~~~~~~~~
infrastructure\repositories\order_repository.py:95:41: note: This violates the Liskov substitution principle
infrastructure\repositories\order_repository.py:95:41: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
infrastructure\repositories\order_repository.py:326:9: error: Unsupported
target for indexed assignment ("RepositoryMetrics")  [index]
            self._metrics["total_orders"] = len(self._orders)
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\order_repository.py:380:13: error: Unsupported
target for indexed assignment ("RepositoryMetrics")  [index]
                self._metrics["cache_hits"] = int(self._metrics.get("cache...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\order_repository.py:380:47: error:
"RepositoryMetrics" has no attribute "get"  [attr-defined]
                self._metrics["cache_hits"] = int(self._metrics.get("cache...
                                                  ^~~~~~~~~~~~~~~~~
infrastructure\repositories\order_repository.py:382:9: error: Unsupported
target for indexed assignment ("RepositoryMetrics")  [index]
            self._metrics["cache_misses"] = int(self._metrics.get("cache_m...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\order_repository.py:382:45: error:
"RepositoryMetrics" has no attribute "get"  [attr-defined]
            self._metrics["cache_misses"] = int(self._metrics.get("cache_m...
                                                ^~~~~~~~~~~~~~~~~
infrastructure\repositories\order_repository.py:529:13: error: Dict entry 4 has
incompatible type "str": "None"; expected "str": "int"  [dict-item]
                "last_health_check": None,
                ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\repositories\order_repository.py:1074:26: error: Argument
"trading_pair" to "Order" has incompatible type
"domain.value_objects.trading_pair.TradingPair"; expected
"domain.types.TradingPair"  [arg-type]
                trading_pair=TradingPair.from_symbol(row["trading_pair"]) ...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\repositories\order_repository.py:1183:5: error: Return type
"AsyncIterator[Order]" of "stream" incompatible with return type
"Coroutine[Any, Any, AsyncIterator[Order]]" in supertype "RepositoryProtocol" 
[override]
        def stream(
        ^
infrastructure\repositories\order_repository.py:1183:5: note: Consider declaring "stream" in supertype "RepositoryProtocol" without "async"
infrastructure\repositories\order_repository.py:1183:5: note: See https://mypy.readthedocs.io/en/stable/more_types.html#asynchronous-iterators
infrastructure\repositories\order_repository.py:1205:5: error: Return type
"_AsyncGeneratorContextManager[Any, None]" of "transaction" incompatible with
return type "Coroutine[Any, Any, AsyncIterator[TransactionProtocol]]" in
supertype "RepositoryProtocol"  [override]
        async def transaction(self) -> AsyncIterator[Any]:
        ^
infrastructure\repositories\order_repository.py:1229:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\order_repository.py:1246:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\order_repository.py:1267:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\order_repository.py:1289:16: error: Missing
positional arguments "success_count", "error_count" in call to
"BulkOperationResult"  [call-arg]
            return BulkOperationResult(
                   ^
infrastructure\repositories\order_repository.py:1329:16: error: Extra keys
("total_queries", "avg_query_time", "cache_hit_rate", "error_rate") for
TypedDict "PerformanceMetricsDict"  [typeddict-unknown-key]
            return {
                   ^
infrastructure\repositories\order_repository.py:1355:20: error: Extra keys
("response_time_ms", "uptime_seconds", "memory_usage_mb", "disk_usage_mb",
"connection_status", "cache_status") for TypedDict "HealthCheckDict" 
[typeddict-unknown-key]
                return {
                       ^
infrastructure\repositories\order_repository.py:1367:20: error: Extra keys
("response_time_ms", "uptime_seconds", "memory_usage_mb", "disk_usage_mb",
"connection_status", "cache_status") for TypedDict "HealthCheckDict" 
[typeddict-unknown-key]
                return {
                       ^
infrastructure\ml_services\evolvable_decision_reasoner.py:69:48: error:
Incompatible types in assignment (expression has type "EvolvableDecisionConfig",
base class "DecisionReasoner" defined the type as "dict[str, Any]") 
[assignment]
            self.config: EvolvableDecisionConfig = config or EvolvableDeci...
                                                   ^~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\ml_services\evolvable_decision_reasoner.py:79:55: error:
Incompatible types in assignment (expression has type "list[dict[str, Any]]",
base class "DecisionReasoner" defined the type as "list[AggregatedSignal]") 
[assignment]
            self.decision_history: List[Dict[str, Any]] = []
                                                          ^~
infrastructure\ml_services\evolvable_decision_reasoner.py:84:5: error: Missing
return statement  [return]
        async def adapt(self, data: Dict[str, Any]) -> bool:
        ^
infrastructure\ml_services\evolvable_decision_reasoner.py:113:5: error: Missing
return statement  [return]
        async def learn(self, data: Dict[str, Any]) -> bool:
        ^
infrastructure\ml_services\evolvable_decision_reasoner.py:376:17: error:
Property "confidence" defined in "AggregatedSignal" is read-only  [misc]
                    decision.confidence = min(final_confidence, 1.0)
                    ^~~~~~~~~~~~~~~~~~~
infrastructure\core\evolvable_components.py:91:13: error: "EvolvableStrategy"
has no attribute "adaptation_count"; maybe "adaptation_rate"?  [attr-defined]
                self.adaptation_count += 1
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\evolvable_components.py:148:20: error: Name "np" is not
defined  [name-defined]
                return np.mean(recent_performance)
                       ^~
infrastructure\core\evolvable_components.py:163:31: error: Name "np" is not
defined  [name-defined]
                stability = 1.0 - np.std(recent_performance)
                                  ^~
infrastructure\core\evolvable_components.py:223:58: error: Name "pd" is not
defined  [name-defined]
    ...c def _quick_adapt_parameters(self, market_data: pd.DataFrame) -> None...
                                                        ^
infrastructure\core\evolvable_components.py:248:28: error: Name "pd" is not
defined  [name-defined]
            self, market_data: pd.DataFrame, performance_data: Dict[str, A...
                               ^
infrastructure\core\evolvable_components.py:278:50: error: Name "pd" is not
defined  [name-defined]
        async def _full_evolution(self, market_data: pd.DataFrame) -> None...
                                                     ^
infrastructure\core\evolvable_components.py:292:28: error: Name "pd" is not
defined  [name-defined]
            self, market_data: pd.DataFrame
                               ^
infrastructure\core\evolvable_components.py:306:36: error: Name "np" is not
defined  [name-defined]
                            mutation = np.random.normal(0, 0.1)
                                       ^~
infrastructure\core\evolvable_components.py:317:32: error: Name "np" is not
defined  [name-defined]
                    best_indices = np.argsort(fitness_scores)[-5:]
                                   ^~
infrastructure\core\evolvable_components.py:322:40: error: Name "np" is not
defined  [name-defined]
                        parent1, parent2 = np.random.choice(
                                           ^~
infrastructure\core\evolvable_components.py:330:42: error: Name "np" is not
defined  [name-defined]
                best_individual = population[np.argmax(fitness_scores)]
                                             ^~
infrastructure\core\evolvable_components.py:337:56: error: Name "pd" is not
defined  [name-defined]
            self, parameters: Dict[str, Any], market_data: pd.DataFrame
                                                           ^
infrastructure\core\evolvable_components.py:354:29: error: Name "np" is not
defined  [name-defined]
                returns_array = np.array(returns)
                                ^~
infrastructure\core\evolvable_components.py:362:23: error: Name "pd" is not
defined  [name-defined]
            self, window: pd.DataFrame, parameters: Dict[str, Any]
                          ^
infrastructure\core\evolvable_components.py:390:20: error: Name "np" is not
defined  [name-defined]
                    if np.random.random() < 0.5:
                       ^~
infrastructure\core\evolvable_components.py:397:24: error: Name "np" is not
defined  [name-defined]
                        if np.random.random() < 0.1:  # 10% веро€тность му...
                           ^~
infrastructure\core\evolvable_components.py:398:36: error: Name "np" is not
defined  [name-defined]
                            mutation = np.random.normal(0, 0.05)
                                       ^~
infrastructure\core\evolvable_components.py:429:9: error: Need type annotation
for "feature_importance" (hint:
"feature_importance: dict[<type>, <type>] = ...")  [var-annotated]
            self.feature_importance = {}
            ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\evolvable_components.py:430:9: error: Need type annotation
for "prediction_history" (hint: "prediction_history: list[<type>] = ...") 
[var-annotated]
            self.prediction_history = []
            ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\evolvable_components.py:442:13: error: "EvolvablePredictor"
has no attribute "adaptation_count"  [attr-defined]
                self.adaptation_count += 1
                ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\evolvable_components.py:488:24: error: Name "np" is not
defined  [name-defined]
                accuracy = np.mean([p.get("accuracy", 0.0) for p in recent...
                           ^~
infrastructure\core\evolvable_components.py:502:20: error: Name "np" is not
defined  [name-defined]
                return np.mean(confidences)
                       ^~
infrastructure\core\evolvable_components.py:548:50: error: Name "np" is not
defined  [name-defined]
        async def _quick_adapt_model(self, features: np.ndarray) -> None:
                                                     ^
infrastructure\core\evolvable_components.py:560:44: error: Name "np" is not
defined  [name-defined]
        async def _learn_model(self, features: np.ndarray, targets: np.nda...
                                               ^
infrastructure\core\evolvable_components.py:569:13: error: "None" has no
attribute "fit"  [attr-defined]
                self.model.fit(features, targets)
                ^~~~~~~~~~~~~~
infrastructure\core\evolvable_components.py:574:52: error: "None" has no
attribute "feature_importances_"  [attr-defined]
    ...                  for i, importance in enumerate(self.model.feature_im...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\evolvable_components.py:579:45: error: Name "np" is not
defined  [name-defined]
        async def _evolve_model(self, features: np.ndarray, targets: np.nd...
                                                ^
infrastructure\core\evolvable_components.py:587:24: error: Name
"RandomForestRegressor" is not defined  [name-defined]
                    ("rf", RandomForestRegressor(n_estimators=100, random_...
                           ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\evolvable_components.py:592:13: error: "None" has no
attribute "fit"  [attr-defined]
                self.model.fit(features, targets)
                ^~~~~~~~~~~~~~
infrastructure\agents\evolvable_strategy_agent.py:20:18: error: Name "nn" is
not defined  [name-defined]
    class StrategyML(nn.Module):
                     ^~
infrastructure\agents\evolvable_strategy_agent.py:27:20: error: Name "nn" is
not defined  [name-defined]
            self.net = nn.Sequential(
                       ^~
infrastructure\agents\evolvable_strategy_agent.py:28:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(input_dim, hidden_dim),
                ^~
infrastructure\agents\evolvable_strategy_agent.py:29:13: error: Name "nn" is
not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_strategy_agent.py:30:13: error: Name "nn" is
not defined  [name-defined]
                nn.Dropout(0.2),
                ^~
infrastructure\agents\evolvable_strategy_agent.py:31:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(hidden_dim, hidden_dim // 2),
                ^~
infrastructure\agents\evolvable_strategy_agent.py:32:13: error: Name "nn" is
not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_strategy_agent.py:33:13: error: Name "nn" is
not defined  [name-defined]
                nn.Linear(
                ^~
infrastructure\agents\evolvable_strategy_agent.py:50:26: error: Name "nn" is
not defined  [name-defined]
            self.criterion = nn.CrossEntropyLoss()
                             ^~
infrastructure\agents\evolvable_strategy_agent.py:57:9: error: Need type
annotation for "training_data" (hint: "training_data: list[<type>] = ...") 
[var-annotated]
            self.training_data = []
            ^~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_strategy_agent.py:71:5: error: Missing return
statement  [return]
        async def adapt(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_strategy_agent.py:99:5: error: Missing return
statement  [return]
        async def learn(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_strategy_agent.py:217:28: error: Name "pd" is
not defined  [name-defined]
            self, market_data: pd.DataFrame, strategy_performance: Dict
                               ^
infrastructure\agents\evolvable_strategy_agent.py:268:34: error: Name "pd" is
not defined  [name-defined]
                features = [f if not pd.isna(f) else 0.0 for f in features...
                                     ^~
infrastructure\agents\evolvable_strategy_agent.py:297:41: error: Name "np" is
not defined  [name-defined]
            self, loss: float, predictions: np.ndarray, target_strategy: i...
                                            ^
infrastructure\agents\evolvable_strategy_agent.py:306:34: error: Name "np" is
not defined  [name-defined]
                predicted_strategy = np.argmax(predictions)
                                     ^~
infrastructure\agents\evolvable_strategy_agent.py:385:22: error: Name "pd" is
not defined  [name-defined]
            market_data: pd.DataFrame,
                         ^
infrastructure\agents\evolvable_strategy_agent.py:396:35: error: Name "np" is
not defined  [name-defined]
                best_strategy_index = np.argmax(predictions_np)
                                      ^~
infrastructure\agents\evolvable_risk_agent.py:22:14: error: Name "nn" is not
defined  [name-defined]
    class RiskML(nn.Module):
                 ^~
infrastructure\agents\evolvable_risk_agent.py:27:20: error: Name "nn" is not
defined  [name-defined]
            self.net = nn.Sequential(
                       ^~
infrastructure\agents\evolvable_risk_agent.py:28:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(input_dim, hidden_dim),
                ^~
infrastructure\agents\evolvable_risk_agent.py:29:13: error: Name "nn" is not
defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_risk_agent.py:30:13: error: Name "nn" is not
defined  [name-defined]
                nn.Dropout(0.2),
                ^~
infrastructure\agents\evolvable_risk_agent.py:31:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(hidden_dim, hidden_dim // 2),
                ^~
infrastructure\agents\evolvable_risk_agent.py:32:13: error: Name "nn" is not
defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_risk_agent.py:33:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(
                ^~
infrastructure\agents\evolvable_risk_agent.py:52:26: error: Name "nn" is not
defined  [name-defined]
            self.criterion = nn.MSELoss()
                             ^~
infrastructure\agents\evolvable_risk_agent.py:59:9: error: Need type annotation
for "training_data" (hint: "training_data: list[<type>] = ...")  [var-annotated]
            self.training_data = []
            ^~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_risk_agent.py:65:5: error: Missing return
statement  [return]
        async def adapt(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_risk_agent.py:89:5: error: Missing return
statement  [return]
        async def learn(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_risk_agent.py:212:28: error: Name "pd" is not
defined  [name-defined]
            self, market_data: pd.DataFrame, positions: Dict
                               ^
infrastructure\agents\evolvable_risk_agent.py:240:34: error: Name "pd" is not
defined  [name-defined]
                features = [f if not pd.isna(f) else 0.0 for f in features...
                                     ^~
infrastructure\agents\evolvable_risk_agent.py:246:45: error: Name "pd" is not
defined  [name-defined]
        def _extract_targets(self, market_data: pd.DataFrame) -> Dict[str,...
                                                ^
infrastructure\agents\evolvable_risk_agent.py:267:28: error: Name "np" is not
defined  [name-defined]
                var_95 = float(np.percentile(returns, 5))
                               ^~
infrastructure\agents\evolvable_risk_agent.py:268:28: error: Name "np" is not
defined  [name-defined]
                var_99 = float(np.percentile(returns, 1))
                               ^~
infrastructure\agents\evolvable_risk_agent.py:270:26: error: Name "np" is not
defined  [name-defined]
                cumulative = np.cumprod(1 + returns)
                             ^~
infrastructure\agents\evolvable_risk_agent.py:271:27: error: Name "np" is not
defined  [name-defined]
                rolling_max = np.maximum.accumulate(cumulative)
                              ^~
infrastructure\agents\evolvable_risk_agent.py:275:30: error: Name "np" is not
defined  [name-defined]
                win_rate = float(np.mean(returns > 0))
                                 ^~
infrastructure\agents\evolvable_risk_agent.py:276:61: error: Name "np" is not
defined  [name-defined]
    ... avg_win = float(returns[returns > 0].mean()) if np.any(returns > 0) e...
                                                        ^~
infrastructure\agents\evolvable_risk_agent.py:278:60: error: Name "np" is not
defined  [name-defined]
    ...      float(abs(returns[returns < 0].mean())) if np.any(returns < 0) e...
                                                        ^~
infrastructure\agents\evolvable_risk_agent.py:305:57: error: Name "np" is not
defined  [name-defined]
        def _update_metrics(self, loss: float, predictions: np.ndarray):
                                                            ^
infrastructure\agents\evolvable_risk_agent.py:394:41: error: Name "pd" is not
defined  [name-defined]
            self, symbol: str, market_data: pd.DataFrame, positions: Dict[...
                                            ^
infrastructure\agents\evolvable_risk_agent.py:399:28: error: "RiskAgent" has no
attribute "process"  [attr-defined]
                result = await self.risk_agent.process(
                               ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_risk_agent.py:417:28: error: Name "pd" is not
defined  [name-defined]
            self, market_data: pd.DataFrame, positions: Dict = None
                               ^
infrastructure\agents\evolvable_risk_agent.py:417:60: error: Incompatible
default for argument "positions" (default has type "None", argument has type
"dict[Any, Any]")  [assignment]
            self, market_data: pd.DataFrame, positions: Dict = None
                                                               ^~~~
infrastructure\agents\evolvable_risk_agent.py:417:60: note: PEP 484 prohibits implicit Optional. Accordingly, mypy has changed its default to no_implicit_optional=True
infrastructure\agents\evolvable_risk_agent.py:417:60: note: Use https://github.com/hauntsaninja/no_implicit_optional to automatically upgrade your codebase
infrastructure\agents\evolvable_news_agent.py:22:14: error: Name "nn" is not
defined  [name-defined]
    class NewsML(nn.Module):
                 ^~
infrastructure\agents\evolvable_news_agent.py:27:20: error: Name "nn" is not
defined  [name-defined]
            self.net = nn.Sequential(
                       ^~
infrastructure\agents\evolvable_news_agent.py:28:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(input_dim, hidden_dim),
                ^~
infrastructure\agents\evolvable_news_agent.py:29:13: error: Name "nn" is not
defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_news_agent.py:30:13: error: Name "nn" is not
defined  [name-defined]
                nn.Dropout(0.2),
                ^~
infrastructure\agents\evolvable_news_agent.py:31:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(hidden_dim, hidden_dim // 2),
                ^~
infrastructure\agents\evolvable_news_agent.py:32:13: error: Name "nn" is not
defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_news_agent.py:33:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(hidden_dim // 2, 3),  # sentiment, impact, confi...
                ^~
infrastructure\agents\evolvable_news_agent.py:46:27: error: Cannot instantiate
abstract class "NewsAgent" with abstract attributes "analyze_sentiment",
"get_relevant_news" and "process_news"  [abstract]
            self.news_agent = NewsAgent()
                              ^~~~~~~~~~~
infrastructure\agents\evolvable_news_agent.py:50:26: error: Name "nn" is not
defined  [name-defined]
            self.criterion = nn.MSELoss()
                             ^~
infrastructure\agents\evolvable_news_agent.py:57:9: error: Need type annotation
for "training_data" (hint: "training_data: list[<type>] = ...")  [var-annotated]
            self.training_data = []
            ^~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_news_agent.py:63:5: error: Missing return
statement  [return]
        async def adapt(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_news_agent.py:70:37: error: Name "np" is not
defined  [name-defined]
                        avg_sentiment = np.mean(
                                        ^~
infrastructure\agents\evolvable_news_agent.py:75:25: error: Unsupported target
for indexed assignment ("NewsConfig")  [index]
                            self.news_agent.config["sentiment_threshold"] ...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_news_agent.py:78:25: error: Unsupported target
for indexed assignment ("NewsConfig")  [index]
                            self.news_agent.config["impact_threshold"] = m...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_news_agent.py:89:5: error: Missing return
statement  [return]
        async def learn(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_news_agent.py:210:60: error: Name "pd" is not
defined  [name-defined]
    ...      self, news_data: List[Dict], market_data: Optional[pd.DataFrame]
                                                                ^
infrastructure\agents\evolvable_news_agent.py:225:25: error: Name "np" is not
defined  [name-defined]
                            np.mean(sentiments),
                            ^~
infrastructure\agents\evolvable_news_agent.py:226:25: error: Name "np" is not
defined  [name-defined]
                            np.std(sentiments),
                            ^~
infrastructure\agents\evolvable_news_agent.py:227:25: error: Name "np" is not
defined  [name-defined]
                            np.mean(impacts),
                            ^~
infrastructure\agents\evolvable_news_agent.py:228:25: error: Name "np" is not
defined  [name-defined]
                            np.std(impacts),
                            ^~
infrastructure\agents\evolvable_news_agent.py:229:25: error: Name "np" is not
defined  [name-defined]
                            np.mean(volumes),
                            ^~
infrastructure\agents\evolvable_news_agent.py:230:25: error: Name "np" is not
defined  [name-defined]
                            np.std(volumes),
                            ^~
infrastructure\agents\evolvable_news_agent.py:262:34: error: Name "pd" is not
defined  [name-defined]
                features = [f if not pd.isna(f) else 0.0 for f in features...
                                     ^~
infrastructure\agents\evolvable_news_agent.py:269:60: error: Name "pd" is not
defined  [name-defined]
    ...      self, news_data: List[Dict], market_data: Optional[pd.DataFrame]
                                                                ^
infrastructure\agents\evolvable_news_agent.py:277:39: error: Name "np" is not
defined  [name-defined]
                    avg_sentiment = float(np.mean(sentiments))
                                          ^~
infrastructure\agents\evolvable_news_agent.py:278:36: error: Name "np" is not
defined  [name-defined]
                    avg_impact = float(np.mean(impacts))
                                       ^~
infrastructure\agents\evolvable_news_agent.py:280:39: error: Name "np" is not
defined  [name-defined]
                    sentiment_std = float(np.std(sentiments))
                                          ^~
infrastructure\agents\evolvable_news_agent.py:295:57: error: Name "np" is not
defined  [name-defined]
        def _update_metrics(self, loss: float, predictions: np.ndarray):
                                                            ^
infrastructure\agents\evolvable_news_agent.py:378:31: error: Name "pd" is not
defined  [name-defined]
            market_data: Optional[pd.DataFrame] = None,
                                  ^
infrastructure\agents\evolvable_news_agent.py:383:28: error: "NewsAgent" has no
attribute "process"  [attr-defined]
                result = await self.news_agent.process(
                               ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_news_agent.py:401:60: error: Name "pd" is not
defined  [name-defined]
    ...elf, news_data: List[Dict], market_data: Optional[pd.DataFrame] = None
                                                         ^
infrastructure\agents\evolvable_market_regime_corrupted.py:22:22: error: Name
"nn" is not defined  [name-defined]
    class MarketRegimeML(nn.Module):
                         ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:27:20: error: Name
"nn" is not defined  [name-defined]
            self.net = nn.Sequential(
                       ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:28:13: error: Name
"nn" is not defined  [name-defined]
                nn.Linear(input_dim, hidden_dim),
                ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:29:13: error: Name
"nn" is not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:30:13: error: Name
"nn" is not defined  [name-defined]
                nn.Dropout(0.2),
                ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:31:13: error: Name
"nn" is not defined  [name-defined]
                nn.Linear(hidden_dim, hidden_dim // 2),
                ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:32:13: error: Name
"nn" is not defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:33:13: error: Name
"nn" is not defined  [name-defined]
                nn.Linear(
                ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:52:26: error: Name
"nn" is not defined  [name-defined]
            self.criterion = nn.CrossEntropyLoss()
                             ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:59:9: error: Need
type annotation for "training_data" (hint: "training_data: list[<type>] = ...") 
[var-annotated]
            self.training_data = []
            ^~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_market_regime_corrupted.py:65:5: error: Missing
return statement  [return]
        async def adapt(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_market_regime_corrupted.py:77:50: error:
TypedDict "AgentConfig" has no key "volatility_threshold" 
[typeddict-unknown-key]
                            self.regime_agent.config["volatility_threshold...
                                                     ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_market_regime_corrupted.py:80:50: error:
TypedDict "AgentConfig" has no key "trend_threshold"  [typeddict-unknown-key]
                            self.regime_agent.config["trend_threshold"] = ...
                                                     ^~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_market_regime_corrupted.py:80:50: note: Did you mean "risk_threshold"?
infrastructure\agents\evolvable_market_regime_corrupted.py:91:5: error: Missing
return statement  [return]
        async def learn(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_market_regime_corrupted.py:207:46: error: Name
"pd" is not defined  [name-defined]
        def _extract_features(self, market_data: pd.DataFrame) -> List[flo...
                                                 ^
infrastructure\agents\evolvable_market_regime_corrupted.py:254:34: error: Name
"pd" is not defined  [name-defined]
                features = [f if not pd.isna(f) else 0.0 for f in features...
                                     ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:270:57: error: Name
"np" is not defined  [name-defined]
    ... _update_metrics(self, loss: float, predictions: np.ndarray, target_re...
                                                        ^
infrastructure\agents\evolvable_market_regime_corrupted.py:280:32: error: Name
"np" is not defined  [name-defined]
                predicted_regime = np.argmax(predictions)
                                   ^~
infrastructure\agents\evolvable_market_regime_corrupted.py:349:41: error: Name
"pd" is not defined  [name-defined]
            self, symbol: str, market_data: pd.DataFrame
                                            ^
infrastructure\agents\evolvable_market_regime_corrupted.py:358:13: error:
Unsupported target for indexed assignment ("ProcessingResult")  [index]
                result["evolution_metrics"] = {
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_market_regime_corrupted.py:366:20: error:
Incompatible return value type (got "ProcessingResult", expected
"dict[str, Any]")  [return-value]
                return result
                       ^~~~~~
infrastructure\agents\evolvable_market_regime_corrupted.py:371:49: error: Name
"pd" is not defined  [name-defined]
        async def predict_regime(self, market_data: pd.DataFrame) -> Dict[...
                                                    ^
infrastructure\agents\evolvable_market_regime_corrupted.py:379:38: error: Name
"np" is not defined  [name-defined]
                predicted_regime_index = np.argmax(predictions_np)
                                         ^~
infrastructure\agents\evolvable_market_regime.py:22:22: error: Name "nn" is not
defined  [name-defined]
    class MarketRegimeML(nn.Module):
                         ^~
infrastructure\agents\evolvable_market_regime.py:27:20: error: Name "nn" is not
defined  [name-defined]
            self.net = nn.Sequential(
                       ^~
infrastructure\agents\evolvable_market_regime.py:28:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(input_dim, hidden_dim),
                ^~
infrastructure\agents\evolvable_market_regime.py:29:13: error: Name "nn" is not
defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_market_regime.py:30:13: error: Name "nn" is not
defined  [name-defined]
                nn.Dropout(0.2),
                ^~
infrastructure\agents\evolvable_market_regime.py:31:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(hidden_dim, hidden_dim // 2),
                ^~
infrastructure\agents\evolvable_market_regime.py:32:13: error: Name "nn" is not
defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_market_regime.py:33:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(
                ^~
infrastructure\agents\evolvable_market_regime.py:52:26: error: Name "nn" is not
defined  [name-defined]
            self.criterion = nn.CrossEntropyLoss()
                             ^~
infrastructure\agents\evolvable_market_regime.py:59:9: error: Need type
annotation for "training_data" (hint: "training_data: list[<type>] = ...") 
[var-annotated]
            self.training_data = []
            ^~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_market_regime.py:65:5: error: Missing return
statement  [return]
        async def adapt(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_market_regime.py:77:50: error: TypedDict
"AgentConfig" has no key "volatility_threshold"  [typeddict-unknown-key]
                            self.regime_agent.config["volatility_threshold...
                                                     ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_market_regime.py:80:50: error: TypedDict
"AgentConfig" has no key "trend_threshold"  [typeddict-unknown-key]
                            self.regime_agent.config["trend_threshold"] = ...
                                                     ^~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_market_regime.py:80:50: note: Did you mean "risk_threshold"?
infrastructure\agents\evolvable_market_regime.py:91:5: error: Missing return
statement  [return]
        async def learn(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_market_regime.py:207:46: error: Name "pd" is
not defined  [name-defined]
        def _extract_features(self, market_data: pd.DataFrame) -> List[flo...
                                                 ^
infrastructure\agents\evolvable_market_regime.py:254:34: error: Name "pd" is
not defined  [name-defined]
                features = [f if not pd.isna(f) else 0.0 for f in features...
                                     ^~
infrastructure\agents\evolvable_market_regime.py:270:57: error: Name "np" is
not defined  [name-defined]
    ... _update_metrics(self, loss: float, predictions: np.ndarray, target_re...
                                                        ^
infrastructure\agents\evolvable_market_regime.py:280:32: error: Name "np" is
not defined  [name-defined]
                predicted_regime = np.argmax(predictions)
                                   ^~
infrastructure\agents\evolvable_market_regime.py:349:41: error: Name "pd" is
not defined  [name-defined]
            self, symbol: str, market_data: pd.DataFrame
                                            ^
infrastructure\agents\evolvable_market_regime.py:358:13: error: Unsupported
target for indexed assignment ("ProcessingResult")  [index]
                result["evolution_metrics"] = {
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_market_regime.py:366:20: error: Incompatible
return value type (got "ProcessingResult", expected "dict[str, Any]") 
[return-value]
                return result
                       ^~~~~~
infrastructure\agents\evolvable_market_regime.py:371:49: error: Name "pd" is
not defined  [name-defined]
        async def predict_regime(self, market_data: pd.DataFrame) -> Dict[...
                                                    ^
infrastructure\agents\evolvable_market_regime.py:379:38: error: Name "np" is
not defined  [name-defined]
                predicted_regime_index = np.argmax(predictions_np)
                                         ^~
infrastructure\agents\evolvable_market_maker.py:22:21: error: Name "nn" is not
defined  [name-defined]
    class MarketMakerML(nn.Module):
                        ^~
infrastructure\agents\evolvable_market_maker.py:27:20: error: Name "nn" is not
defined  [name-defined]
            self.net = nn.Sequential(
                       ^~
infrastructure\agents\evolvable_market_maker.py:28:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(input_dim, hidden_dim),
                ^~
infrastructure\agents\evolvable_market_maker.py:29:13: error: Name "nn" is not
defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_market_maker.py:30:13: error: Name "nn" is not
defined  [name-defined]
                nn.Dropout(0.2),
                ^~
infrastructure\agents\evolvable_market_maker.py:31:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(hidden_dim, hidden_dim // 2),
                ^~
infrastructure\agents\evolvable_market_maker.py:32:13: error: Name "nn" is not
defined  [name-defined]
                nn.ReLU(),
                ^~
infrastructure\agents\evolvable_market_maker.py:33:13: error: Name "nn" is not
defined  [name-defined]
                nn.Linear(hidden_dim // 2, 3),  # direction, confidence, e...
                ^~
infrastructure\agents\evolvable_market_maker.py:50:26: error: Name "nn" is not
defined  [name-defined]
            self.criterion = nn.MSELoss()
                             ^~
infrastructure\agents\evolvable_market_maker.py:57:9: error: Need type
annotation for "training_data" (hint: "training_data: list[<type>] = ...") 
[var-annotated]
            self.training_data = []
            ^~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_market_maker.py:63:5: error: Missing return
statement  [return]
        async def adapt(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_market_maker.py:87:5: error: Missing return
statement  [return]
        async def learn(self, data: Any) -> bool:
        ^
infrastructure\agents\evolvable_market_maker.py:210:28: error: Name "pd" is not
defined  [name-defined]
            self, market_data: pd.DataFrame, order_book: Dict
                               ^
infrastructure\agents\evolvable_market_maker.py:240:34: error: Name "pd" is not
defined  [name-defined]
                features = [f if not pd.isna(f) else 0.0 for f in features...
                                     ^~
infrastructure\agents\evolvable_market_maker.py:246:45: error: Name "pd" is not
defined  [name-defined]
        def _extract_targets(self, market_data: pd.DataFrame) -> Dict[str,...
                                                ^
infrastructure\agents\evolvable_market_maker.py:253:25: error: Name "np" is not
defined  [name-defined]
                direction = np.sign(price_change)
                            ^~
infrastructure\agents\evolvable_market_maker.py:268:57: error: Name "np" is not
defined  [name-defined]
        def _update_metrics(self, loss: float, predictions: np.ndarray):
                                                            ^
infrastructure\agents\evolvable_market_maker.py:348:41: error: Name "pd" is not
defined  [name-defined]
            self, symbol: str, market_data: pd.DataFrame, order_book: Dict...
                                            ^
infrastructure\agents\evolvable_market_maker.py:353:28: error:
"MarketMakerModelAgent" has no attribute "process"  [attr-defined]
                result = await self.market_maker_agent.process(
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\evolvable_market_maker.py:371:28: error: Name "pd" is not
defined  [name-defined]
            self, market_data: pd.DataFrame, order_book: Dict = None
                               ^
infrastructure\agents\evolvable_market_maker.py:371:61: error: Incompatible
default for argument "order_book" (default has type "None", argument has type
"dict[Any, Any]")  [assignment]
            self, market_data: pd.DataFrame, order_book: Dict = None
                                                                ^~~~
infrastructure\agents\evolvable_market_maker.py:371:61: note: PEP 484 prohibits implicit Optional. Accordingly, mypy has changed its default to no_implicit_optional=True
infrastructure\agents\evolvable_market_maker.py:371:61: note: Use https://github.com/hauntsaninja/no_implicit_optional to automatically upgrade your codebase
infrastructure\agents\whales\agent.py:25:41: error: Argument 2 to "__init__" of
"BaseAgent" has incompatible type "dict[str, Any] | None"; expected
"Literal['market_maker', 'whale_analyzer', 'risk_manager', 'portfolio_optimizer', 'order_executor', 'news_analyzer', 'market_regime', 'strategy_agent', 'meta_controller', 'evolutionary_agent', 'social_media', 'entanglement_detector']"
 [arg-type]
            super().__init__("WhalesAgent", config)
                                            ^~~~~~
infrastructure\agents\whales\agent.py:26:9: error: Property "config" defined in
"BaseAgent" is read-only  [misc]
            self.config = config or {
            ^~~~~~~~~~~
infrastructure\agents\whales\agent.py:26:23: error: Incompatible types in
assignment (expression has type "dict[str, Any]", variable has type
"AgentConfig")  [assignment]
            self.config = config or {
                          ^
infrastructure\agents\whales\agent.py:36:55: error: TypedDict "AgentConfig" has
no key "enable_ml_model"  [typeddict-item]
    ...   self.ml_model = WhaleMLModel() if self.config["enable_ml_model"] el...
                                                        ^~~~~~~~~~~~~~~~~
infrastructure\agents\whales\agent.py:38:33: error: Argument 1 to
"WhaleSignalAnalyzer" has incompatible type "AgentConfig"; expected
"dict[str, Any]"  [arg-type]
                WhaleSignalAnalyzer(self.config)
                                    ^~~~~~~~~~~
infrastructure\agents\whales\agent.py:39:28: error: TypedDict "AgentConfig" has
no key "enable_signal_analysis"  [typeddict-item]
                if self.config["enable_signal_analysis"]
                               ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\whales\agent.py:43:49: error: TypedDict "AgentConfig" has
no key "enable_caching"  [typeddict-item]
                WhaleActivityCache() if self.config["enable_caching"] else...
                                                    ^~~~~~~~~~~~~~~~
infrastructure\agents\whales\agent.py:43:49: note: Did you mean "enable_learning"?
infrastructure\agents\whales\agent.py:47:37: error: Name "WhaleActivity" is not
defined  [name-defined]
            self.whale_activities: List[WhaleActivity] = []
                                        ^
infrastructure\agents\whales\agent.py:48:41: error: Name "WhaleAnalysis" is not
defined  [name-defined]
            self.current_analysis: Optional[WhaleAnalysis] = None
                                            ^
infrastructure\agents\whales\agent.py:65:13: error: Property "status" defined
in "AgentState" is read-only  [misc]
                self.state.status = AgentStatus.HEALTHY
                ^~~~~~~~~~~~~~~~~
infrastructure\agents\whales\agent.py:74:5: error: Return type
"Coroutine[Any, Any, dict[str, Any]]" of "process" incompatible with return type
"Coroutine[Any, Any, ProcessingResult]" in supertype "BaseAgent"  [override]
        async def process(self, data: Any) -> Dict[str, Any]:
        ^
infrastructure\agents\whales\agent.py:103:61: error: TypedDict "AgentConfig"
has no key "impact_threshold"  [typeddict-item]
    ...                   if a.impact_score > self.config["impact_threshold"]
                                                          ^~~~~~~~~~~~~~~~~~
infrastructure\agents\whales\agent.py:142:37: error: TypedDict key must be a
string literal; expected one of ("name", "agent_type", "max_position_size",
"max_portfolio_risk", "max_risk_per_trade", ...)  [literal-required]
                    value = self.config[key]
                                        ^~~
infrastructure\agents\whales\agent.py:153:15: error: Name "WhaleActivity" is
not defined  [name-defined]
        ) -> List[WhaleActivity]:
                  ^
infrastructure\agents\whales\agent.py:160:33: error: Argument 2 to
"analyze_order_book" of "WhaleSignalAnalyzer" has incompatible type
"AgentConfig"; expected "dict[str, Any]"  [arg-type]
                        order_book, self.config
                                    ^~~~~~~~~~~
infrastructure\agents\whales\agent.py:192:45: error: Name "WhaleActivity" is
not defined  [name-defined]
            self, symbol: str, activities: List[WhaleActivity]
                                                ^
infrastructure\agents\whales\agent.py:193:19: error: Name "WhaleAnalysis" is
not defined  [name-defined]
        ) -> Optional[WhaleAnalysis]:
                      ^
infrastructure\agents\whales\agent.py:224:55: error: TypedDict "AgentConfig"
has no key "min_whale_size"  [typeddict-item]
    ...                   if activity.volume >= self.config["min_whale_size"]
                                                            ^~~~~~~~~~~~~~~~
infrastructure\agents\whales\agent.py:227:24: error: Name "WhaleAnalysis" is
not defined  [name-defined]
                analysis = WhaleAnalysis(
                           ^~~~~~~~~~~~~
infrastructure\agents\whales\agent.py:251:19: error: Name "WhaleActivity" is
not defined  [name-defined]
        ) -> Optional[WhaleActivity]:
                      ^
infrastructure\agents\whales\agent.py:270:24: error: Name "WhaleActivity" is
not defined  [name-defined]
                    return WhaleActivity(
                           ^~~~~~~~~~~~~
infrastructure\agents\whales\agent.py:291:19: error: Name "WhaleActivity" is
not defined  [name-defined]
        ) -> Optional[WhaleActivity]:
                      ^
infrastructure\agents\whales\agent.py:307:24: error: Name "WhaleActivity" is
not defined  [name-defined]
                    return WhaleActivity(
                           ^~~~~~~~~~~~~
infrastructure\agents\whales\agent.py:331:19: error: Name "WhaleActivity" is
not defined  [name-defined]
        ) -> Optional[WhaleActivity]:
                      ^
infrastructure\agents\whales\agent.py:347:24: error: Name "WhaleActivity" is
not defined  [name-defined]
                    return WhaleActivity(
                           ^~~~~~~~~~~~~
infrastructure\agents\news\agent_news.py:30:5: error: Name "NewsAgentObserver"
already defined (possibly by an import)  [no-redef]
        class NewsAgentObserver:
        ^
infrastructure\agents\news\agent_news.py:62:20: error: Argument "config" to
"__init__" of "BaseAgent" has incompatible type "dict[str, Any]"; expected
"AgentConfig | None"  [arg-type]
                config=config
                       ^~~~~~
infrastructure\agents\news\agent_news.py:126:43: error: Name "ProcessingResult"
is not defined  [name-defined]
        async def process(self, data: Any) -> "ProcessingResult":
                                              ^
infrastructure\agents\news\agent_news.py:212:37: error: TypedDict key must be a
string literal; expected one of ("name", "agent_type", "max_position_size",
"max_portfolio_risk", "max_risk_per_trade", ...)  [literal-required]
                    value = self.config[key]
                                        ^~~
infrastructure\agents\news\agent_news.py:253:40: error: Missing positional
argument "social_media_agent" in call to "SocialMediaNewsProvider"  [call-arg]
                    self._providers.append(SocialMediaNewsProvider())
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\news\agent_news.py:362:55: error: Unsupported operand
types for > ("float" and "object")  [operator]
    ...                   if float(news.impact_score) > black_swan_threshold:
                                                        ^~~~~~~~~~~~~~~~~~~~
examples\neural_noise_analysis_example.py:58:19: error: "type[Timestamp]" has
no attribute "from_timestamp"  [attr-defined]
            timestamp=Timestamp.from_timestamp(time.time()),
                      ^~~~~~~~~~~~~~~~~~~~~~~~
examples\neural_noise_analysis_example.py:91:19: error: "type[Timestamp]" has
no attribute "from_timestamp"  [attr-defined]
            timestamp=Timestamp.from_timestamp(time.time()),
                      ^~~~~~~~~~~~~~~~~~~~~~~~
examples\market_memory_example.py:19:1: error: Module
"infrastructure.agents.market_memory_integration" has no attribute
"MarketMemoryConfig"  [attr-defined]
    from infrastructure.agents.market_memory_integration import (
    ^
examples\market_memory_example.py:19:1: error: Module
"infrastructure.agents.market_memory_integration" has no attribute
"MarketMemoryIntegration"  [attr-defined]
    from infrastructure.agents.market_memory_integration import (
    ^
examples\market_memory_example.py:174:27: error: Argument "timestamp" to
"PatternSnapshot" has incompatible type "datetime"; expected "Timestamp" 
[arg-type]
                    timestamp=datetime.now(),
                              ^~~~~~~~~~~~~~
examples\market_memory_example.py:196:27: error: Argument "timestamp" to
"PatternOutcome" has incompatible type "datetime"; expected "Timestamp" 
[arg-type]
                    timestamp=datetime.now(),
                              ^~~~~~~~~~~~~~
examples\market_memory_example.py:384:21: error: Module has no attribute
"date_range"  [attr-defined]
                dates = pd.date_range(
                        ^~~~~~~~~~~~~
examples\ddd_usage_examples.py:17:1: error: Module "domain.entities.risk" has
no attribute "RiskLimit"  [attr-defined]
    from domain.entities.risk import RiskLimit, RiskManager, RiskProfile, ...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
examples\ddd_usage_examples.py:32:1: error: Module "shared.exceptions" has no
attribute "TradingError"  [attr-defined]
    from shared.exceptions import InsufficientFundsError, TradingError
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
domain\strategies\strategy_factory.py:97:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_factory.py:98:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_factory.py:101:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
domain\strategies\strategy_factory.py:103:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
application\use_cases\manage_trading_pairs.py:203:30: error: Argument
"trading_pair" to "CreateTradingPairResponse" has incompatible type
"domain.entities.trading_pair.TradingPair"; expected
"domain.types.TradingPair | None"  [arg-type]
                    trading_pair=trading_pair,
                                 ^~~~~~~~~~~~
application\use_cases\manage_trading_pairs.py:236:30: error: Argument
"trading_pair" to "UpdateTradingPairResponse" has incompatible type
"domain.entities.trading_pair.TradingPair"; expected
"domain.types.TradingPair | None"  [arg-type]
                    trading_pair=trading_pair,
                                 ^~~~~~~~~~~~
application\use_cases\manage_trading_pairs.py:283:51: error: Argument 1 to
"append" of "list" has incompatible type "tuple[TradingPair, None]"; expected
"tuple[TradingPair, TradingPairMetrics]"  [arg-type]
                            pairs_with_metrics.append((pair, None))
                                                      ^~~~~~~~~~~~
application\use_cases\manage_trading_pairs.py:288:47: error: Argument 1 to
"append" of "list" has incompatible type "tuple[TradingPair, None]"; expected
"tuple[TradingPair, TradingPairMetrics]"  [arg-type]
                        pairs_with_metrics.append((pair, None))
                                                  ^~~~~~~~~~~~
application\use_cases\manage_trading_pairs.py:290:31: error: Argument
"trading_pairs" to "GetTradingPairsResponse" has incompatible type
"list[domain.entities.trading_pair.TradingPair]"; expected
"list[domain.types.TradingPair]"  [arg-type]
                    trading_pairs=paginated_pairs,
                                  ^~~~~~~~~~~~~~~
application\use_cases\manage_trading_pairs.py:364:26: error: "MarketData" has
no attribute "get_order_book"  [attr-defined]
                order_book = market_data.get_order_book()
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_trading_pairs.py:386:20: error: Unexpected keyword
argument "symbol" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:386:20: error: Unexpected keyword
argument "liquidity_score" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:386:20: error: Unexpected keyword
argument "bid_ask_spread" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:386:20: error: Unexpected keyword
argument "market_depth" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:386:20: error: Unexpected keyword
argument "overall_score" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:386:20: error: Unexpected keyword
argument "last_updated" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:388:28: error: Argument
"volatility" to "TradingPairMetrics" has incompatible type "float"; expected
"Decimal"  [arg-type]
                    volatility=volatility,
                               ^~~~~~~~~~
application\use_cases\manage_trading_pairs.py:389:24: error: Argument "spread"
to "TradingPairMetrics" has incompatible type "float"; expected
"PriceValue | None"  [arg-type]
                    spread=spread,
                           ^~~~~~
application\use_cases\manage_trading_pairs.py:390:28: error: Argument
"volume_24h" to "TradingPairMetrics" has incompatible type "float"; expected
"VolumeValue"  [arg-type]
                    volume_24h=volume_24h,
                               ^~~~~~~~~~
application\use_cases\manage_trading_pairs.py:391:34: error: Argument
"price_change_24h" to "TradingPairMetrics" has incompatible type "float";
expected "PriceValue"  [arg-type]
                    price_change_24h=price_change_24h,
                                     ^~~~~~~~~~~~~~~~
application\use_cases\manage_trading_pairs.py:402:20: error: Unexpected keyword
argument "symbol" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:402:20: error: Unexpected keyword
argument "liquidity_score" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:402:20: error: Unexpected keyword
argument "bid_ask_spread" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:402:20: error: Unexpected keyword
argument "market_depth" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:402:20: error: Unexpected keyword
argument "overall_score" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:402:20: error: Unexpected keyword
argument "last_updated" for "TradingPairMetrics"  [call-arg]
                return TradingPairMetrics(
                       ^
application\use_cases\manage_trading_pairs.py:404:28: error: Argument
"volatility" to "TradingPairMetrics" has incompatible type "float"; expected
"Decimal"  [arg-type]
                    volatility=0.0,
                               ^~~
application\use_cases\manage_trading_pairs.py:405:24: error: Argument "spread"
to "TradingPairMetrics" has incompatible type "float"; expected
"PriceValue | None"  [arg-type]
                    spread=0.0,
                           ^~~
application\use_cases\manage_trading_pairs.py:406:28: error: Argument
"volume_24h" to "TradingPairMetrics" has incompatible type "float"; expected
"VolumeValue"  [arg-type]
                    volume_24h=0.0,
                               ^~~
application\use_cases\manage_trading_pairs.py:407:34: error: Argument
"price_change_24h" to "TradingPairMetrics" has incompatible type "float";
expected "PriceValue"  [arg-type]
                    price_change_24h=0.0,
                                     ^~~
application\use_cases\manage_trading_pairs.py:419:22: error: "MarketData" has
no attribute "get_historical_prices"  [attr-defined]
                prices = market_data.get_historical_prices()
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_trading_pairs.py:448:30: error: Value of type
"OrderBookEntry" is not indexable  [index]
                best_bid = float(order_book.bids[0][0])
                                 ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_trading_pairs.py:449:30: error: Value of type
"OrderBookEntry" is not indexable  [index]
                best_ask = float(order_book.asks[0][0])
                                 ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_trading_pairs.py:474:22: error: "MarketData" has
no attribute "get_historical_prices"  [attr-defined]
                prices = market_data.get_historical_prices()
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:280:42: error: "type[Timestamp]" has no
attribute "now"  [attr-defined]
                    timestamp=TimestampValue(pd.Timestamp.now()),
                                             ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:295:31: error: "PositionRepository" has no
attribute "get_by_portfolio_id"  [attr-defined]
                positions = await self.position_repository.get_by_portfoli...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\manage_risk.py:319:46: error: "type[Timestamp]" has no
attribute "now"  [attr-defined]
                        timestamp=TimestampValue(pd.Timestamp.now()),
                                                 ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:327:46: error: "type[Timestamp]" has no
attribute "now"  [attr-defined]
                        timestamp=TimestampValue(pd.Timestamp.now()),
                                                 ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:337:67: error: "type[Timestamp]" has no
attribute "now"  [attr-defined]
    ... success=True, errors=[], timestamp=TimestampValue(pd.Timestamp.now())
                                                          ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:348:31: error: "PositionRepository" has no
attribute "get_by_portfolio_id"  [attr-defined]
                positions = await self.position_repository.get_by_portfoli...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\manage_risk.py:350:29: error: Missing positional argument
"portfolio_id" in call to "Position"  [call-arg]
                temp_position = Position(
                                ^
application\use_cases\manage_risk.py:351:20: error: Argument "id" to "Position"
has incompatible type "OrderId"; expected "PositionId"  [arg-type]
                    id=order.id,
                       ^~~~~~~~
application\use_cases\manage_risk.py:352:30: error: Argument "trading_pair" to
"Position" has incompatible type "domain.types.TradingPair"; expected
"domain.entities.trading_pair.TradingPair"  [arg-type]
                    trading_pair=order.trading_pair,
                                 ^~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:353:22: error: Argument "side" to
"Position" has incompatible type "OrderSide"; expected "PositionSide" 
[arg-type]
                    side=order.side,
                         ^~~~~~~~~~
application\use_cases\manage_risk.py:354:24: error: Argument "volume" to
"Position" has incompatible type "VolumeValue"; expected "Volume"  [arg-type]
                    volume=order.quantity,
                           ^~~~~~~~~~~~~~
application\use_cases\manage_risk.py:355:29: error: Argument "entry_price" to
"Position" has incompatible type "Price | None"; expected "Price"  [arg-type]
                    entry_price=order.price,
                                ^~~~~~~~~~~
application\use_cases\manage_risk.py:356:31: error: Argument "current_price" to
"Position" has incompatible type "Price | None"; expected "Price"  [arg-type]
                    current_price=order.price,
                                  ^~~~~~~~~~~
application\use_cases\manage_risk.py:357:28: error: "type[Timestamp]" has no
attribute "now"  [attr-defined]
                    created_at=pd.Timestamp.now(),
                               ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:358:28: error: "type[Timestamp]" has no
attribute "now"  [attr-defined]
                    updated_at=pd.Timestamp.now(),
                               ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:438:28: error: "RiskLevel" has no
attribute "value"  [attr-defined]
                    risk_level=risk_level.value,
                               ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:452:31: error: "PositionRepository" has no
attribute "get_by_portfolio_id"  [attr-defined]
                positions = await self.position_repository.get_by_portfoli...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\manage_risk.py:535:30: error: Unsupported operand types
for - ("Series" and "float")  [operator]
                excess_returns = portfolio_returns - risk_free_rate / 252
                                 ^
application\use_cases\manage_risk.py:537:23: error: "float" has no attribute
"mean"  [attr-defined]
                    float(excess_returns.mean() / excess_returns.std() * n...
                          ^~~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:537:47: error: "float" has no attribute
"std"  [attr-defined]
                    float(excess_returns.mean() / excess_returns.std() * n...
                                                  ^~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:538:20: error: "float" has no attribute
"std"  [attr-defined]
                    if excess_returns.std() > 0
                       ^~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:542:34: error: "int" has no attribute
"cumprod"  [attr-defined]
                cumulative_returns = (1 + portfolio_returns).cumprod()
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:542:39: error: Unsupported operand types
for + ("int" and "Series")  [operator]
                cumulative_returns = (1 + portfolio_returns).cumprod()
                                          ^~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:574:16: error: "Portfolio" has no
attribute "risk_limits"  [attr-defined]
                if portfolio.risk_limits:
                   ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:575:47: error: "Portfolio" has no
attribute "risk_limits"  [attr-defined]
                    if portfolio_metrics.var_95 > portfolio.risk_limits.ge...
                                                  ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:579:58: error: "Portfolio" has no
attribute "risk_limits"  [attr-defined]
    ...        if abs(portfolio_metrics.max_drawdown) > portfolio.risk_limits...
                                                        ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:591:41: error: "Portfolio" has no
attribute "risk_limits"  [attr-defined]
                        if position_value > portfolio.risk_limits.get(
                                            ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:628:37: error: "MarketData" has no
attribute "get_historical_prices"  [attr-defined]
                    historical_prices = market_data[symbol].get_historical...
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\manage_risk.py:641:16: error: Incompatible return value
type (got "dict[Symbol, list[float]]", expected "dict[str, list[float]]") 
[return-value]
            return returns_data
                   ^~~~~~~~~~~~
application\use_cases\manage_risk.py:641:16: note: Perhaps you need a type annotation for "returns_data"? Suggestion: "dict[str, list[float]]"
application\use_cases\manage_risk.py:748:50: error: "type[Timestamp]" has no
attribute "now"  [attr-defined]
                            timestamp=TimestampValue(pd.Timestamp.now()),
                                                     ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:757:50: error: "type[Timestamp]" has no
attribute "now"  [attr-defined]
                            timestamp=TimestampValue(pd.Timestamp.now()),
                                                     ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:768:54: error: "type[Timestamp]" has no
attribute "now"  [attr-defined]
    ...                         timestamp=TimestampValue(pd.Timestamp.now()),
                                                         ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:818:30: error: No overload variant of
"percentile" matches argument types "Series", "float"  [call-overload]
                    return float(np.percentile(returns, (1 - confidence_le...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\manage_risk.py:818:30: note: Possible overload variants:
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> floating[Any]
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> complexfloating[Any, Any]
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> timedelta64
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[datetime64]] | _NestedSequence[_SupportsArray[dtype[datetime64]]], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> datetime64
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> Any
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[floating[Any]]]
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[complexfloating[Any, Any]]]
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[timedelta64]]
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[datetime64]] | _NestedSequence[_SupportsArray[dtype[datetime64]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[datetime64]]
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[object_]]
application\use_cases\manage_risk.py:818:30: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: bool = ...) -> Any
application\use_cases\manage_risk.py:818:30: note:     def [_ArrayType: ndarray[Any, dtype[Any]]] percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: _ArrayType = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: bool = ...) -> _ArrayType
application\use_cases\manage_risk.py:836:33: error: No overload variant of
"percentile" matches argument types "Series", "float"  [call-overload]
                    var_threshold = np.percentile(returns, (1 - confidence...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\manage_risk.py:836:33: note: Possible overload variants:
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> floating[Any]
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> complexfloating[Any, Any]
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> timedelta64
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[datetime64]] | _NestedSequence[_SupportsArray[dtype[datetime64]]], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> datetime64
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: bool | bool_ | int | integer[Any] | float | floating[Any], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> Any
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[floating[Any]]]
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[complexfloating[Any, Any]]]
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[timedelta64]]
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[datetime64]] | _NestedSequence[_SupportsArray[dtype[datetime64]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[datetime64]]
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: Literal[False] = ...) -> ndarray[Any, dtype[object_]]
application\use_cases\manage_risk.py:836:33: note:     def percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: None = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: bool = ...) -> Any
application\use_cases\manage_risk.py:836:33: note:     def [_ArrayType: ndarray[Any, dtype[Any]]] percentile(a: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any] | complexfloating[Any, Any]]]] | bool | int | float | complex | _NestedSequence[bool | int | float | complex] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[bool_ | integer[Any] | timedelta64]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | timedelta64]]] | bool | int | _NestedSequence[bool | int] | _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], q: _SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[bool_ | integer[Any] | floating[Any]]]] | bool | int | float | _NestedSequence[bool | int | float], axis: SupportsIndex | Sequence[SupportsIndex] | None = ..., out: _ArrayType = ..., overwrite_input: bool = ..., method: Literal['inverted_cdf', 'averaged_inverted_cdf', 'closest_observation', 'interpolated_inverted_cdf', 'hazen', 'weibull', 'linear', 'median_unbiased', 'normal_unbiased', 'lower', 'higher', 'midpoint', 'nearest'] = ..., keepdims: bool = ...) -> _ArrayType
application\use_cases\manage_risk.py:856:30: error: "Series" has no attribute
"cov"  [attr-defined]
                    covariance = asset_returns.cov(market_returns)
                                 ^~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:857:35: error: "Series" has no attribute
"var"  [attr-defined]
                    market_variance = market_returns.var()
                                      ^~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:878:30: error: "Series" has no attribute
"corr"  [attr-defined]
                    return float(returns1.corr(returns2))
                                 ^~~~~~~~~~~~~
application\use_cases\manage_risk.py:916:24: error: Incompatible return value
type (got "str", expected "RiskLevel")  [return-value]
                    return RiskLevel.HIGH
                           ^~~~~~~~~~~~~~
application\use_cases\manage_risk.py:918:24: error: Incompatible return value
type (got "str", expected "RiskLevel")  [return-value]
                    return RiskLevel.MEDIUM
                           ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:920:24: error: Incompatible return value
type (got "str", expected "RiskLevel")  [return-value]
                    return RiskLevel.LOW
                           ^~~~~~~~~~~~~
application\use_cases\manage_risk.py:923:20: error: Incompatible return value
type (got "str", expected "RiskLevel")  [return-value]
                return RiskLevel.MEDIUM
                       ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:939:24: error: Incompatible return value
type (got "str", expected "RiskLevel")  [return-value]
                    return RiskLevel.HIGH
                           ^~~~~~~~~~~~~~
application\use_cases\manage_risk.py:941:24: error: Incompatible return value
type (got "str", expected "RiskLevel")  [return-value]
                    return RiskLevel.MEDIUM
                           ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:943:24: error: Incompatible return value
type (got "str", expected "RiskLevel")  [return-value]
                    return RiskLevel.LOW
                           ^~~~~~~~~~~~~
application\use_cases\manage_risk.py:946:20: error: Incompatible return value
type (got "str", expected "RiskLevel")  [return-value]
                return RiskLevel.MEDIUM
                       ^~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:955:16: error:
"dict[str, float | Decimal | str]" has no attribute "var_95"  [attr-defined]
                if risk_assessment.portfolio_risk.var_95 > request.max_var...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:957:21: error:
"dict[str, float | Decimal | str]" has no attribute "var_95"  [attr-defined]
                        f"Current VaR 95% ({risk_assessment.portfolio_risk...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\manage_risk.py:959:20: error:
"dict[str, float | Decimal | str]" has no attribute "max_drawdown" 
[attr-defined]
                if abs(risk_assessment.portfolio_risk.max_drawdown) > requ...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_risk.py:961:21: error:
"dict[str, float | Decimal | str]" has no attribute "max_drawdown" 
[attr-defined]
                        f"Current max drawdown ({risk_assessment.portfolio...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\manage_positions.py:9:1: error: Module
"application.types" has no attribute "PositionManagementUseCase"  [attr-defined]
    from application.types import (
    ^
application\use_cases\manage_positions.py:26:1: error: Module "domain.types"
has no attribute "OrderSide"  [attr-defined]
    from domain.types import (
    ^
application\use_cases\manage_positions.py:26:1: error: Module "domain.types"
has no attribute "PositionStatus"  [attr-defined]
    from domain.types import (
    ^
application\use_cases\manage_positions.py:52:27: error: Name "OrderRepository"
is not defined  [name-defined]
            order_repository: OrderRepository,
                              ^
application\use_cases\manage_positions.py:76:20: error: Missing positional
argument "item" in call to "PositionId"  [call-arg]
                    id=PositionId(),
                       ^~~~~~~~~~~~
application\use_cases\manage_positions.py:78:30: error: Argument "trading_pair"
to "Position" has incompatible type "domain.types.TradingPair"; expected
"domain.entities.trading_pair.TradingPair"  [arg-type]
                    trading_pair=request.trading_pair,
                                 ^~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:79:22: error: Argument "side" to
"Position" has incompatible type "OrderSide"; expected "PositionSide" 
[arg-type]
                    side=request.side,
                         ^~~~~~~~~~~~
application\use_cases\manage_positions.py:86:19: error: "PositionRepository"
has no attribute "create"  [attr-defined]
                await self.position_repository.create(position)
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:116:16: error: "Position" has no
attribute "portfolio_id"  [attr-defined]
                if position.portfolio_id != request.portfolio_id:
                   ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:125:17: error: "Position" has no
attribute "update_price"  [attr-defined]
                    position.update_price(request.price)
                    ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:126:44: error: Incompatible types in
assignment (expression has type "Price", target has type "Volume")  [assignment]
                    changes["current_price"] = request.price
                                               ^~~~~~~~~~~~~
application\use_cases\manage_positions.py:130:26: error: Argument "position" to
"UpdatePositionResponse" has incompatible type
"domain.entities.trading.Position"; expected
"domain.entities.position.Position | None"  [arg-type]
                    position=position,
                             ^~~~~~~~
application\use_cases\manage_positions.py:131:25: error: Argument "changes" to
"UpdatePositionResponse" has incompatible type "dict[str, Volume]"; expected
"dict[str, str | float | int | bool]"  [arg-type]
                    changes=changes,
                            ^~~~~~~
application\use_cases\manage_positions.py:158:16: error: "Position" has no
attribute "portfolio_id"  [attr-defined]
                if position.portfolio_id != request.portfolio_id:
                   ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:220:20: error: Unexpected keyword
argument "total_value" for "GetPositionsResponse"  [call-arg]
                return GetPositionsResponse(
                       ^
application\use_cases\manage_positions.py:229:20: error: Unexpected keyword
argument "total_value" for "GetPositionsResponse"  [call-arg]
                return GetPositionsResponse(
                       ^
application\use_cases\manage_positions.py:252:29: error: "Position" has no
attribute "portfolio_id"  [attr-defined]
                if position and position.portfolio_id == portfolio_id:
                                ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:253:24: error: Incompatible return
value type (got "domain.entities.trading.Position", expected
"domain.entities.position.Position | None")  [return-value]
                    return position
                           ^~~~~~~~
application\use_cases\manage_positions.py:282:20: error: Unexpected keyword
argument "position_value" for "PositionMetrics"; did you mean "notional_value"? 
[call-arg]
                return PositionMetrics(
                       ^
application\use_cases\manage_positions.py:282:20: error: Unexpected keyword
argument "entry_value" for "PositionMetrics"  [call-arg]
                return PositionMetrics(
                       ^
application\use_cases\manage_positions.py:310:17: error: "Trade" has no
attribute "portfolio_id"  [attr-defined]
                    trade.portfolio_id, trade.trading_pair
                    ^~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:310:37: error: Argument 2 to
"get_by_trading_pair" of "PositionRepository" has incompatible type
"TradingPair"; expected "bool"  [arg-type]
                    trade.portfolio_id, trade.trading_pair
                                        ^~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:315:24: error: Incompatible return
value type (got "bool", expected "Position | None")  [return-value]
                    return await self.update_position_from_trade(trade)
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:318:24: error: Unexpected keyword
argument "quantity" for "Position"  [call-arg]
                position = Position(
                           ^
application\use_cases\manage_positions.py:319:20: error: Missing positional
argument "item" in call to "PositionId"  [call-arg]
                    id=PositionId(),
                       ^~~~~~~~~~~~
application\use_cases\manage_positions.py:320:30: error: "Trade" has no
attribute "portfolio_id"  [attr-defined]
                    portfolio_id=trade.portfolio_id,
                                 ^~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:321:30: error: Argument
"trading_pair" to "Position" has incompatible type "domain.types.TradingPair";
expected "domain.entities.trading_pair.TradingPair"  [arg-type]
                    trading_pair=trade.trading_pair,
                                 ^~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:322:22: error: Argument "side" to
"Position" has incompatible type "OrderSide"; expected "PositionSide" 
[arg-type]
                    side=trade.side,
                         ^~~~~~~~~~
application\use_cases\manage_positions.py:330:19: error: "PositionRepository"
has no attribute "create"  [attr-defined]
                await self.position_repository.create(position)
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:347:17: error: "Trade" has no
attribute "portfolio_id"  [attr-defined]
                    trade.portfolio_id, trade.trading_pair
                    ^~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:347:37: error: Argument 2 to
"get_by_trading_pair" of "PositionRepository" has incompatible type
"TradingPair"; expected "bool"  [arg-type]
                    trade.portfolio_id, trade.trading_pair
                                        ^~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:356:32: error: "list[Position]" has
no attribute "quantity"  [attr-defined]
                    new_quantity = position.quantity.amount + trade.quanti...
                                   ^~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:359:22: error: "list[Position]" has
no attribute "quantity"  [attr-defined]
                        (position.quantity.amount * position.entry_price.a...
                         ^~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:359:49: error: "list[Position]" has
no attribute "entry_price"  [attr-defined]
                        (position.quantity.amount * position.entry_price.a...
                                                    ^~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:362:17: error: "list[Position]" has
no attribute "quantity"  [attr-defined]
                    position.quantity = Volume(new_quantity, Currency.USDT...
                    ^~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:363:17: error: "list[Position]" has
no attribute "entry_price"  [attr-defined]
                    position.entry_price = Price(new_entry_price, Currency...
                    ^~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:366:32: error: "list[Position]" has
no attribute "quantity"  [attr-defined]
                    new_quantity = position.quantity.amount - trade.quanti...
                                   ^~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:369:21: error: "list[Position]" has
no attribute "quantity"  [attr-defined]
                        position.quantity = Volume(Decimal("0"), Currency....
                        ^~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:371:21: error: "list[Position]" has
no attribute "quantity"  [attr-defined]
                        position.quantity = Volume(new_quantity, Currency....
                        ^~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:373:13: error: "list[Position]" has
no attribute "current_price"  [attr-defined]
                position.current_price = trade.price
                ^~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:374:13: error: "list[Position]" has
no attribute "updated_at"  [attr-defined]
                position.updated_at = Timestamp.now()
                ^~~~~~~~~~~~~~~~~~~
application\use_cases\manage_positions.py:376:51: error: Argument 1 to "update"
of "PositionRepository" has incompatible type "list[Position]"; expected
"Position"  [arg-type]
                await self.position_repository.update(position)
                                                      ^~~~~~~~
application\use_cases\manage_orders.py:37:37: error: Name
"OrderManagementUseCase" is not defined  [name-defined]
    class DefaultOrderManagementUseCase(OrderManagementUseCase):
                                        ^~~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_orders.py:44:30: error: Name "PositionRepository"
is not defined  [name-defined]
            position_repository: PositionRepository,
                                 ^
application\use_cases\manage_orders.py:74:26: error: Argument "quantity" to
"Order" has incompatible type "Volume"; expected "VolumeValue"  [arg-type]
                    quantity=request.volume,
                             ^~~~~~~~~~~~~~
application\use_cases\manage_orders.py:75:29: error: Argument 1 to "Price" has
incompatible type "Price"; expected "Decimal"  [arg-type]
                    price=Price(request.price, Currency.USD) if request.pr...
                                ^~~~~~~~~~~~~
application\use_cases\manage_orders.py:94:25: error: "TradingPair" has no
attribute "symbol"  [attr-defined]
                            f"Insufficient position size for {request.trad...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\manage_orders.py:121:59: error: Argument 1 to "get_by_id"
of "OrderRepository" has incompatible type "OrderId"; expected "EntityId" 
[arg-type]
    ...       order = await self.order_repository.get_by_id(request.order_id)
                                                            ^~~~~~~~~~~~~~~~
application\use_cases\manage_orders.py:147:35: error: Argument
"cancellation_time" to "CancelOrderResponse" has incompatible type "Timestamp";
expected "TimestampValue | None"  [arg-type]
                    cancellation_time=Timestamp.now(),
                                      ^~~~~~~~~~~~~~~
application\use_cases\manage_orders.py:196:17: error: Generator has
incompatible item type "Any | Decimal"; expected "bool"  [misc]
                    (order.quantity.amount * order.price.amount) if order....
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\manage_orders.py:196:18: error: "VolumeValue" has no
attribute "amount"  [attr-defined]
                    (order.quantity.amount * order.price.amount) if order....
                     ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\manage_orders.py:228:59: error: Argument 1 to "get_by_id"
of "OrderRepository" has incompatible type "OrderId"; expected "EntityId" 
[arg-type]
                order = await self.order_repository.get_by_id(order_id)
                                                              ^~~~~~~~
application\use_cases\manage_orders.py:252:59: error: Argument 1 to "get_by_id"
of "OrderRepository" has incompatible type "OrderId"; expected "EntityId" 
[arg-type]
                order = await self.order_repository.get_by_id(order_id)
                                                              ^~~~~~~~
application\services\technical_analysis_service.py:14:1: error: Name
"TechnicalAnalysisService" already defined (possibly by an import)  [no-redef]
    class TechnicalAnalysisService:
    ^
application\services\technical_analysis_service.py:55:18: error: Name "pd" is
not defined  [name-defined]
                df = pd.DataFrame(df_data)
                     ^~
application\services\technical_analysis_service.py:63:42: error:
"TechnicalIndicator" has no attribute "values"; maybe "value"?  [attr-defined]
                    result[indicator_name] = indicator_data.values
                                             ^~~~~~~~~~~~~~~~~~~~~
application\services\ml_service.py:56:55: error: Argument 1 to "get_model" of
"MLRepository" has incompatible type "str"; expected "EntityId"  [arg-type]
                return await self.ml_repository.get_model(model_id)
                                                          ^~~~~~~~
application\services\ml_service.py:138:51: error: Argument 1 to "delete_model"
of "MLRepository" has incompatible type "str"; expected "EntityId"  [arg-type]
                await self.ml_repository.delete_model(model_id)
                                                      ^~~~~~~~
application\services\ml_service.py:144:45: error: Name "pd" is not defined 
[name-defined]
            self, model_id: str, training_data: pd.DataFrame, target_data:...
                                                ^
application\services\ml_service.py:180:28: error: Name "np" is not defined 
[name-defined]
                    accuracy = np.mean(y_pred.round() == y)
                               ^~
application\services\ml_service.py:229:17: error: Name "np" is not defined 
[name-defined]
                X = np.array([feature_values])
                    ^~
application\services\ml_service.py:245:21: error: Name "np" is not defined 
[name-defined]
                        np.std(predictions) / (abs(prediction_value) + 1e-...
                        ^~
application\services\ml_service.py:266:41: error: Name "pd" is not defined 
[name-defined]
            self, model_id: str, test_data: pd.DataFrame, test_target: pd....
                                            ^
application\services\ml_service.py:301:28: error: Name "np" is not defined 
[name-defined]
                    accuracy = np.mean(y_pred.round() == y)
                               ^~
application\services\ml_service.py:363:70: error: Argument 1 to
"get_predictions_by_model" of "MLRepository" has incompatible type "str";
expected "EntityId"  [arg-type]
    ...urn await self.ml_repository.get_predictions_by_model(model_id, limit)
                                                             ^~~~~~~~
application\services\market_data_service.py:39:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error getting market data: {str(e)}"...
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:48:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error saving market data: {str(e)}")
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:57:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error saving market data batch: {str...
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:64:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error getting market state: {str(e)}...
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:73:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error updating market state: {str(e)...
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:80:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error getting available symbols: {st...
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:87:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error getting available timeframes: ...
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:119:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error getting price history: {str(e)...
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:131:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error getting real-time price: {str(...
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:144:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error getting market depth: {str(e)}...
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:152:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error subscribing to updates: {str(e...
                      ^~~~~~~~~~~~~
application\services\market_data_service.py:164:19: error: Name "ExchangeError"
is not defined  [name-defined]
                raise ExchangeError(f"Error cleaning up old data: {str(e)}...
                      ^~~~~~~~~~~~~
application\services\market_analysis_service.py:18:47: error: Name
"DomainMarketAnalysisService" is not defined  [name-defined]
            self.domain_market_analysis_service = DomainMarketAnalysisServ...
                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:63:15: error: Call
to abstract method "initialize" of "BaseApplicationService" with trivial body
via super() is unsafe  [safe-super]
            await super().initialize()
                  ^~~~~~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:98:13: error:
Unsupported operand types for + ("object" and "int")  [operator]
                self._trading_stats["total_orders"] += 1
                ^
application\services\implementations\trading_service_impl.py:103:13: error:
Unsupported operand types for + ("object" and "int")  [operator]
                self._trading_stats["failed_orders"] += 1
                ^
application\services\implementations\trading_service_impl.py:127:29: error:
"TradingRepository" has no attribute "cancel_order"  [attr-defined]
                success = await self.trading_repository.cancel_order(order...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:158:61: error:
Argument 1 to "get_order" of "TradingRepository" has incompatible type
"OrderId"; expected "EntityId"  [arg-type]
                order = await self.trading_repository.get_order(order_id)
                                                                ^~~~~~~~
application\services\implementations\trading_service_impl.py:181:55: error:
Argument 1 to "_is_balance_cache_expired" of "TradingServiceImpl" has
incompatible type "Money"; expected "dict[str, Money]"  [arg-type]
                    if not self._is_balance_cache_expired(cached_balance):
                                                          ^~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:182:28: error:
Incompatible return value type (got "Money", expected "dict[str, Money]") 
[return-value]
                        return cached_balance
                               ^~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:184:29: error:
"TradingRepository" has no attribute "get_account_balance"  [attr-defined]
                balance = await self.trading_repository.get_account_balanc...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:192:5: error:
Return type "Coroutine[Any, Any, list[domain.entities.trading.Trade]]" of
"get_trade_history" incompatible with return type
"Coroutine[Any, Any, list[domain.entities.trade.Trade]]" in supertype
"TradingService"  [override]
        async def get_trade_history(self, symbol: Symbol, limit: int = 100...
        ^
application\services\implementations\trading_service_impl.py:204:28: error:
"TradingRepository" has no attribute "get_trade_history"  [attr-defined]
                trades = await self.trading_repository.get_trade_history(s...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:226:28: error:
"TradingRepository" has no attribute "get_open_orders"  [attr-defined]
                orders = await self.trading_repository.get_open_orders(sym...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:271:55: error:
Unsupported operand types for * ("VolumeAmount" and "float")  [operator]
    ...               order_cost = order.amount.value * 1.0  # ”прощенна€ лог...
                                                        ^~~
application\services\implementations\trading_service_impl.py:296:29: error:
"TradingRepository" has no attribute "execute_order"; maybe "delete_order"? 
[attr-defined]
                success = await self.trading_repository.execute_order(orde...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:300:36: error:
Incompatible types in assignment (expression has type "datetime", variable has
type "Timestamp")  [assignment]
                    order.updated_at = datetime.now()
                                       ^~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:304:17: error:
Unsupported operand types for + ("object" and "int")  [operator]
                    self._trading_stats["successful_orders"] += 1
                    ^
application\services\implementations\trading_service_impl.py:305:17: error:
Unsupported operand types for + ("object" and "VolumeAmount")  [operator]
                    self._trading_stats["total_volume"] += order.amount.va...
                    ^
application\services\implementations\trading_service_impl.py:311:21: error:
Unsupported operand types for * ("object" and "int")  [operator]
                        current_avg * (total_orders - 1) + execution_time
                        ^
application\services\implementations\trading_service_impl.py:311:36: error:
Unsupported operand types for - ("object" and "int")  [operator]
                        current_avg * (total_orders - 1) + execution_time
                                       ^
application\services\implementations\trading_service_impl.py:312:21: error:
Unsupported operand types for / ("float" and "object")  [operator]
                    ) / total_orders
                        ^~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:317:23: error:
"SignalService" has no attribute "process_order_execution"  [attr-defined]
                    await self.signal_service.process_order_execution(orde...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:320:32: error:
"type[OrderStatus]" has no attribute "FAILED"  [attr-defined]
                    order.status = OrderStatus.FAILED
                                   ^~~~~~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:321:36: error:
Incompatible types in assignment (expression has type "datetime", variable has
type "Timestamp")  [assignment]
                    order.updated_at = datetime.now()
                                       ^~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:325:17: error:
Unsupported operand types for + ("object" and "int")  [operator]
                    self._trading_stats["failed_orders"] += 1
                    ^
application\services\implementations\trading_service_impl.py:329:13: error:
Unsupported operand types for + ("object" and "int")  [operator]
                self._trading_stats["failed_orders"] += 1
                ^
application\services\implementations\trading_service_impl.py:333:22: error: No
overload variant of "__sub__" of "datetime" matches argument type "Timestamp" 
[operator]
            cache_age = (datetime.now() - order.updated_at).total_seconds(...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\trading_service_impl.py:333:22: note: Possible overload variants:
application\services\implementations\trading_service_impl.py:333:22: note:     def __sub__(self, datetime, /) -> timedelta
application\services\implementations\trading_service_impl.py:333:22: note:     def __sub__(self, timedelta, /) -> datetime
application\services\implementations\trading_service_impl.py:353:17: error:
Unsupported left operand type for / ("object")  [operator]
                    self._trading_stats["successful_orders"]
                    ^
application\services\implementations\trading_service_impl.py:355:20: error:
Unsupported operand types for < ("int" and "object")  [operator]
                    if self._trading_stats["total_orders"] > 0
                       ^
application\services\implementations\trading_service_impl.py:358:35: error:
Argument 1 to "float" has incompatible type "object"; expected
"str | Buffer | SupportsFloat | SupportsIndex"  [arg-type]
                "total_volume": float(self._trading_stats["total_volume"])...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\risk_service_impl.py:33:15: error: Call to
abstract method "initialize" of "BaseApplicationService" with trivial body via
super() is unsafe  [safe-super]
            await super().initialize()
                  ^~~~~~~~~~~~~~~~~~
application\services\implementations\risk_service_impl.py:47:5: error: Return
type "Coroutine[Any, Any, application.types.RiskMetrics]" of
"assess_portfolio_risk" incompatible with return type
"Coroutine[Any, Any, domain.types.RiskMetrics]" in supertype "RiskService" 
[override]
        async def assess_portfolio_risk(self, portfolio_id: PortfolioId) -...
        ^
application\services\implementations\risk_service_impl.py:59:39: error:
Incompatible types in assignment (expression has type
"domain.entities.risk.RiskMetrics", target has type
"application.types.RiskMetrics")  [assignment]
            self._risk_cache[cache_key] = risk_metrics
                                          ^~~~~~~~~~~~
application\services\implementations\risk_service_impl.py:60:16: error:
Incompatible return value type (got "domain.entities.risk.RiskMetrics", expected
"application.types.RiskMetrics")  [return-value]
            return risk_metrics
                   ^~~~~~~~~~~~
application\services\implementations\risk_service_impl.py:73:18: error:
"RiskMetrics" has no attribute "portfolio_var_99"; maybe "portfolio_var_95",
"portfolio_cvar_95", or "portfolio_value"?  [attr-defined]
                else risk_metrics.portfolio_var_99
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\risk_service_impl.py:85:42: error:
Argument 2 of "validate_risk_limits" is incompatible with supertype
"RiskService"; supertype defines the argument type as "CreateOrderRequest" 
[override]
            self, portfolio_id: PortfolioId, order_request: CreateOrderReq...
                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\risk_service_impl.py:85:42: note: This violates the Liskov substitution principle
application\services\implementations\risk_service_impl.py:85:42: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
application\services\implementations\risk_service_impl.py:107:64: error:
Argument 1 to "validate_risk_limits" of "RiskAnalysisService" has incompatible
type "application.types.RiskMetrics"; expected
"domain.entities.risk.RiskMetrics"  [arg-type]
    ... self.risk_analysis_service.validate_risk_limits(risk_metrics, limits)
                                                        ^~~~~~~~~~~~
application\services\implementations\risk_service_impl.py:107:78: error:
Argument 2 to "validate_risk_limits" of "RiskAnalysisService" has incompatible
type "dict[str, Any]"; expected "RiskLimits"  [arg-type]
    ... self.risk_analysis_service.validate_risk_limits(risk_metrics, limits)
                                                                      ^~~~~~
application\services\implementations\risk_service_impl.py:112:16: error:
"RiskAnalysisService" has no attribute "get_risk_alerts"  [attr-defined]
            return self.risk_analysis_service.get_risk_alerts(risk_metrics...
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\risk_service_impl.py:116:39: error:
"RiskMetrics" has no attribute "last_updated"  [attr-defined]
            cache_age = (datetime.now() - risk_metrics.last_updated).total...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:59:15: error:
Call to abstract method "initialize" of "BaseApplicationService" with trivial
body via super() is unsafe  [safe-super]
            await super().initialize()
                  ^~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:94:31: error:
"PortfolioRepository" has no attribute "get_portfolio_positions"  [attr-defined]
                positions = await self.portfolio_repository.get_portfolio_...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:165:31: error:
"PortfolioRepository" has no attribute "get_portfolio_positions"  [attr-defined]
                positions = await self.portfolio_repository.get_portfolio_...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:177:40: error:
Argument 2 to "Money" has incompatible type "str"; expected
"Currency | CurrencyCode"  [arg-type]
                return Money(Decimal("0"), "USDT")
                                           ^~~~~~
application\services\implementations\portfolio_service_impl.py:179:5: error:
Return type "Coroutine[Any, Any, application.types.PortfolioMetrics]" of
"get_portfolio_metrics" incompatible with return type
"Coroutine[Any, Any, application.protocols.service_protocols.PortfolioMetrics]"
in supertype "PortfolioService"  [override]
        async def get_portfolio_metrics(
        ^
application\services\implementations\portfolio_service_impl.py:203:31: error:
"PortfolioRepository" has no attribute "get_portfolio_positions"  [attr-defined]
                positions = await self.portfolio_repository.get_portfolio_...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:207:40: error:
"PortfolioRepository" has no attribute "get_portfolio_returns"; maybe
"get_portfolio"?  [attr-defined]
                historical_returns = await self.portfolio_repository.get_p...
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:224:23: error:
Unexpected keyword argument "portfolio_id" for "PortfolioMetrics"  [call-arg]
                metrics = PortfolioMetrics(
                          ^
application\services\implementations\portfolio_service_impl.py:224:23: error:
Unexpected keyword argument "position_count" for "PortfolioMetrics"  [call-arg]
                metrics = PortfolioMetrics(
                          ^
application\services\implementations\portfolio_service_impl.py:224:23: error:
Unexpected keyword argument "volatility" for "PortfolioMetrics"  [call-arg]
                metrics = PortfolioMetrics(
                          ^
application\services\implementations\portfolio_service_impl.py:224:23: error:
Unexpected keyword argument "last_updated" for "PortfolioMetrics"  [call-arg]
                metrics = PortfolioMetrics(
                          ^
application\services\implementations\portfolio_service_impl.py:224:23: error:
Unexpected keyword argument "metadata" for "PortfolioMetrics"  [call-arg]
                metrics = PortfolioMetrics(
                          ^
application\services\implementations\portfolio_service_impl.py:226:48: error:
Argument 2 to "Money" has incompatible type "str"; expected
"Currency | CurrencyCode"  [arg-type]
                    total_value=Money(total_value, "USDT"),
                                                   ^~~~~~
application\services\implementations\portfolio_service_impl.py:227:44: error:
Argument 2 to "Money" has incompatible type "str"; expected
"Currency | CurrencyCode"  [arg-type]
                    total_pnl=Money(total_pnl, "USDT"),
                                               ^~~~~~
application\services\implementations\portfolio_service_impl.py:235:43: error:
"Portfolio" has no attribute "strategies"  [attr-defined]
                        "strategy_count": len(portfolio.strategies),
                                              ^~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:268:29: error:
"PortfolioRepository" has no attribute "get_portfolio_balance"; maybe
"get_portfolio" or "get_portfolio_by_account"?  [attr-defined]
                balance = await self.portfolio_repository.get_portfolio_ba...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:297:29: error:
"PortfolioRepository" has no attribute "update_portfolio_balance"; maybe
"update_portfolio"?  [attr-defined]
                success = await self.portfolio_repository.update_portfolio...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:318:5: error:
Return type "Coroutine[Any, Any, application.types.PerformanceMetrics]" of
"get_portfolio_performance" incompatible with return type
"Coroutine[Any, Any, application.protocols.service_protocols.PerformanceMetrics]"
in supertype "PortfolioService"  [override]
        async def get_portfolio_performance(
        ^
application\services\implementations\portfolio_service_impl.py:341:37: error:
"PortfolioRepository" has no attribute "get_portfolio_history"; maybe
"get_portfolio"?  [attr-defined]
                historical_data = await self.portfolio_repository.get_port...
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:346:24: error:
Unexpected keyword argument "period" for "PerformanceMetrics"  [call-arg]
                    return PerformanceMetrics(
                           ^
application\services\implementations\portfolio_service_impl.py:346:24: error:
Unexpected keyword argument "daily_return" for "PerformanceMetrics"  [call-arg]
                    return PerformanceMetrics(
                           ^
application\services\implementations\portfolio_service_impl.py:346:24: error:
Unexpected keyword argument "total_trades" for "PerformanceMetrics"  [call-arg]
                    return PerformanceMetrics(
                           ^
application\services\implementations\portfolio_service_impl.py:349:34: error:
Argument "total_return" to "PerformanceMetrics" has incompatible type "Decimal";
expected "Percentage"  [arg-type]
                        total_return=Decimal("0"),
                                     ^~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:357:31: error:
Argument "timestamp" to "PerformanceMetrics" has incompatible type "datetime";
expected "TimestampValue"  [arg-type]
                        timestamp=datetime.now(),
                                  ^~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:373:42: error:
Argument 2 of "validate_portfolio_constraints" is incompatible with supertype
"PortfolioService"; supertype defines the argument type as "CreateOrderRequest" 
[override]
            self, portfolio_id: PortfolioId, order_request: CreateOrderReq...
                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:373:42: note: This violates the Liskov substitution principle
application\services\implementations\portfolio_service_impl.py:373:42: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
application\services\implementations\portfolio_service_impl.py:394:16: error:
"Portfolio" has no attribute "risk_limits"  [attr-defined]
                if portfolio.risk_limits:
                   ^~~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:396:37: error:
"Portfolio" has no attribute "risk_limits"  [attr-defined]
                    max_position_size = portfolio.risk_limits.get("max_pos...
                                        ^~~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:397:42: error:
"CreateOrderRequest" has no attribute "amount"  [attr-defined]
                    if max_position_size and order_request.amount.value > ...
                                             ^~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:399:41: error:
"CreateOrderRequest" has no attribute "amount"  [attr-defined]
                            f"Order amount {order_request.amount.value} ex...
                                            ^~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:402:37: error:
"Portfolio" has no attribute "risk_limits"  [attr-defined]
                    max_concentration = portfolio.risk_limits.get("max_con...
                                        ^~~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:406:25: error:
"CreateOrderRequest" has no attribute "symbol"  [attr-defined]
                            order_request.symbol, Decimal("0")
                            ^~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:410:29: error:
"CreateOrderRequest" has no attribute "symbol"  [attr-defined]
                                f"Symbol {order_request.symbol} concentrat...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:415:17: error:
"CreateOrderRequest" has no attribute "symbol"  [attr-defined]
                    order_request.symbol.split("/")[-1]
                    ^~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:416:31: error:
"CreateOrderRequest" has no attribute "symbol"  [attr-defined]
                    if "/" in str(order_request.symbol)
                                  ^~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:421:35: error:
"CreateOrderRequest" has no attribute "amount"  [attr-defined]
                    required_amount = order_request.amount.value
                                      ^~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:451:71: error:
Argument 1 to "get_portfolio" of "PortfolioRepository" has incompatible type
"PortfolioId"; expected "EntityId"  [arg-type]
    ...ortfolio = await self.portfolio_repository.get_portfolio(portfolio_id)
                                                                ^~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:454:52: error:
Incompatible types in assignment (expression has type
"domain.entities.portfolio_fixed.Portfolio", target has type
"domain.entities.portfolio.Portfolio")  [assignment]
                    self._portfolio_cache[cache_key] = portfolio
                                                       ^~~~~~~~~
application\services\implementations\portfolio_service_impl.py:455:20: error:
Incompatible return value type (got
"domain.entities.portfolio_fixed.Portfolio | None", expected
"domain.entities.portfolio.Portfolio | None")  [return-value]
                return portfolio
                       ^~~~~~~~~
application\services\implementations\portfolio_service_impl.py:509:40: error:
"PortfolioRepository" has no attribute "get_portfolio_returns"; maybe
"get_portfolio"?  [attr-defined]
                historical_returns = await self.portfolio_repository.get_p...
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:527:40: error:
"PortfolioRepository" has no attribute "get_portfolio_returns"; maybe
"get_portfolio"?  [attr-defined]
                historical_returns = await self.portfolio_repository.get_p...
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:545:40: error:
"PortfolioRepository" has no attribute "get_portfolio_returns"; maybe
"get_portfolio"?  [attr-defined]
                historical_returns = await self.portfolio_repository.get_p...
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:565:24: error:
Unexpected keyword argument "period" for "PerformanceMetrics"  [call-arg]
                    return PerformanceMetrics(
                           ^
application\services\implementations\portfolio_service_impl.py:565:24: error:
Unexpected keyword argument "daily_return" for "PerformanceMetrics"  [call-arg]
                    return PerformanceMetrics(
                           ^
application\services\implementations\portfolio_service_impl.py:565:24: error:
Unexpected keyword argument "total_trades" for "PerformanceMetrics"  [call-arg]
                    return PerformanceMetrics(
                           ^
application\services\implementations\portfolio_service_impl.py:566:46: error:
Argument 1 to "PortfolioId" has incompatible type "str"; expected "UUID" 
[arg-type]
                        portfolio_id=PortfolioId(""),
                                                 ^~
application\services\implementations\portfolio_service_impl.py:568:34: error:
Argument "total_return" to "PerformanceMetrics" has incompatible type "Decimal";
expected "Percentage"  [arg-type]
                        total_return=Decimal("0"),
                                     ^~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:576:31: error:
Argument "timestamp" to "PerformanceMetrics" has incompatible type "datetime";
expected "TimestampValue"  [arg-type]
                        timestamp=datetime.now(),
                                  ^~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:623:20: error:
Unexpected keyword argument "period" for "PerformanceMetrics"  [call-arg]
                return PerformanceMetrics(
                       ^
application\services\implementations\portfolio_service_impl.py:623:20: error:
Unexpected keyword argument "daily_return" for "PerformanceMetrics"  [call-arg]
                return PerformanceMetrics(
                       ^
application\services\implementations\portfolio_service_impl.py:623:20: error:
Unexpected keyword argument "total_trades" for "PerformanceMetrics"  [call-arg]
                return PerformanceMetrics(
                       ^
application\services\implementations\portfolio_service_impl.py:624:42: error:
Argument 1 to "PortfolioId" has incompatible type "str"; expected "UUID" 
[arg-type]
                    portfolio_id=PortfolioId(""),
                                             ^~
application\services\implementations\portfolio_service_impl.py:626:30: error:
Argument "total_return" to "PerformanceMetrics" has incompatible type
"Any | Decimal"; expected "Percentage"  [arg-type]
                    total_return=total_return,
                                 ^~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:634:27: error:
Argument "timestamp" to "PerformanceMetrics" has incompatible type "datetime";
expected "TimestampValue"  [arg-type]
                    timestamp=datetime.now(),
                              ^~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:643:32: error:
"PortfolioRepository" has no attribute "get_all_portfolios"; maybe
"get_portfolio" or "get_all_positions"?  [attr-defined]
                portfolios = await self.portfolio_repository.get_all_portf...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\portfolio_service_impl.py:653:22: error:
No overload variant of "__sub__" of "datetime" matches argument type "Timestamp"
 [operator]
            cache_age = (datetime.now() - portfolio.updated_at).total_seco...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:653:22: note: Possible overload variants:
application\services\implementations\portfolio_service_impl.py:653:22: note:     def __sub__(self, datetime, /) -> timedelta
application\services\implementations\portfolio_service_impl.py:653:22: note:     def __sub__(self, timedelta, /) -> datetime
application\services\implementations\portfolio_service_impl.py:658:39: error:
"PortfolioMetrics" has no attribute "last_updated"  [attr-defined]
            cache_age = (datetime.now() - metrics.last_updated).total_seco...
                                          ^~~~~~~~~~~~~~~~~~~~
application\services\implementations\portfolio_service_impl.py:687:36: error:
"PortfolioRepository" has no attribute "get_active_portfolios"; maybe
"get_portfolio"?  [attr-defined]
                    portfolios = await self.portfolio_repository.get_activ...
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\ml_service_impl.py:50:15: error: Call to
abstract method "initialize" of "BaseApplicationService" with trivial body via
super() is unsafe  [safe-super]
            await super().initialize()
                  ^~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:70:5: error: Return
type "Coroutine[Any, Any, application.types.MLPrediction | None]" of
"predict_price" incompatible with return type
"Coroutine[Any, Any, application.protocols.service_protocols.MLPrediction | None]"
in supertype "MLService"  [override]
        async def predict_price(
        ^
application\services\implementations\ml_service_impl.py:97:35: error:
"MLPredictor" has no attribute "predict"  [attr-defined]
            prediction_result = await self.ml_predictor.predict(model, pre...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:108:26: error: Argument
"metadata" to "MLPrediction" has incompatible type "dict[str, Any]"; expected
"MetadataDict"  [arg-type]
                    metadata={
                             ^
application\services\implementations\ml_service_impl.py:141:34: error:
"MLPredictor" has no attribute "analyze_sentiment"  [attr-defined]
            sentiment_result = await self.ml_predictor.analyze_sentiment(t...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:172:5: error: Return
type "Coroutine[Any, Any, list[application.types.PatternDetection]]" of
"detect_patterns" incompatible with return type
"Coroutine[Any, Any, list[application.protocols.service_protocols.PatternDetection]]"
in supertype "MLService"  [override]
        async def detect_patterns(self, market_data: MarketData) -> List[P...
        ^
application\services\implementations\ml_service_impl.py:188:26: error:
"MLPredictor" has no attribute "detect_patterns"  [attr-defined]
            patterns = await self.ml_predictor.detect_patterns(pattern_mod...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:200:26: error: Argument
"metadata" to "PatternDetection" has incompatible type "dict[str, Any]";
expected "MetadataDict"  [arg-type]
                    metadata={
                             ^
application\services\implementations\ml_service_impl.py:227:30: error:
"MLPredictor" has no attribute "calculate_risk_metrics"  [attr-defined]
            risk_metrics = await self.ml_predictor.calculate_risk_metrics(
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:258:56: error: Argument
1 to "get_model" of "MLRepository" has incompatible type "str"; expected
"EntityId"  [arg-type]
                model = await self.ml_repository.get_model(model_id)
                                                           ^~~~~~~~
application\services\implementations\ml_service_impl.py:263:37: error:
"MLPredictor" has no attribute "train_model"; maybe "train_models"? 
[attr-defined]
                training_result = await self.ml_predictor.train_model(mode...
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:266:34: error:
Unsupported operand types for + ("str" and "int")  [operator]
                    model.version += 1
                                     ^
application\services\implementations\ml_service_impl.py:267:17: error: "Model"
has no attribute "last_trained"  [attr-defined]
                    model.last_trained = datetime.now()
                    ^~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:268:17: error: "Model"
has no attribute "training_metrics"  [attr-defined]
                    model.training_metrics = training_result.metrics
                    ^~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:269:23: error:
"MLRepository" has no attribute "update_model"  [attr-defined]
                    await self.ml_repository.update_model(model)
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:297:56: error: Argument
1 to "get_model" of "MLRepository" has incompatible type "str"; expected
"EntityId"  [arg-type]
                model = await self.ml_repository.get_model(model_id)
                                                           ^~~~~~~~
application\services\implementations\ml_service_impl.py:301:39: error:
"MLPredictor" has no attribute "evaluate_model"  [attr-defined]
                evaluation_result = await self.ml_predictor.evaluate_model...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:331:37: error: "Model"
has no attribute "model_id"  [attr-defined]
                    self._active_models[model.model_id] = model
                                        ^~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:332:34: error: "Model"
has no attribute "model_id"  [attr-defined]
                    self.logger.info(f"Loaded model: {model.model_id} (v{m...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\ml_service_impl.py:397:39: error:
"TimestampValue" has no attribute "value"  [attr-defined]
            cache_age = (datetime.now() - prediction.timestamp.value).tota...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:49:15: error: Call
to abstract method "initialize" of "BaseApplicationService" with trivial body
via super() is unsafe  [safe-super]
            await super().initialize()
                  ^~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:79:29: error:
Missing positional argument "timeframe" in call to "get_market_data" of
"MarketRepository"  [call-arg]
            market_data = await self.market_repository.get_market_data(sym...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\market_service_impl.py:82:51: error:
Incompatible types in assignment (expression has type "list[MarketData]", target
has type "MarketData")  [assignment]
                self._market_data_cache[symbol_str] = market_data
                                                      ^~~~~~~~~~~
application\services\implementations\market_service_impl.py:84:16: error:
Incompatible return value type (got "list[MarketData]", expected
"MarketData | None")  [return-value]
            return market_data
                   ^~~~~~~~~~~
application\services\implementations\market_service_impl.py:112:33: error:
"MarketRepository" has no attribute "get_historical_data"  [attr-defined]
            historical_data = await self.market_repository.get_historical_...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\market_service_impl.py:143:43: error:
"Price" has no attribute "timestamp"  [attr-defined]
                if not self._is_cache_expired(cached_price.timestamp):
                                              ^~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:147:28: error:
"MarketData" has no attribute "current_price"  [attr-defined]
            if market_data and market_data.current_price:
                               ^~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:149:45: error:
"MarketData" has no attribute "current_price"  [attr-defined]
                self._price_cache[symbol_str] = market_data.current_price
                                                ^~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:151:20: error:
"MarketData" has no attribute "current_price"  [attr-defined]
                return market_data.current_price
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:171:43: error:
Argument 1 to "_is_cache_expired" of "MarketServiceImpl" has incompatible type
"Any | None"; expected "TimestampValue"  [arg-type]
                if not self._is_cache_expired(cached_orderbook.get("timest...
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\market_service_impl.py:174:27: error:
"MarketRepository" has no attribute "get_order_book"  [attr-defined]
            orderbook = await self.market_repository.get_order_book(symbol...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:218:25: error:
"MarketMetricsService" has no attribute "calculate_metrics"; maybe
"calculate_trend_metrics", "calculate_volume_metrics", or
"calculate_momentum_metrics"?  [attr-defined]
            metrics = await self.market_metrics_service.calculate_metrics(...
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:259:5: error:
Return type "Coroutine[Any, Any, application.types.MarketAnalysis]" of
"analyze_market" incompatible with return type
"Coroutine[Any, Any, application.protocols.service_protocols.MarketAnalysis]" in
supertype "MarketService"  [override]
        async def analyze_market(self, symbol: Symbol) -> MarketAnalysis:
        ^
application\services\implementations\market_service_impl.py:274:26: error:
"TechnicalAnalysisService" has no attribute "analyze_market"; maybe
"analyze_market_data"?  [attr-defined]
            analysis = await self.technical_analysis_service.analyze_marke...
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:289:5: error:
Return type "Coroutine[Any, Any, application.types.TechnicalIndicators]" of
"get_technical_indicators" incompatible with return type
"Coroutine[Any, Any, application.protocols.service_protocols.TechnicalIndicators]"
in supertype "MarketService"  [override]
        async def get_technical_indicators(self, symbol: Symbol) -> Techni...
        ^
application\services\implementations\market_service_impl.py:304:28: error:
"TechnicalAnalysisService" has no attribute "calculate_indicators"; maybe
"calculate_atr"?  [attr-defined]
            indicators = await self.technical_analysis_service.calculate_i...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\implementations\market_service_impl.py:328:39: error:
"TimestampValue" has no attribute "value"  [attr-defined]
            cache_age = (datetime.now() - timestamp.value).total_seconds()
                                          ^~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:337:31: error:
"TimestampValue" has no attribute "value"  [attr-defined]
                    key=lambda k: self._market_data_cache[k].timestamp.val...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:369:39: error:
"MarketData" has no attribute "current_price"  [attr-defined]
                                    float(market_data.current_price.value)
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:370:36: error:
"MarketData" has no attribute "current_price"  [attr-defined]
                                    if market_data.current_price
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:379:39: error:
"MarketData" has no attribute "price_change_24h"  [attr-defined]
                                    float(market_data.price_change_24h.val...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:380:36: error:
"MarketData" has no attribute "price_change_24h"  [attr-defined]
                                    if market_data.price_change_24h
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\implementations\market_service_impl.py:455:5: error: Name
"validate_input" already defined on line 408  [no-redef]
        def validate_input(self, data: Any) -> bool:
        ^
application\services\implementations\market_service_impl.py:466:5: error: Name
"process" already defined on line 419  [no-redef]
        def process(self, data: Any) -> Any:
        ^
application\services\implementations\market_service_impl.py:476:5: error: Name
"_process_market_data" already defined on line 429  [no-redef]
        def _process_market_data(self, data: Dict[str, Any]) -> Dict[str, ...
        ^
application\services\implementations\market_service_impl.py:497:5: error: Name
"_process_symbol" already defined on line 450  [no-redef]
        def _process_symbol(self, symbol: str) -> str:
        ^
application\services\implementations\cache_service_impl.py:45:15: error: Call
to abstract method "initialize" of "BaseApplicationService" with trivial body
via super() is unsafe  [safe-super]
            await super().initialize()
                  ^~~~~~~~~~~~~~~~~~
tests\unit\test_evolution_agents_unit.py:10:1: error: Module
"infrastructure.agents.evolvable_portfolio_agent" has no attribute "PortfolioML"
 [attr-defined]
    from infrastructure.agents.evolvable_portfolio_agent import EvolvableP...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_evolution_agents_unit.py:14:1: error: Module
"infrastructure.agents.evolvable_order_executor" has no attribute
"OrderExecutionML"  [attr-defined]
    from infrastructure.agents.evolvable_order_executor import EvolvableOr...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_evolution_agents_unit.py:15:1: error: Module
"infrastructure.agents.evolvable_meta_controller" has no attribute
"MetaControllerML"  [attr-defined]
    from infrastructure.agents.evolvable_meta_controller import EvolvableM...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\application_tests\test_use_cases.py:8:1: error: Module
"application.use_cases.manage_orders" has no attribute "OrderManagementUseCase";
maybe "DefaultOrderManagementUseCase"?  [attr-defined]
    from application.use_cases.manage_orders import (
    ^
tests\unit\application_tests\test_services.py:14:1: error: Module
"application.types" has no attribute "OrderResponse"  [attr-defined]
    from application.types import (
    ^
tests\unit\application_tests\test_services.py:14:1: error: Module
"application.types" has no attribute "StrategyConfig"  [attr-defined]
    from application.types import (
    ^
tests\unit\application_tests\test_services.py:14:1: error: Module
"application.types" has no attribute "PortfolioConfig"  [attr-defined]
    from application.types import (
    ^
tests\unit\application_tests\test_services.py:25:1: error: Module
"application.services.implementations.notification_service_impl" has no
attribute "NotificationServiceImpl"  [attr-defined]
    from application.services.implementations.notification_service_impl im...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\test_trading_flow.py:11:1: error: Module
"application.use_cases.manage_orders" has no attribute "ManageOrdersUseCase" 
[attr-defined]
    from application.use_cases.manage_orders import ManageOrdersUseCase
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_trading_flow.py:12:1: error: Module
"application.use_cases.manage_positions" has no attribute
"ManagePositionsUseCase"  [attr-defined]
    from application.use_cases.manage_positions import ManagePositionsUseC...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_trading_flow.py:13:1: error: Module
"application.use_cases.manage_risk" has no attribute "ManageRiskUseCase" 
[attr-defined]
    from application.use_cases.manage_risk import ManageRiskUseCase
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_trading_cycle.py:11:1: error: Module
"domain.entities.trading" has no attribute "Order"; maybe "OrderId"? 
[attr-defined]
    from domain.entities.trading import Signal, SignalType, Order, OrderSi...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\test_trading_cycle.py:15:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\test_trading_cycle.py:16:1: error: Module
"application.use_cases.manage_orders" has no attribute "ExecuteStrategyRequest" 
[attr-defined]
    from application.use_cases.manage_orders import ExecuteStrategyRequest...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\test_trading_cycle.py:16:1: error: Module
"application.use_cases.manage_orders" has no attribute "ExecuteStrategyResponse"
 [attr-defined]
    from application.use_cases.manage_orders import ExecuteStrategyRequest...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\application\test_application_integration.py:51:27: error: Too
many arguments for "DefaultTradingService"  [call-arg]
            trading_service = DefaultTradingService(order_repo, position_r...
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\application\test_application_integration.py:62:63: error:
Argument 2 to "Money" has incompatible type "str"; expected
"Currency | CurrencyCode"  [arg-type]
            portfolio.available_balance = Money(Decimal("10000"), "USD")
                                                                  ^~~~~
tests\integration\application\test_application_integration.py:66:29: error:
Name "OrderStatus" is not defined  [name-defined]
            mock_order.status = OrderStatus.PENDING
                                ^~~~~~~~~~~
tests\integration\application\test_application_integration.py:71:26: error:
Unexpected keyword argument "symbol" for "CreateOrderRequest"  [call-arg]
            create_request = CreateOrderRequest(
                             ^
tests\integration\application\test_application_integration.py:71:26: error:
Unexpected keyword argument "amount" for "CreateOrderRequest"  [call-arg]
            create_request = CreateOrderRequest(
                             ^
tests\integration\application\test_application_integration.py:72:26: error:
Argument "portfolio_id" to "CreateOrderRequest" has incompatible type "UUID";
expected "PortfolioId"  [arg-type]
                portfolio_id=portfolio_id,
                             ^~~~~~~~~~~~
tests\integration\application\test_application_integration.py:74:24: error:
Name "OrderType" is not defined  [name-defined]
                order_type=OrderType.LIMIT,
                           ^~~~~~~~~
tests\integration\application\test_application_integration.py:75:18: error:
Name "OrderSide" is not defined  [name-defined]
                side=OrderSide.BUY,
                     ^~~~~~~~~
tests\integration\application\test_application_integration.py:76:43: error:
Argument 2 to "Volume" has incompatible type "str"; expected "Currency | None" 
[arg-type]
                amount=Volume(Decimal("0.1"), "BTC"),
                                              ^~~~~
tests\integration\application\test_application_integration.py:77:43: error:
Argument 2 to "Price" has incompatible type "str"; expected "Currency" 
[arg-type]
                price=Price(Decimal("50000"), "USD", "BTC")
                                              ^~~~~
tests\integration\application\test_application_integration.py:77:50: error:
Argument 3 to "Price" has incompatible type "str"; expected "Currency | None" 
[arg-type]
                price=Price(Decimal("50000"), "USD", "BTC")
                                                     ^~~~~
tests\integration\application\test_application_integration.py:95:89: error:
Argument 3 to "get_market_data" of "MarketDataService" has incompatible type
"int"; expected "datetime | None"  [arg-type]
    ...sult = await market_data_service.get_market_data("BTC/USD", "1h", 100)
                                                                         ^~~
tests\integration\application\test_application_integration.py:97:39: error:
"MarketDataService" has no attribute "get_market_summary"; maybe
"get_market_state"?  [attr-defined]
            market_summary_result = await market_data_service.get_market_s...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\application\test_application_integration.py:100:32: error:
Unexpected keyword argument "executed_price" for "execute_order" of
"DefaultTradingService"; did you mean "execution_price"?  [call-arg]
            execute_result = await trading_service.execute_order(
                                   ^
tests\integration\application\test_application_integration.py:194:43: error:
Name "OrderStatus" is not defined  [name-defined]
                Mock(symbol="BTC/USD", status=OrderStatus.FILLED),
                                              ^~~~~~~~~~~
tests\integration\application\test_application_integration.py:195:43: error:
Name "OrderStatus" is not defined  [name-defined]
                Mock(symbol="ETH/USD", status=OrderStatus.PENDING)
                                              ^~~~~~~~~~~
tests\integration\application\test_application_integration.py:225:24: error:
Name "OrderType" is not defined  [name-defined]
                order_type=OrderType.LIMIT,
                           ^~~~~~~~~
tests\integration\application\test_application_integration.py:226:18: error:
Name "OrderSide" is not defined  [name-defined]
                side=OrderSide.BUY,
                     ^~~~~~~~~
tests\integration\application\test_application_integration.py:265:29: error:
Name "OrderStatus" is not defined  [name-defined]
            mock_order.status = OrderStatus.PENDING
                                ^~~~~~~~~~~
tests\integration\application\test_application_integration.py:279:24: error:
Name "OrderType" is not defined  [name-defined]
                order_type=OrderType.LIMIT,
                           ^~~~~~~~~
tests\integration\application\test_application_integration.py:280:18: error:
Name "OrderSide" is not defined  [name-defined]
                side=OrderSide.BUY,
                     ^~~~~~~~~
tests\integration\application\test_application_integration.py:290:20: error:
Name "OrderStatus" is not defined  [name-defined]
                status=OrderStatus.PENDING
                       ^~~~~~~~~~~
tests\integration\application\test_application_integration.py:311:43: error:
Name "OrderStatus" is not defined  [name-defined]
                Mock(symbol="BTC/USD", status=OrderStatus.FILLED, realized...
                                              ^~~~~~~~~~~
tests\integration\application\test_application_integration.py:312:43: error:
Name "OrderStatus" is not defined  [name-defined]
                Mock(symbol="ETH/USD", status=OrderStatus.FILLED, realized...
                                              ^~~~~~~~~~~
tests\integration\application\test_application_integration.py:313:43: error:
Name "OrderStatus" is not defined  [name-defined]
                Mock(symbol="ADA/USD", status=OrderStatus.FILLED, realized...
                                              ^~~~~~~~~~~
application\services\trading_service.py:278:5: note: "execute_order" of "DefaultTradingService" defined here
tests\integration\application\test_application_integration.py:100:32: error:
Unexpected keyword argument "executed_quantity" for "execute_order" of
"DefaultTradingService"; did you mean "execution_quantity"?  [call-arg]
            execute_result = await trading_service.execute_order(
                                   ^
application\services\trading_service.py:278:5: note: "execute_order" of "DefaultTradingService" defined here
tests\integration\application\test_application_integration.py:105:16: error:
Value of type "Trade" is not indexable  [index]
            assert execute_result["success"] is True
                   ^~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:106:16: error:
Value of type "Trade" is not indexable  [index]
            assert execute_result["order_id"] == order_id
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:109:22: error:
Argument "order_id" to "CancelOrderRequest" has incompatible type "UUID";
expected "OrderId"  [arg-type]
                order_id=order_id,
                         ^~~~~~~~
tests\integration\application\test_application_integration.py:110:26: error:
Argument "portfolio_id" to "CancelOrderRequest" has incompatible type "UUID";
expected "PortfolioId"  [arg-type]
                portfolio_id=portfolio_id
                             ^~~~~~~~~~~~
tests\integration\application\test_application_integration.py:159:84: error:
Argument 3 to "get_market_data" of "MarketDataService" has incompatible type
"int"; expected "datetime | None"  [arg-type]
    ...lt = await market_data_service.get_market_data(symbol, timeframe, 100)
                                                                         ^~~
tests\integration\application\test_application_integration.py:162:32: error:
"MarketDataService" has no attribute "get_market_summary"; maybe
"get_market_state"?  [attr-defined]
            summary_result = await market_data_service.get_market_summary(...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:165:32: error:
"MarketDataService" has no attribute "get_volume_profile"  [attr-defined]
            profile_result = await market_data_service.get_volume_profile(...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:168:31: error:
"MarketDataService" has no attribute "get_market_regime_analysis" 
[attr-defined]
            regime_result = await market_data_service.get_market_regime_an...
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\application\test_application_integration.py:180:67: error:
Too many values to unpack (4 expected, 5 provided)  [misc]
    ..._repo, position_repo, portfolio_repo, session_repo = mock_repositories
                                                            ^~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:185:63: error:
Argument 2 to "Money" has incompatible type "str"; expected
"Currency | CurrencyCode"  [arg-type]
            portfolio.available_balance = Money(Decimal("10000"), "USD")
                                                                  ^~~~~
tests\integration\application\test_application_integration.py:199:32: error:
"DefaultTradingService" has no attribute "create_trading_session"; maybe
"start_trading_session" or "end_trading_session"?  [attr-defined]
            session_result = await trading_service.create_trading_session(...
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:203:31: error:
"DefaultTradingService" has no attribute "get_orders"; maybe "get_order"? 
[attr-defined]
            orders_result = await trading_service.get_orders(portfolio_id)
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:208:16: error:
Value of type "TradingSession" is not indexable  [index]
            assert end_result["success"] is True
                   ^~~~~~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:209:16: error:
Value of type "TradingSession" is not indexable  [index]
            assert end_result["session_id"] == session_id
                   ^~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:222:26: error:
Unexpected keyword argument "symbol" for "CreateOrderRequest"  [call-arg]
            create_request = CreateOrderRequest(
                             ^
tests\integration\application\test_application_integration.py:222:26: error:
Unexpected keyword argument "amount" for "CreateOrderRequest"  [call-arg]
            create_request = CreateOrderRequest(
                             ^
tests\integration\application\test_application_integration.py:223:26: error:
Argument "portfolio_id" to "CreateOrderRequest" has incompatible type "UUID";
expected "PortfolioId"  [arg-type]
                portfolio_id=uuid4(),
                             ^~~~~~~
tests\integration\application\test_application_integration.py:227:43: error:
Argument 2 to "Volume" has incompatible type "str"; expected "Currency | None" 
[arg-type]
                amount=Volume(Decimal("0.1"), "BTC"),
                                              ^~~~~
tests\integration\application\test_application_integration.py:228:43: error:
Argument 2 to "Price" has incompatible type "str"; expected "Currency" 
[arg-type]
                price=Price(Decimal("50000"), "USD", "BTC")
                                              ^~~~~
tests\integration\application\test_application_integration.py:228:50: error:
Argument 3 to "Price" has incompatible type "str"; expected "Currency | None" 
[arg-type]
                price=Price(Decimal("50000"), "USD", "BTC")
                                                     ^~~~~
tests\integration\application\test_application_integration.py:235:66: error:
Argument 2 to "Money" has incompatible type "str"; expected
"Currency | CurrencyCode"  [arg-type]
    ...       poor_portfolio.available_balance = Money(Decimal("100"), "USD")
                                                                       ^~~~~
tests\integration\application\test_application_integration.py:243:22: error:
Argument "order_id" to "CancelOrderRequest" has incompatible type "UUID";
expected "OrderId"  [arg-type]
                order_id=uuid4(),
                         ^~~~~~~
tests\integration\application\test_application_integration.py:244:26: error:
Argument "portfolio_id" to "CancelOrderRequest" has incompatible type "UUID";
expected "PortfolioId"  [arg-type]
                portfolio_id=uuid4()
                             ^~~~~~~
tests\integration\application\test_application_integration.py:259:63: error:
Argument 2 to "Money" has incompatible type "str"; expected
"Currency | CurrencyCode"  [arg-type]
            portfolio.available_balance = Money(Decimal("10000"), "USD")
                                                                  ^~~~~
tests\integration\application\test_application_integration.py:276:26: error:
Unexpected keyword argument "symbol" for "CreateOrderRequest"  [call-arg]
            create_request = CreateOrderRequest(
                             ^
tests\integration\application\test_application_integration.py:276:26: error:
Unexpected keyword argument "amount" for "CreateOrderRequest"  [call-arg]
            create_request = CreateOrderRequest(
                             ^
tests\integration\application\test_application_integration.py:277:26: error:
Argument "portfolio_id" to "CreateOrderRequest" has incompatible type "UUID";
expected "PortfolioId"  [arg-type]
                portfolio_id=portfolio_id,
                             ^~~~~~~~~~~~
tests\integration\application\test_application_integration.py:281:43: error:
Argument 2 to "Volume" has incompatible type "str"; expected "Currency | None" 
[arg-type]
                amount=Volume(Decimal("0.1"), "BTC"),
                                              ^~~~~
tests\integration\application\test_application_integration.py:282:43: error:
Argument 2 to "Price" has incompatible type "str"; expected "Currency" 
[arg-type]
                price=Price(Decimal("50000"), "USD", "BTC")
                                              ^~~~~
tests\integration\application\test_application_integration.py:282:50: error:
Argument 3 to "Price" has incompatible type "str"; expected "Currency | None" 
[arg-type]
                price=Price(Decimal("50000"), "USD", "BTC")
                                                     ^~~~~
tests\integration\application\test_application_integration.py:287:23: error:
Unexpected keyword argument "symbol" for "GetOrdersRequest"  [call-arg]
            get_request = GetOrdersRequest(
                          ^
tests\integration\application\test_application_integration.py:288:26: error:
Argument "portfolio_id" to "GetOrdersRequest" has incompatible type "UUID";
expected "PortfolioId"  [arg-type]
                portfolio_id=portfolio_id,
                             ^~~~~~~~~~~~
tests\integration\application\test_application_integration.py:297:36: error:
"MarketDataService" has no attribute "get_market_summary"; maybe
"get_market_state"?  [attr-defined]
            market_data_result = await market_data_service.get_market_summ...
                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:308:64: error:
Argument 2 to "Money" has incompatible type "str"; expected
"Currency | CurrencyCode"  [arg-type]
            portfolio.available_balance = Money(Decimal("100000"), "USD")
                                                                   ^~~~~
tests\integration\application\test_application_integration.py:317:30: error:
"DefaultTradingService" has no attribute "calculate_trading_statistics"; maybe
"get_trading_statistics"?  [attr-defined]
            stats_result = await trading_service.calculate_trading_statist...
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\application\test_application_integration.py:329:29: error:
"DefaultTradingService" has no attribute "calculate_risk_metrics" 
[attr-defined]
            risk_result = await trading_service.calculate_risk_metrics(por...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\infrastructure\repositories\test_postgres_repositories.py:18:1: error:
Module "domain.entities.market" has no attribute "MarketDepth"; maybe
"MarketData"?  [attr-defined]
    from domain.entities.market import MarketData, MarketDepth
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\e2e\test_complete_trading_session.py:11:1: error: Module
"application.use_cases.manage_orders" has no attribute "ManageOrdersUseCase" 
[attr-defined]
    from application.use_cases.manage_orders import ManageOrdersUseCase
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\e2e\test_complete_trading_session.py:12:1: error: Module
"application.use_cases.manage_positions" has no attribute
"ManagePositionsUseCase"  [attr-defined]
    from application.use_cases.manage_positions import ManagePositionsUseC...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\e2e\test_complete_trading_session.py:13:1: error: Module
"application.use_cases.manage_risk" has no attribute "ManageRiskUseCase" 
[attr-defined]
    from application.use_cases.manage_risk import ManageRiskUseCase
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\e2e\test_complete_trading_session.py:362:23: error: "Position" has no
attribute "average_price"  [attr-defined]
            entry_price = position.average_price.value
                          ^~~~~~~~~~~~~~~~~~~~~~
tests\e2e\test_complete_trading_session.py:367:23: error: "Position" has no
attribute "average_price"  [attr-defined]
            entry_price = position.average_price.value
                          ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:59:5: error:
Return type "StrategyAnalysis" of "analyze" incompatible with return type
"dict[str, Any]" in supertype "BaseStrategy"  [override]
        def analyze(self, data: pd.DataFrame) -> StrategyAnalysis:
        ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:59:29: error:
Name "pd" is not defined  [name-defined]
        def analyze(self, data: pd.DataFrame) -> StrategyAnalysis:
                                ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:98:27: error:
Name "pd" is not defined  [name-defined]
                    timestamp=pd.Timestamp.now(),
                              ^~
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:119:5: error:
Return type "domain.types.strategy_types.Signal | None" of "generate_signal"
incompatible with return type
"infrastructure.strategies.base_strategy.Signal | None" in supertype
"BaseStrategy"  [override]
        def generate_signal(self, data: pd.DataFrame) -> Optional[Signal]:
        ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:119:37: error:
Name "pd" is not defined  [name-defined]
        def generate_signal(self, data: pd.DataFrame) -> Optional[Signal]:
                                        ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:155:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime, ml_predictions...
                        ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:158:9: error:
Need type annotation for "signals" (hint: "signals: list[<type>] = ...") 
[var-annotated]
            signals = []
            ^~~~~~~
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:179:36: error:
Name "pd" is not defined  [name-defined]
            self, strategy: str, data: pd.DataFrame
                                       ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:219:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime, ml_predictions...
                        ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:243:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime, ml_predictions...
                        ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:260:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime
                        ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:272:15: error:
Name "pd" is not defined  [name-defined]
            data: pd.DataFrame,
                  ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:299:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime, ml_predictions...
                        ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:317:21: error:
Name "pd" is not defined  [name-defined]
            self, data: pd.DataFrame, regime: MarketRegime, ml_predictions...
                        ^
infrastructure\strategies\adaptive\adaptive_strategy_generator.py:354:43: error:
Name "pd" is not defined  [name-defined]
        def _calculate_indicators(self, data: pd.DataFrame) -> Dict[str, p...
                                              ^
infrastructure\core\evolution_integration.py:14:1: error: Module
"infrastructure.agents.evolvable_components" has no attribute
"EvolvableMarketMakerAgent"  [attr-defined]
    from infrastructure.agents.evolvable_components import (
    ^
infrastructure\core\evolution_integration.py:14:1: error: Module
"infrastructure.agents.evolvable_components" has no attribute
"EvolvableMarketRegimeAgent"  [attr-defined]
    from infrastructure.agents.evolvable_components import (
    ^
infrastructure\core\evolution_integration.py:14:1: error: Module
"infrastructure.agents.evolvable_components" has no attribute
"EvolvableMetaController"  [attr-defined]
    from infrastructure.agents.evolvable_components import (
    ^
infrastructure\core\evolution_integration.py:14:1: error: Module
"infrastructure.agents.evolvable_components" has no attribute
"EvolvableNewsAgent"  [attr-defined]
    from infrastructure.agents.evolvable_components import (
    ^
infrastructure\core\evolution_integration.py:14:1: error: Module
"infrastructure.agents.evolvable_components" has no attribute
"EvolvableOrderExecutor"  [attr-defined]
    from infrastructure.agents.evolvable_components import (
    ^
infrastructure\core\evolution_integration.py:14:1: error: Module
"infrastructure.agents.evolvable_components" has no attribute
"EvolvablePortfolioAgent"  [attr-defined]
    from infrastructure.agents.evolvable_components import (
    ^
infrastructure\core\evolution_integration.py:14:1: error: Module
"infrastructure.agents.evolvable_components" has no attribute
"EvolvableRiskAgent"  [attr-defined]
    from infrastructure.agents.evolvable_components import (
    ^
infrastructure\core\evolution_integration.py:14:1: error: Module
"infrastructure.agents.evolvable_components" has no attribute
"EvolvableStrategyAgent"  [attr-defined]
    from infrastructure.agents.evolvable_components import (
    ^
infrastructure\core\evolution_integration.py:42:32: error: Name
"EvolutionConfig" is not defined  [name-defined]
        def __init__(self, config: EvolutionConfig = None):
                                   ^
infrastructure\core\evolution_integration.py:48:33: error: Name
"EvolutionConfig" is not defined  [name-defined]
            self.config = config or EvolutionConfig()
                                    ^~~~~~~~~~~~~~~
infrastructure\core\evolution_integration.py:55:36: error: Missing positional
argument "storage" in call to "EvolutionMigration"  [call-arg]
            self.evolution_migration = EvolutionMigration()
                                       ^~~~~~~~~~~~~~~~~~~~
infrastructure\core\evolution_integration.py:57:34: error: Unexpected keyword
argument "min_accuracy_threshold" for "EvolutionContext"  [call-arg]
            self.evolution_context = EvolutionContext(
                                     ^
infrastructure\core\evolution_integration.py:57:34: error: Unexpected keyword
argument "min_profitability_threshold" for "EvolutionContext"; did you mean
"min_profitability"?  [call-arg]
            self.evolution_context = EvolutionContext(
                                     ^
infrastructure\core\evolution_integration.py:57:34: error: Unexpected keyword
argument "max_drawdown_threshold" for "EvolutionContext"  [call-arg]
            self.evolution_context = EvolutionContext(
                                     ^
infrastructure\core\evolution_integration.py:57:34: error: Unexpected keyword
argument "min_sharpe_threshold" for "EvolutionContext"  [call-arg]
            self.evolution_context = EvolutionContext(
                                     ^
infrastructure\core\evolution_integration.py:60:27: error: Argument
"mutation_rate" to "EvolutionContext" has incompatible type "float"; expected
"Decimal"  [arg-type]
                mutation_rate=0.1,
                              ^~~
infrastructure\core\evolution_integration.py:61:28: error: Argument
"crossover_rate" to "EvolutionContext" has incompatible type "float"; expected
"Decimal"  [arg-type]
                crossover_rate=0.8,
                               ^~~
infrastructure\core\evolution_integration.py:71:33: error: Argument
"strategy_repository" to "EvolutionOrchestrator" has incompatible type "None";
expected "StrategyRepositoryProtocol"  [arg-type]
                strategy_repository=None,  # Ѕудет установлен позже
                                    ^~~~
infrastructure\core\evolution_integration.py:190:38: error: Name
"evolution_manager" is not defined  [name-defined]
                    "evolution_manager": evolution_manager.get_system_heal...
                                         ^~~~~~~~~~~~~~~~~
infrastructure\core\evolution_integration.py:245:21: error: Name "pd" is not
defined  [name-defined]
                dates = pd.date_range(start=start_date, end=end_date, freq...
                        ^~
infrastructure\core\evolution_integration.py:246:20: error: Name "pd" is not
defined  [name-defined]
                data = pd.DataFrame(
                       ^~
domain\strategies\examples.py:332:47: error: Argument 1 to "RiskLevel" has
incompatible type "float"; expected "Decimal"  [arg-type]
                risk_level: RiskLevel = RiskLevel(0.5),
                                                  ^~~
domain\strategies\examples.py:333:69: error: Argument 1 to "ConfidenceLevel"
has incompatible type "float"; expected "Decimal"  [arg-type]
    ...         confidence_threshold: ConfidenceLevel = ConfidenceLevel(0.6),
                                                                        ^~~
domain\strategies\examples.py:363:20: error: "CustomStrategy" has no attribute
"strategy_type"; maybe "get_strategy_type"?  [attr-defined]
                return self.strategy_type
                       ^~~~~~~~~~~~~~~~~~
domain\strategies\examples.py:366:20: error: "CustomStrategy" has no attribute
"parameters"; maybe "get_parameters"?  [attr-defined]
                return self.parameters
                       ^~~~~~~~~~~~~~~
domain\strategies\examples.py:368:38: error: Name "StrategyPerformance" is not
defined  [name-defined]
            def get_performance(self) -> "StrategyPerformance":
                                         ^
application\symbol_selection\analytics.py:97:21: error: Module has no attribute
"date_range"  [attr-defined]
                dates = pd.date_range(start="2024-01-01", periods=100, fre...
                        ^~~~~~~~~~~~~
application\services\service_factory.py:22:1: error: Module
"application.services.implementations.notification_service_impl" has no
attribute "NotificationServiceImpl"  [attr-defined]
    from application.services.implementations.notification_service_impl im...
    ^
application\services\service_factory.py:112:52: error: Missing positional
arguments "technical_analysis_service", "market_metrics_service" in call to
"MarketServiceImpl"  [call-arg]
    ...          self._service_instances[service_key] = MarketServiceImpl(ser...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
application\services\service_factory.py:112:70: error: Argument 1 to
"MarketServiceImpl" has incompatible type "dict[str, Any]"; expected
"MarketRepository"  [arg-type]
    ...lf._service_instances[service_key] = MarketServiceImpl(service_config)
                                                              ^~~~~~~~~~~~~~
application\services\service_factory.py:126:52: error: Missing positional
argument "ml_predictor" in call to "MLServiceImpl"  [call-arg]
    ...          self._service_instances[service_key] = MLServiceImpl(service...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
application\services\service_factory.py:126:66: error: Argument 1 to
"MLServiceImpl" has incompatible type "dict[str, Any]"; expected "MLRepository" 
[arg-type]
    ...  self._service_instances[service_key] = MLServiceImpl(service_config)
                                                              ^~~~~~~~~~~~~~
application\services\service_factory.py:142:52: error: Missing positional
argument "signal_service" in call to "TradingServiceImpl"  [call-arg]
    ...          self._service_instances[service_key] = TradingServiceImpl(se...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
application\services\service_factory.py:142:71: error: Argument 1 to
"TradingServiceImpl" has incompatible type "dict[str, Any]"; expected
"TradingRepository"  [arg-type]
    ...f._service_instances[service_key] = TradingServiceImpl(service_config)
                                                              ^~~~~~~~~~~~~~
application\services\service_factory.py:174:52: error: Missing positional
argument "portfolio_optimizer" in call to "PortfolioServiceImpl"  [call-arg]
    ...          self._service_instances[service_key] = PortfolioServiceImpl(...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
application\services\service_factory.py:174:73: error: Argument 1 to
"PortfolioServiceImpl" has incompatible type "dict[str, Any]"; expected
"PortfolioRepository"  [arg-type]
    ..._service_instances[service_key] = PortfolioServiceImpl(service_config)
                                                              ^~~~~~~~~~~~~~
application\services\service_factory.py:194:52: error: Unexpected keyword
argument "risk_calculator" for "RiskServiceImpl"  [call-arg]
                self._service_instances[service_key] = RiskServiceImpl(
                                                       ^
application\services\implementations\risk_service_impl.py:22:5: note: "RiskServiceImpl" defined here
application\services\service_factory.py:292:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
application\services\service_factory.py:293:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
application\services\service_factory.py:317:20: error: Too many arguments for
"ServiceFactory"  [call-arg]
                return factory_class(config)
                       ^~~~~~~~~~~~~~~~~~~~~
application\services\service_factory.py:325:20: error: Too many arguments for
"ServiceFactory"  [call-arg]
                return self._default_factory(config)
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\service_factory.py:341:12: error: Incompatible return
value type (got "ServiceFactory | None", expected "ServiceFactory") 
[return-value]
        return service_factory_registry.create_factory(
               ^
application\services\market_service.py:22:43: error: Too many arguments for
"TechnicalAnalysisService"  [call-arg]
            self.technical_analysis_service = TechnicalAnalysisService(mar...
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\market_service.py:77:22: error: "TechnicalAnalysisService"
has no attribute "get_technical_indicators"  [attr-defined]
            return await self.technical_analysis_service.get_technical_ind...
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\services\market_service.py:123:19: error: Name "ExchangeError" is
not defined  [name-defined]
                raise ExchangeError(
                      ^~~~~~~~~~~~~
application\services\market_service.py:128:53: error: Incompatible default for
argument "alert_types" (default has type "None", argument has type "list[str]") 
[assignment]
            self, symbol: str, alert_types: List[str] = None
                                                        ^~~~
application\services\market_service.py:128:53: note: PEP 484 prohibits implicit Optional. Accordingly, mypy has changed its default to no_implicit_optional=True
application\services\market_service.py:128:53: note: Use https://github.com/hauntsaninja/no_implicit_optional to automatically upgrade your codebase
application\services\market_service.py:196:19: error: Name "ExchangeError" is
not defined  [name-defined]
                raise ExchangeError(f"Error getting market alerts: {str(e)...
                      ^~~~~~~~~~~~~
application\services\market_service.py:266:19: error: Name "ExchangeError" is
not defined  [name-defined]
                raise ExchangeError(f"Error getting market sentiment: {str...
                      ^~~~~~~~~~~~~
application\orchestration\trading_orchestrator.py:14:1: error: Module
"application.use_cases.manage_orders" has no attribute "OrderManagementUseCase";
maybe "DefaultOrderManagementUseCase"?  [attr-defined]
    from application.use_cases.manage_orders import OrderManagementUseCase
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\orchestration\trading_orchestrator.py:319:13: error: Need type
annotation for "signals" (hint: "signals: list[<type>] = ...")  [var-annotated]
                signals = []
                ^~~~~~~
application\orchestration\trading_orchestrator.py:335:76: error: Argument 2 to
"check_order_risk" of "RiskManagementUseCase" has incompatible type "None";
expected "Portfolio"  [arg-type]
    ...  risk_valid = await self.risk_use_case.check_order_risk(signal, None)
                                                                        ^~~~
tests\unit\test_decomposed_strategies.py:88:6: error: Name "patch" is not
defined  [name-defined]
        @patch('infrastructure.strategies.adaptive.market_regime_detector....
         ^~~~~
tests\unit\test_decomposed_strategies.py:89:6: error: Name "patch" is not
defined  [name-defined]
        @patch('infrastructure.strategies.adaptive.ml_signal_processor.MLS...
         ^~~~~
tests\unit\test_decomposed_strategies.py:90:6: error: Name "patch" is not
defined  [name-defined]
        @patch('infrastructure.strategies.adaptive.strategy_selector.Strat...
         ^~~~~
tests\unit\test_decomposed_strategies.py:115:6: error: Name "patch" is not
defined  [name-defined]
        @patch('infrastructure.strategies.adaptive.market_regime_detector....
         ^~~~~
tests\unit\test_decomposed_strategies.py:116:6: error: Name "patch" is not
defined  [name-defined]
        @patch('infrastructure.strategies.adaptive.ml_signal_processor.MLS...
         ^~~~~
tests\unit\test_decomposed_strategies.py:117:6: error: Name "patch" is not
defined  [name-defined]
        @patch('infrastructure.strategies.adaptive.strategy_selector.Strat...
         ^~~~~
tests\unit\application_tests\test_symbol_selection.py:7:1: error: Module
"application.symbol_selection.analytics" has no attribute
"SymbolSelectionAnalytics"; maybe "SymbolAnalytics" or "SymbolSelectionResult"? 
[attr-defined]
    from application.symbol_selection.analytics import SymbolSelectionAnal...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\application_tests\test_symbol_selection.py:8:1: error: Module
"application.symbol_selection.cache" has no attribute "SymbolSelectionCache" 
[attr-defined]
    from application.symbol_selection.cache import SymbolSelectionCache
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:14:1: error: Module
"infrastructure.agents.local_ai_controller" has no attribute "LocalAIController"
 [attr-defined]
    from infrastructure.agents.local_ai_controller import LocalAIControlle...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:44:1: error: Module
"infrastructure.simulation.backtester" has no attribute "Backtester" 
[attr-defined]
    from infrastructure.simulation.backtester import Backtester
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:85:30: error: Function
"shared.unified_cache.get_cache_manager" is not valid as a type  [valid-type]
            self.cache: Optional[get_cache_manager] = None
                                 ^
infrastructure\core\integration_manager.py:85:30: note: Perhaps you need "Callable[...]" or a callback protocol?
infrastructure\core\integration_manager.py:663:75: error: Incompatible default
for argument "market_conditions" (default has type "None", argument has type
"dict[str, Any]")  [assignment]
    ...def _adapt_strategies(self, market_conditions: Dict[str, Any] = None):
                                                                       ^~~~
infrastructure\core\integration_manager.py:663:75: note: PEP 484 prohibits implicit Optional. Accordingly, mypy has changed its default to no_implicit_optional=True
infrastructure\core\integration_manager.py:663:75: note: Use https://github.com/hauntsaninja/no_implicit_optional to automatically upgrade your codebase
infrastructure\core\integration_manager.py:667:23: error:
"AutonomousController" has no attribute "adapt_strategies"  [attr-defined]
                    await self.autonomous_controller.adapt_strategies(mark...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:703:17: error: Missing positional
argument "type" in call to "Event"  [call-arg]
                    Event(
                    ^
infrastructure\core\integration_manager.py:704:26: error: Argument "name" to
"Event" has incompatible type "str"; expected "EventName"  [arg-type]
                        name="signal.created",
                             ^~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:706:30: error: "type[EventPriority]"
has no attribute "MEDIUM"  [attr-defined]
                        priority=EventPriority.MEDIUM,
                                 ^~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:741:17: error: Missing positional
argument "type" in call to "Event"  [call-arg]
                    Event(
                    ^
infrastructure\core\integration_manager.py:742:26: error: Argument "name" to
"Event" has incompatible type "str"; expected "EventName"  [arg-type]
                        name="order.executed",
                             ^~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:757:13: error: Missing positional
argument "type" in call to "Event"  [call-arg]
                Event(
                ^
infrastructure\core\integration_manager.py:758:22: error: Argument "name" to
"Event" has incompatible type "str"; expected "EventName"  [arg-type]
                    name="system.error",
                         ^~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:825:17: error: Unsupported target
for indexed assignment ("object")  [index]
                    status["components"]["autonomous_controller"] = True
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:828:17: error: Unsupported target
for indexed assignment ("object")  [index]
                    status["components"]["circuit_breaker"] = circuit_stat...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:830:39: error: "HealthChecker" has
no attribute "get_health_status"  [attr-defined]
                    health_status = await self.health_checker.get_health_s...
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\integration_manager.py:831:17: error: Unsupported target
for indexed assignment ("object")  [index]
                    status["components"]["health_checker"] = health_status
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:835:17: error: Unsupported target
for indexed assignment ("object")  [index]
                    status["components"]["evolution_system"] = evolution_s...
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:848:23: error: "MetricsCollector"
has no attribute "record_trade"  [attr-defined]
                    await self.metrics.record_trade(trade_data)
                          ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:881:23: error:
"AutonomousController" has no attribute "handle_health_issues"; maybe
"_handle_health_issues"?  [attr-defined]
                    await self.autonomous_controller.handle_health_issues(...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:909:23: error: "MetricsCollector"
has no attribute "record_evolution"  [attr-defined]
                    await self.metrics.record_evolution(evolution_data)
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:920:23: error: "MetricsCollector"
has no attribute "record_performance_improvement"  [attr-defined]
                    await self.metrics.record_performance_improvement(perf...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\integration_manager.py:937:13: error: Missing positional
argument "type" in call to "Event"  [call-arg]
                Event(
                ^
infrastructure\core\integration_manager.py:938:22: error: Argument "name" to
"Event" has incompatible type "str"; expected "EventName"  [arg-type]
                    name="system.initialization_failed",
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\auto_migration_manager.py:216:31: error: Name "np" is not
defined  [name-defined]
                stability = 1.0 - np.std(recent_performances)
                                  ^~
application\symbol_selection\opportunity_selector.py:10:1: error: Module
"domain.symbols" has no attribute "OpportunityScore"; maybe
"OpportunityScoreCache" or "OpportunityScoreCalculator"?  [attr-defined]
    from domain.symbols import (
    ^
application\symbol_selection\opportunity_selector.py:10:1: error: Module
"domain.symbols" has no attribute "OrderBookMetrics"; maybe
"OrderBookMetricsData"?  [attr-defined]
    from domain.symbols import (
    ^
application\symbol_selection\opportunity_selector.py:10:1: error: Module
"domain.symbols" has no attribute "PatternMetrics"; maybe "PatternMetricsData"? 
[attr-defined]
    from domain.symbols import (
    ^
application\symbol_selection\opportunity_selector.py:10:1: error: Module
"domain.symbols" has no attribute "SessionMetrics"; maybe "SessionMetricsData"? 
[attr-defined]
    from domain.symbols import (
    ^
application\symbol_selection\opportunity_selector.py:211:39: error:
"BaseException" object is not iterable  [misc]
                        symbol, profile = result
                                          ^~~~~~
application\symbol_selection\opportunity_selector.py:243:29: error: Item "None"
of "SymbolMetricsProviderProtocol | None" has no attribute "get_symbol_metrics" 
[union-attr]
                metrics = await self.metrics_provider.get_symbol_metrics(s...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\symbol_selection\opportunity_selector.py:246:28: error:
"MarketPhaseClassifier" has no attribute "classify_phase"; maybe
"classify_market_phase"?  [attr-defined]
                market_phase = self.market_phase_classifier.classify_phase...
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\symbol_selection\opportunity_selector.py:259:38: error: Name "np"
is not defined  [name-defined]
                        confidence=0.7 + np.random.rand() * 0.2,
                                         ^~
application\symbol_selection\opportunity_selector.py:261:32: error: Unexpected
keyword argument "total_volume" for "VolumeProfile"  [call-arg]
                    volume_profile=VolumeProfile(
                                   ^
application\symbol_selection\opportunity_selector.py:261:32: error: Unexpected
keyword argument "avg_volume" for "VolumeProfile"; did you mean "avg_volume_1m",
"avg_volume_5m", or "avg_volume_15m"?  [call-arg]
                    volume_profile=VolumeProfile(
                                   ^
application\symbol_selection\opportunity_selector.py:266:33: error: Unexpected
keyword argument "support_levels" for "PriceStructure"; did you mean
"support_level"?  [call-arg]
                    price_structure=PriceStructure(
                                    ^
application\symbol_selection\opportunity_selector.py:266:33: error: Unexpected
keyword argument "resistance_levels" for "PriceStructure"; did you mean
"resistance_level"?  [call-arg]
                    price_structure=PriceStructure(
                                    ^
application\symbol_selection\opportunity_selector.py:280:36: error: Name "np"
is not defined  [name-defined]
                        symmetry=0.5 + np.random.rand() * 0.3,
                                       ^~
application\symbol_selection\opportunity_selector.py:284:40: error: Name "np"
is not defined  [name-defined]
                        success_rate=0.6 + np.random.rand() * 0.3,
                                           ^~
application\symbol_selection\opportunity_selector.py:285:42: error: Name "np"
is not defined  [name-defined]
                        avg_confidence=0.7 + np.random.rand() * 0.2,
                                             ^~
application\symbol_selection\opportunity_selector.py:288:45: error: Name "np"
is not defined  [name-defined]
                        session_alignment=0.6 + np.random.rand() * 0.3,
                                                ^~
application\symbol_selection\opportunity_selector.py:289:53: error: Name "np"
is not defined  [name-defined]
    ...                 cross_session_correlation=0.5 + np.random.rand() * 0....
                                                        ^~
application\symbol_selection\opportunity_selector.py:301:53: error: Argument 2
to "PriceStructure" has incompatible type "list[Never]"; expected "float" 
[arg-type]
                    price_structure=PriceStructure(100, [], []),
                                                        ^~
application\symbol_selection\opportunity_selector.py:301:57: error: Argument 3
to "PriceStructure" has incompatible type "list[Never]"; expected "float" 
[arg-type]
                    price_structure=PriceStructure(100, [], []),
                                                            ^~
application\symbol_selection\opportunity_selector.py:318:33: error:
"SymbolFilters" has no attribute "apply_filters"  [attr-defined]
                filtered_profiles = self.filters.apply_filters(profiles)
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
application\services\market_service_factory.py:18:9: error: Need type
annotation for "_services_cache" (hint:
"_services_cache: dict[<type>, <type>] = ...")  [var-annotated]
            self._services_cache = {}
            ^~~~~~~~~~~~~~~~~~~~
application\services\market_service_factory.py:40:17: error: Too many arguments
for "TechnicalAnalysisService"  [call-arg]
                    TechnicalAnalysisService(self.market_repository)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_integration_manager.py:356:23: error: Unexpected keyword
argument "name" for "Event"  [call-arg]
            trade_event = Event(
                          ^
tests\unit\test_integration_manager.py:359:24: error: "type[EventType]" has no
attribute "TRADE"  [attr-defined]
                event_type=EventType.TRADE,
                           ^~~~~~~~~~~~~~~
tests\unit\test_integration_manager.py:362:22: error: Unexpected keyword
argument "name" for "Event"  [call-arg]
            risk_event = Event(
                         ^
tests\unit\test_integration_manager.py:365:24: error: "type[EventType]" has no
attribute "RISK"  [attr-defined]
                event_type=EventType.RISK,
                           ^~~~~~~~~~~~~~
tests\unit\test_integration_manager.py:369:54: error: Argument 1 to
"_on_trade_executed" of "IntegrationManager" has incompatible type
"domain.types.infrastructure_types.Event"; expected
"domain.types.messaging_types.Event"  [arg-type]
            await integration_manager._on_trade_executed(trade_event)
                                                         ^~~~~~~~~~~
tests\unit\test_integration_manager.py:370:59: error: Argument 1 to
"_on_risk_limit_exceeded" of "IntegrationManager" has incompatible type
"domain.types.infrastructure_types.Event"; expected
"domain.types.messaging_types.Event"  [arg-type]
            await integration_manager._on_risk_limit_exceeded(risk_event)
                                                              ^~~~~~~~~~
tests\unit\test_integration_manager.py:392:9: error: "IntegrationManager" has
no attribute "cleanup"  [attr-defined]
            integration_manager.cleanup()
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\domain\test_symbols_workflow_integration.py:8:1: error:
Module "domain.symbols" has no attribute "OrderBookMetrics"; maybe
"OrderBookMetricsData"?  [attr-defined]
    from domain.symbols import (
    ^
tests\integration\domain\test_symbols_workflow_integration.py:8:1: error:
Module "domain.symbols" has no attribute "PatternMetrics"; maybe
"PatternMetricsData"?  [attr-defined]
    from domain.symbols import (
    ^
tests\integration\domain\test_symbols_workflow_integration.py:8:1: error:
Module "domain.symbols" has no attribute "SessionMetrics"; maybe
"SessionMetricsData"?  [attr-defined]
    from domain.symbols import (
    ^
tests\e2e\test_symbols_performance_e2e.py:12:1: error: Module "domain.symbols"
has no attribute "OrderBookMetrics"; maybe "OrderBookMetricsData"? 
[attr-defined]
    from domain.symbols import (
    ^
tests\e2e\test_symbols_performance_e2e.py:12:1: error: Module "domain.symbols"
has no attribute "PatternMetrics"; maybe "PatternMetricsData"?  [attr-defined]
    from domain.symbols import (
    ^
tests\e2e\test_symbols_performance_e2e.py:12:1: error: Module "domain.symbols"
has no attribute "SessionMetrics"; maybe "SessionMetricsData"?  [attr-defined]
    from domain.symbols import (
    ^
tests\e2e\test_symbols_e2e.py:9:1: error: Module "domain.symbols" has no
attribute "OrderBookMetrics"; maybe "OrderBookMetricsData"?  [attr-defined]
    from domain.symbols import (
    ^
tests\e2e\test_symbols_e2e.py:9:1: error: Module "domain.symbols" has no
attribute "PatternMetrics"; maybe "PatternMetricsData"?  [attr-defined]
    from domain.symbols import (
    ^
tests\e2e\test_symbols_e2e.py:9:1: error: Module "domain.symbols" has no
attribute "SessionMetrics"; maybe "SessionMetricsData"?  [attr-defined]
    from domain.symbols import (
    ^
tests\e2e\test_symbols_e2e.py:15:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"TradingOrchestrator"  [attr-defined]
    from application.use_cases.trading_orchestrator import TradingOrchestr...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\e2e\test_symbols_e2e.py:16:1: error: Module "domain.entities.trading" has
no attribute "TradingDecision"; maybe "TradingSession"?  [attr-defined]
    from domain.entities.trading import TradingDecision, OrderType, Positi...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\ml_services\model_selector.py:329:17: error: "DataFrame" has no
attribute "values"  [attr-defined]
                X = features.values.reshape((features.shape[0], features.s...
                    ^~~~~~~~~~~~~~~
infrastructure\ml_services\model_selector.py:329:42: error: "DataFrame" has no
attribute "shape"  [attr-defined]
                X = features.values.reshape((features.shape[0], features.s...
                                             ^~~~~~~~~~~~~~
infrastructure\ml_services\model_selector.py:373:17: error: "DataFrame" has no
attribute "values"  [attr-defined]
                X = features.values.reshape((features.shape[0], features.s...
                    ^~~~~~~~~~~~~~~
infrastructure\ml_services\model_selector.py:373:42: error: "DataFrame" has no
attribute "shape"  [attr-defined]
                X = features.values.reshape((features.shape[0], features.s...
                                             ^~~~~~~~~~~~~~
infrastructure\ml_services\model_selector.py:382:38: error: "DataFrame" has no
attribute "shape"  [attr-defined]
                            input_shape=(features.shape[1], 1),
                                         ^~~~~~~~~~~~~~
infrastructure\ml_services\model_selector.py:419:17: error: "DataFrame" has no
attribute "values"  [attr-defined]
                X = features.values
                    ^~~~~~~~~~~~~~~
infrastructure\ml_services\model_selector.py:431:36: error: Value of type
"Callable[[], ndarray[Any, Any]]" is not indexable  [index]
                    y_sequences.append(y[i])
                                       ^~~~
infrastructure\ml_services\model_selector.py:510:21: error: Item "DataFrame" of
"DataFrame | dict[Never, Never]" has no attribute "to_dict"  [union-attr]
                        self.feature_importance.get(pair, {}).get(timefram...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\ml_services\model_selector.py:510:21: error: Item
"dict[Never, Never]" of "DataFrame | dict[Never, Never]" has no attribute
"to_dict"  [union-attr]
                        self.feature_importance.get(pair, {}).get(timefram...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\ml_services\model_selector.py:577:21: error: "DataFrame" has no
attribute "values"  [attr-defined]
                    X = features.values
                        ^~~~~~~~~~~~~~~
infrastructure\core\system_integration.py:48:1: error: Module
"infrastructure.core.exchange" has no attribute "ExchangeManager" 
[attr-defined]
    from .exchange import ExchangeManager
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\system_integration.py:50:1: error: Module
"infrastructure.core.fibonacci_tools" has no attribute "FibonacciAnalysis" 
[attr-defined]
    from .fibonacci_tools import (
    ^
infrastructure\core\system_integration.py:50:1: error: Module
"infrastructure.core.fibonacci_tools" has no attribute "FibonacciCalculator" 
[attr-defined]
    from .fibonacci_tools import (
    ^
infrastructure\core\system_integration.py:50:1: error: Module
"infrastructure.core.fibonacci_tools" has no attribute "FibonacciExtension" 
[attr-defined]
    from .fibonacci_tools import (
    ^
infrastructure\core\system_integration.py:50:1: error: Module
"infrastructure.core.fibonacci_tools" has no attribute "FibonacciRetracement" 
[attr-defined]
    from .fibonacci_tools import (
    ^
infrastructure\core\system_integration.py:61:1: error: Module
"infrastructure.core.market_regime" has no attribute "RegimeAnalysis" 
[attr-defined]
    from .market_regime import (
    ^
infrastructure\core\system_integration.py:61:1: error: Module
"infrastructure.core.market_regime" has no attribute "RegimeClassifier" 
[attr-defined]
    from .market_regime import (
    ^
infrastructure\core\system_integration.py:61:1: error: Module
"infrastructure.core.market_regime" has no attribute "RegimeMetrics" 
[attr-defined]
    from .market_regime import (
    ^
infrastructure\core\system_integration.py:61:1: error: Module
"infrastructure.core.market_regime" has no attribute "RegimeTransition" 
[attr-defined]
    from .market_regime import (
    ^
infrastructure\core\system_integration.py:69:1: error: Module
"infrastructure.core.math_utils" has no attribute "FinancialUtils" 
[attr-defined]
    from .math_utils import (
    ^
infrastructure\core\system_integration.py:69:1: error: Module
"infrastructure.core.math_utils" has no attribute "MathUtils"  [attr-defined]
    from .math_utils import (
    ^
infrastructure\core\system_integration.py:69:1: error: Module
"infrastructure.core.math_utils" has no attribute "MatrixUtils"  [attr-defined]
    from .math_utils import (
    ^
infrastructure\core\system_integration.py:69:1: error: Module
"infrastructure.core.math_utils" has no attribute "OptimizationUtils" 
[attr-defined]
    from .math_utils import (
    ^
infrastructure\core\system_integration.py:69:1: error: Module
"infrastructure.core.math_utils" has no attribute "StatisticalUtils" 
[attr-defined]
    from .math_utils import (
    ^
infrastructure\core\system_integration.py:69:1: error: Module
"infrastructure.core.math_utils" has no attribute "VectorUtils"  [attr-defined]
    from .math_utils import (
    ^
infrastructure\core\system_integration.py:86:1: error: Module
"infrastructure.core.technical" has no attribute "MomentumAnalysis" 
[attr-defined]
    from .technical import (
    ^
infrastructure\core\system_integration.py:86:1: error: Module
"infrastructure.core.technical" has no attribute "SupportResistance" 
[attr-defined]
    from .technical import (
    ^
infrastructure\core\system_integration.py:86:1: error: Module
"infrastructure.core.technical" has no attribute "TechnicalAnalysis" 
[attr-defined]
    from .technical import (
    ^
infrastructure\core\system_integration.py:86:1: error: Module
"infrastructure.core.technical" has no attribute "TechnicalIndicatorsService" 
[attr-defined]
    from .technical import (
    ^
infrastructure\core\system_integration.py:86:1: error: Module
"infrastructure.core.technical" has no attribute "TechnicalPatterns" 
[attr-defined]
    from .technical import (
    ^
infrastructure\core\system_integration.py:86:1: error: Module
"infrastructure.core.technical" has no attribute "TrendAnalysis"  [attr-defined]
    from .technical import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute "ADX"  [attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute "ATR"  [attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute "CCI"  [attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute "EMA"  [attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute "RSI"  [attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute "SMA"  [attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute "BollingerBands";
maybe "bollinger_bands"?  [attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute "StochasticOscillator"
 [attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute
"TechnicalAnalysisService"  [attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute "TechnicalIndicators" 
[attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:96:1: error: Module
"infrastructure.core.technical_analysis" has no attribute "WilliamsR" 
[attr-defined]
    from .technical_analysis import (
    ^
infrastructure\core\system_integration.py:110:1: error: Module
"infrastructure.core.timeframes" has no attribute "MultiTimeframeAnalysis" 
[attr-defined]
    from .timeframes import (
    ^
infrastructure\core\system_integration.py:110:1: error: Module
"infrastructure.core.timeframes" has no attribute "TimeframeAnalysis" 
[attr-defined]
    from .timeframes import (
    ^
infrastructure\core\system_integration.py:110:1: error: Module
"infrastructure.core.timeframes" has no attribute "TimeframeConverter" 
[attr-defined]
    from .timeframes import (
    ^
infrastructure\core\system_integration.py:110:1: error: Module
"infrastructure.core.timeframes" has no attribute "TimeframeManager" 
[attr-defined]
    from .timeframes import (
    ^
infrastructure\core\system_integration.py:110:1: error: Module
"infrastructure.core.timeframes" has no attribute "TimeframeOptimizer" 
[attr-defined]
    from .timeframes import (
    ^
infrastructure\core\system_integration.py:117:1: error: Module
"infrastructure.core.visualization" has no attribute "ChartRenderer" 
[attr-defined]
    from .visualization import (
    ^
infrastructure\core\system_integration.py:117:1: error: Module
"infrastructure.core.visualization" has no attribute "MarketVisualization" 
[attr-defined]
    from .visualization import (
    ^
infrastructure\core\system_integration.py:117:1: error: Module
"infrastructure.core.visualization" has no attribute "PerformanceChart" 
[attr-defined]
    from .visualization import (
    ^
infrastructure\core\system_integration.py:117:1: error: Module
"infrastructure.core.visualization" has no attribute "PlotManager" 
[attr-defined]
    from .visualization import (
    ^
infrastructure\core\system_integration.py:117:1: error: Module
"infrastructure.core.visualization" has no attribute "RiskChart"  [attr-defined]
    from .visualization import (
    ^
infrastructure\core\system_integration.py:117:1: error: Module
"infrastructure.core.visualization" has no attribute "TechnicalChart" 
[attr-defined]
    from .visualization import (
    ^
infrastructure\core\system_integration.py:125:1: error: Module
"infrastructure.core.wavelet_tools" has no attribute "WaveletAnalyzer" 
[attr-defined]
    from .wavelet_tools import (
    ^
infrastructure\core\system_integration.py:125:1: error: Module
"infrastructure.core.wavelet_tools" has no attribute "WaveletDecomposition" 
[attr-defined]
    from .wavelet_tools import (
    ^
infrastructure\core\system_integration.py:125:1: error: Module
"infrastructure.core.wavelet_tools" has no attribute "WaveletFeatures" 
[attr-defined]
    from .wavelet_tools import (
    ^
infrastructure\core\system_integration.py:125:1: error: Module
"infrastructure.core.wavelet_tools" has no attribute "WaveletReconstruction" 
[attr-defined]
    from .wavelet_tools import (
    ^
infrastructure\core\system_integration.py:125:1: error: Module
"infrastructure.core.wavelet_tools" has no attribute "WaveletTransform" 
[attr-defined]
    from .wavelet_tools import (
    ^
infrastructure\core\system_integration.py:244:31: error: Incompatible types in
assignment (expression has type "datetime", variable has type "None") 
[assignment]
                self.start_time = datetime.now()
                                  ^~~~~~~~~~~~~~
infrastructure\core\system_integration.py:287:65: error: Argument 1 to
"CircuitBreaker" has incompatible type
"infrastructure.messaging.event_bus.EventBus"; expected
"infrastructure.messaging.optimized_event_bus.EventBus"  [arg-type]
    ...   self.components["circuit_breaker"] = CircuitBreaker(self.event_bus)
                                                              ^~~~~~~~~~~~~~
infrastructure\core\system_integration.py:295:43: error: Missing positional
argument "connection_string" in call to "Database"  [call-arg]
                self.components["database"] = Database()
                                              ^~~~~~~~~~
infrastructure\core\system_integration.py:299:53: error: Missing positional
argument "connection_string" in call to "OptimizedDatabase"  [call-arg]
    ...           self.components["optimized_database"] = OptimizedDatabase()
                                                          ^~~~~~~~~~~~~~~~~~~
infrastructure\core\system_integration.py:319:51: error: Missing positional
argument "config" in call to "PositionManager"  [call-arg]
                self.components["position_manager"] = PositionManager()
                                                      ^~~~~~~~~~~~~~~~~
infrastructure\core\system_integration.py:332:17: error: Argument 1 to
"AutonomousController" has incompatible type
"infrastructure.messaging.event_bus.EventBus"; expected
"infrastructure.messaging.optimized_event_bus.EventBus"  [arg-type]
                    self.event_bus, {}
                    ^~~~~~~~~~~~~~
infrastructure\core\system_integration.py:385:47: error: Missing positional
arguments "timestamp", "price", "volume", "volatility", "trend", "indicators",
"market_regime", "liquidity", "momentum", "sentiment", "support_levels",
"resistance_levels", "market_depth", "correlation_matrix", "market_impact",
"volume_profile" in call to "MarketState"  [call-arg]
                self.components["market_state"] = MarketState()
                                                  ^~~~~~~~~~~~~
infrastructure\core\system_integration.py:429:34: error: Argument 1 to
"subscribe" of "EventBus" has incompatible type "str"; expected "EventName" 
[arg-type]
            self.event_bus.subscribe("health.issues_detected", self._on_he...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\system_integration.py:429:60: error: Argument 2 to
"subscribe" of "EventBus" has incompatible type
"Callable[[domain.types.infrastructure_types.Event], Coroutine[Any, Any, None]]";
expected
"Callable[[domain.types.messaging_types.Event], Awaitable[None] | None]" 
[arg-type]
    ...lf.event_bus.subscribe("health.issues_detected", self._on_health_issue...
                                                        ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\system_integration.py:431:34: error: Argument 1 to
"subscribe" of "EventBus" has incompatible type "str"; expected "EventName" 
[arg-type]
            self.event_bus.subscribe("risk.limit_exceeded", self._on_risk_...
                                     ^~~~~~~~~~~~~~~~~~~~~
infrastructure\core\system_integration.py:431:57: error: Argument 2 to
"subscribe" of "EventBus" has incompatible type
"Callable[[domain.types.infrastructure_types.Event], Coroutine[Any, Any, None]]";
expected
"Callable[[domain.types.messaging_types.Event], Awaitable[None] | None]" 
[arg-type]
    ... self.event_bus.subscribe("risk.limit_exceeded", self._on_risk_limit_e...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\core\system_integration.py:433:34: error: Argument 1 to
"subscribe" of "EventBus" has incompatible type "str"; expected "EventName" 
[arg-type]
            self.event_bus.subscribe("trade.executed", self._on_trade_exec...
                                     ^~~~~~~~~~~~~~~~
infrastructure\core\system_integration.py:433:52: error: Argument 2 to
"subscribe" of "EventBus" has incompatible type
"Callable[[domain.types.infrastructure_types.Event], Coroutine[Any, Any, None]]";
expected
"Callable[[domain.types.messaging_types.Event], Awaitable[None] | None]" 
[arg-type]
    ...      self.event_bus.subscribe("trade.executed", self._on_trade_execut...
                                                        ^~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\system_integration.py:435:34: error: Argument 1 to
"subscribe" of "EventBus" has incompatible type "str"; expected "EventName" 
[arg-type]
            self.event_bus.subscribe("evolution.agent_evolved", self._on_a...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\core\system_integration.py:435:61: error: Argument 2 to
"subscribe" of "EventBus" has incompatible type
"Callable[[domain.types.infrastructure_types.Event], Coroutine[Any, Any, None]]";
expected
"Callable[[domain.types.messaging_types.Event], Awaitable[None] | None]" 
[arg-type]
    ...f.event_bus.subscribe("evolution.agent_evolved", self._on_agent_evolve...
                                                        ^~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:25:1: error: Incompatible
import of "FollowResult" (imported name has type
"type[domain.interfaces.strategy_protocols.FollowResult]", local name has type
"type[application.market.mm_follow_controller.FollowResult]")  [assignment]
    from domain.interfaces.strategy_protocols import (
    ^
infrastructure\agents\agent_context_refactored.py:25:1: error: Incompatible
import of "FollowSignal" (imported name has type
"type[domain.interfaces.strategy_protocols.FollowSignal]", local name has type
"type[application.market.mm_follow_controller.FollowSignal]")  [assignment]
    from domain.interfaces.strategy_protocols import (
    ^
infrastructure\agents\agent_context_refactored.py:25:1: error: Incompatible
import of "MirrorMap" (imported name has type
"type[domain.interfaces.strategy_protocols.MirrorMap]", local name has type
"type[application.strategy_advisor.mirror_map_builder.MirrorMap]")  [assignment]
    from domain.interfaces.strategy_protocols import (
    ^
infrastructure\agents\agent_context_refactored.py:25:1: error: Incompatible
import of "SymbolSelectionResult" (imported name has type
"type[domain.interfaces.strategy_protocols.SymbolSelectionResult]", local name
has type "type[application.symbol_selection.types.SymbolSelectionResult]") 
[assignment]
    from domain.interfaces.strategy_protocols import (
    ^
infrastructure\agents\agent_context_refactored.py:134:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very low order aggre...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:136:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very high order aggr...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:139:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very low position si...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:141:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very high position s...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:144:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["errors"].append("Invalid confidence mul...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:147:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very high confidence...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:150:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["errors"].append("Invalid risk multiplie...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:153:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very high risk multi...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:156:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["errors"].append("Invalid execution dela...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:159:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["warnings"].append("Very high execution ...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:163:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["warnings"].append("High aggressiveness ...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:166:13: error: "object" has
no attribute "append"  [attr-defined]
                validation_result["warnings"].append(
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:244:62: error: Argument
"context" to "get_logger" has incompatible type "str"; expected "LogContext" 
[arg-type]
            self.logger = get_logger(f"modifier.{name}", context="agent")
                                                                 ^~~~~~~
infrastructure\agents\agent_context_refactored.py:269:29: error: Item "None" of
"EntanglementResult | None" has no attribute "correlation_score"  [union-attr]
            correlation_score = result.correlation_score
                                ^~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:270:18: error: Item "None" of
"EntanglementResult | None" has no attribute "lag_ms"  [union-attr]
            lag_ms = result.lag_ms
                     ^~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:271:22: error: Item "None" of
"EntanglementResult | None" has no attribute "confidence"  [union-attr]
            confidence = result.confidence
                         ^~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:343:12: error: Item "None" of
"FollowSignal | None" has no attribute "confidence"  [union-attr]
            if signal.confidence > 0.8:
               ^~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:345:52: error: Item "None" of
"FollowSignal | None" has no attribute "position_size_modifier"  [union-attr]
    ...              ModifierType.ORDER_AGGRESSIVENESS, signal.position_size_...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context_refactored.py:348:56: error: Item "None" of
"FollowSignal | None" has no attribute "position_size_modifier"  [union-attr]
    ...          ModifierType.POSITION_SIZE_MULTIPLIER, signal.position_size_...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context_refactored.py:351:53: error: Item "None" of
"FollowSignal | None" has no attribute "confidence"  [union-attr]
                    ModifierType.CONFIDENCE_MULTIPLIER, signal.confidence
                                                        ^~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:354:47: error: Item "None" of
"FollowSignal | None" has no attribute "risk_modifier"  [union-attr]
                    ModifierType.RISK_MULTIPLIER, signal.risk_modifier
                                                  ^~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:357:52: error: Item "None" of
"FollowSignal | None" has no attribute "stop_loss_modifier"  [union-attr]
    ...              ModifierType.PRICE_OFFSET_PERCENT, signal.stop_loss_modi...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context_refactored.py:361:16: error: Item "None" of
"FollowSignal | None" has no attribute "entry_timing"  [union-attr]
                if signal.entry_timing == "immediate":
                   ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:363:18: error: Item "None" of
"FollowSignal | None" has no attribute "entry_timing"  [union-attr]
                elif signal.entry_timing == "wait":
                     ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:367:18: error: Item "None" of
"FollowSignal | None" has no attribute "entry_timing"  [union-attr]
                elif signal.entry_timing == "gradual":
                     ^~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:372:14: error: Item "None" of
"FollowSignal | None" has no attribute "confidence"  [union-attr]
            elif signal.confidence > 0.6:
                 ^~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:376:24: error: Item "None" of
"FollowSignal | None" has no attribute "position_size_modifier"  [union-attr]
                    1.0 + (signal.position_size_modifier - 1.0) * 0.5,
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:380:24: error: Item "None" of
"FollowSignal | None" has no attribute "position_size_modifier"  [union-attr]
                    1.0 + (signal.position_size_modifier - 1.0) * 0.5,
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:384:24: error: Item "None" of
"FollowSignal | None" has no attribute "confidence"  [union-attr]
                    1.0 + (signal.confidence - 0.6) * 0.5,
                           ^~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:400:47: error: Argument 2 to
"_update_pattern_context" of "MarketMakerPatternModifierApplicator" has
incompatible type "FollowSignal | None"; expected "FollowSignal"  [arg-type]
            self._update_pattern_context(context, signal)
                                                  ^~~~~~
infrastructure\agents\agent_context_refactored.py:403:13: error: Item "None" of
"FollowSignal | None" has no attribute "pattern_type"  [union-attr]
                f"Applied MM pattern modifier: pattern={signal.pattern_typ...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:403:13: error: Item "None" of
"FollowSignal | None" has no attribute "confidence"  [union-attr]
                f"Applied MM pattern modifier: pattern={signal.pattern_typ...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
infrastructure\agents\agent_context_refactored.py:498:9: error: Item "None" of
"AgentLogger | None" has no attribute "debug"  [union-attr]
            self._logger.debug(f"Set {key} = {value}")
            ^~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:571:17: error: Item "None" of
"AgentLogger | None" has no attribute "error"  [union-attr]
                    self._logger.error(f"Error applying modifier {applicat...
                    ^~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:581:9: error: Item "None" of
"AgentLogger | None" has no attribute "debug"  [union-attr]
            self._logger.debug(
            ^~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:664:9: error: Item "None" of
"AgentLogger | None" has no attribute "debug"  [union-attr]
            self._logger.debug("Reset modifiers cache")
            ^~~~~~~~~~~~~~~~~~
infrastructure\agents\agent_context_refactored.py:671:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
examples\doass_integration_example.py:24:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\trading_orchestrator\core.py:31:1: error: Module
"domain.entities.trading" has no attribute "Order"; maybe "OrderId"? 
[attr-defined]
    from domain.entities.trading import Order, OrderSide, OrderStatus, Ord...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\trading_orchestrator\core.py:65:1: error: Module
"domain.strategies" has no attribute "StrategyInterface"  [attr-defined]
    from domain.strategies import (
    ^
application\use_cases\trading_orchestrator\core.py:89:1: error: Module
"infrastructure.ml_services.decision_reasoner" has no attribute "TradeDecision" 
[attr-defined]
    from infrastructure.ml_services.decision_reasoner import DecisionReaso...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\use_cases\trading_orchestrator\core.py:166:30: error: Name
"PositionRepository" is not defined  [name-defined]
            position_repository: PositionRepository,
                                 ^
application\use_cases\trading_orchestrator\core.py:167:31: error: Name
"PortfolioRepository" is not defined  [name-defined]
            portfolio_repository: PortfolioRepository,
                                  ^
application\use_cases\trading_orchestrator\core.py:301:32: error: Missing
positional argument "orchestrator" in call to "UpdateHandlers"  [call-arg]
            self.update_handlers = UpdateHandlers()
                                   ^~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:302:26: error: Missing
positional argument "orchestrator" in call to "Modifiers"  [call-arg]
            self.modifiers = Modifiers()
                             ^~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:312:65: error: Argument 1 to
"get_by_id" of "StrategyRepository" has incompatible type "StrategyId"; expected
"EntityId"  [arg-type]
    ...rategy = await self.strategy_repository.get_by_id(request.strategy_id)
                                                         ^~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:322:17: error: Argument 1 to
"validate_trading_conditions" of "DefaultTradingOrchestratorUseCase" has
incompatible type "PortfolioId"; expected "str"  [arg-type]
                    request.portfolio_id, request.symbol
                    ^~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:327:29: error: "Strategy"
has no attribute "execute"  [attr-defined]
                signals = await strategy.execute(request.market_data)
                                ^~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:327:46: error:
"ExecuteStrategyRequest" has no attribute "market_data"  [attr-defined]
                signals = await strategy.execute(request.market_data)
                                                 ^~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:332:29: error: Argument 2 to
"_create_order_from_signal" of "DefaultTradingOrchestratorUseCase" has
incompatible type "PortfolioId"; expected "str"  [arg-type]
                        signal, request.portfolio_id
                                ^~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:336:20: error: Unexpected
keyword argument "strategy_id" for "ExecuteStrategyResponse"  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:336:20: error: Unexpected
keyword argument "portfolio_id" for "ExecuteStrategyResponse"  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:336:20: error: Unexpected
keyword argument "symbol" for "ExecuteStrategyResponse"  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:336:20: error: Unexpected
keyword argument "orders" for "ExecuteStrategyResponse"  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:336:20: error: Unexpected
keyword argument "signals" for "ExecuteStrategyResponse"  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:336:20: error: Unexpected
keyword argument "execution_time" for "ExecuteStrategyResponse"; did you mean
"execution_time_ms"?  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:347:20: error: Unexpected
keyword argument "strategy_id" for "ExecuteStrategyResponse"  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:347:20: error: Unexpected
keyword argument "portfolio_id" for "ExecuteStrategyResponse"  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:347:20: error: Unexpected
keyword argument "symbol" for "ExecuteStrategyResponse"  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:347:20: error: Unexpected
keyword argument "orders" for "ExecuteStrategyResponse"  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:347:20: error: Unexpected
keyword argument "signals" for "ExecuteStrategyResponse"  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:347:20: error: Unexpected
keyword argument "execution_time" for "ExecuteStrategyResponse"; did you mean
"execution_time_ms"?  [call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:347:20: error: Unexpected
keyword argument "error" for "ExecuteStrategyResponse"; did you mean "errors"? 
[call-arg]
                return ExecuteStrategyResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:363:29: error:
"ExecuteStrategyRequest" has no attribute "strategy_name"  [attr-defined]
                strategy_name = request.strategy_name.lower()
                                ^~~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:394:25: error:
"ProcessSignalRequest" has no attribute "signal_id"; maybe "signal"? 
[attr-defined]
                logger.info(f"Processing signal: {request.signal_id}")
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:397:33: error: Argument 2 to
"_create_order_from_signal" of "DefaultTradingOrchestratorUseCase" has
incompatible type "PortfolioId"; expected "str"  [arg-type]
                    request.signal, request.portfolio_id
                                    ^~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:400:24: error: Unexpected
keyword argument "signal_id" for "ProcessSignalResponse"  [call-arg]
                    return ProcessSignalResponse(
                           ^
application\use_cases\trading_orchestrator\core.py:400:24: error: Unexpected
keyword argument "portfolio_id" for "ProcessSignalResponse"  [call-arg]
                    return ProcessSignalResponse(
                           ^
application\use_cases\trading_orchestrator\core.py:400:24: error: Unexpected
keyword argument "order" for "ProcessSignalResponse"  [call-arg]
                    return ProcessSignalResponse(
                           ^
application\use_cases\trading_orchestrator\core.py:400:24: error: Unexpected
keyword argument "processing_time" for "ProcessSignalResponse"  [call-arg]
                    return ProcessSignalResponse(
                           ^
application\use_cases\trading_orchestrator\core.py:401:31: error:
"ProcessSignalRequest" has no attribute "signal_id"; maybe "signal"? 
[attr-defined]
                        signal_id=request.signal_id,
                                  ^~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:408:24: error: Unexpected
keyword argument "signal_id" for "ProcessSignalResponse"  [call-arg]
                    return ProcessSignalResponse(
                           ^
application\use_cases\trading_orchestrator\core.py:408:24: error: Unexpected
keyword argument "portfolio_id" for "ProcessSignalResponse"  [call-arg]
                    return ProcessSignalResponse(
                           ^
application\use_cases\trading_orchestrator\core.py:408:24: error: Unexpected
keyword argument "order" for "ProcessSignalResponse"  [call-arg]
                    return ProcessSignalResponse(
                           ^
application\use_cases\trading_orchestrator\core.py:408:24: error: Unexpected
keyword argument "processing_time" for "ProcessSignalResponse"  [call-arg]
                    return ProcessSignalResponse(
                           ^
application\use_cases\trading_orchestrator\core.py:408:24: error: Unexpected
keyword argument "error" for "ProcessSignalResponse"; did you mean "errors"? 
[call-arg]
                    return ProcessSignalResponse(
                           ^
application\use_cases\trading_orchestrator\core.py:409:31: error:
"ProcessSignalRequest" has no attribute "signal_id"; maybe "signal"? 
[attr-defined]
                        signal_id=request.signal_id,
                                  ^~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:418:20: error: Unexpected
keyword argument "signal_id" for "ProcessSignalResponse"  [call-arg]
                return ProcessSignalResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:418:20: error: Unexpected
keyword argument "portfolio_id" for "ProcessSignalResponse"  [call-arg]
                return ProcessSignalResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:418:20: error: Unexpected
keyword argument "order" for "ProcessSignalResponse"  [call-arg]
                return ProcessSignalResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:418:20: error: Unexpected
keyword argument "processing_time" for "ProcessSignalResponse"  [call-arg]
                return ProcessSignalResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:418:20: error: Unexpected
keyword argument "error" for "ProcessSignalResponse"; did you mean "errors"? 
[call-arg]
                return ProcessSignalResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:419:27: error:
"ProcessSignalRequest" has no attribute "signal_id"; maybe "signal"? 
[attr-defined]
                    signal_id=request.signal_id,
                              ^~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:435:17: error: Argument 1 to
"calculate_portfolio_weights" of "DefaultTradingOrchestratorUseCase" has
incompatible type "PortfolioId"; expected "str"  [arg-type]
                    request.portfolio_id
                    ^~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:444:39: error:
"PortfolioRebalanceRequest" has no attribute "rebalance_threshold" 
[attr-defined]
                    if abs(weight_diff) > request.rebalance_threshold:
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:447:46: error: Argument 3 to
"_create_rebalance_order" of "DefaultTradingOrchestratorUseCase" has
incompatible type "PortfolioId"; expected "str"  [arg-type]
                            symbol, weight_diff, request.portfolio_id
                                                 ^~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:451:20: error: Unexpected
keyword argument "portfolio_id" for "PortfolioRebalanceResponse"  [call-arg]
                return PortfolioRebalanceResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:451:20: error: Unexpected
keyword argument "orders" for "PortfolioRebalanceResponse"  [call-arg]
                return PortfolioRebalanceResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:451:20: error: Unexpected
keyword argument "rebalance_time" for "PortfolioRebalanceResponse"; did you mean
"rebalance_cost"?  [call-arg]
                return PortfolioRebalanceResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:454:33: error: Argument
"current_weights" to "PortfolioRebalanceResponse" has incompatible type
"dict[str, Decimal]"; expected "dict[Symbol, Decimal]"  [arg-type]
                    current_weights=current_weights,
                                    ^~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:461:20: error: Unexpected
keyword argument "portfolio_id" for "PortfolioRebalanceResponse"  [call-arg]
                return PortfolioRebalanceResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:461:20: error: Unexpected
keyword argument "orders" for "PortfolioRebalanceResponse"  [call-arg]
                return PortfolioRebalanceResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:461:20: error: Unexpected
keyword argument "rebalance_time" for "PortfolioRebalanceResponse"; did you mean
"rebalance_cost"?  [call-arg]
                return PortfolioRebalanceResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:461:20: error: Unexpected
keyword argument "error" for "PortfolioRebalanceResponse"; did you mean
"errors"?  [call-arg]
                return PortfolioRebalanceResponse(
                       ^
application\use_cases\trading_orchestrator\core.py:479:29: error:
"SessionService" has no attribute "create_session"  [attr-defined]
                session = await self.session_service.create_session(
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:507:29: error:
"SessionService" has no attribute "stop_session"  [attr-defined]
                success = await self.session_service.stop_session(session_...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:524:29: error:
"SessionService" has no attribute "get_session"; maybe "get_session_phase"? 
[attr-defined]
                session = await self.session_service.get_session(session_i...
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:601:19: error:
"OrderRepository" has no attribute "create"  [attr-defined]
                await self.order_repository.create(order)
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\use_cases\trading_orchestrator\core.py:626:19: error:
"OrderRepository" has no attribute "create"  [attr-defined]
                await self.order_repository.create(order)
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\performance\test_infrastructure_performance.py:27:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\performance\test_infrastructure_performance.py:28:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\performance\test_infrastructure_performance.py:29:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\performance\test_infrastructure_performance.py:328:24: error: Argument
"id" to "Order" has incompatible type "UUID"; expected "OrderId"  [arg-type]
                        id=uuid4(),
                           ^~~~~~~
tests\performance\test_infrastructure_performance.py:329:34: error:
"type[TradingPair]" has no attribute "from_string"  [attr-defined]
                        trading_pair=TradingPair.from_string("BTC/USD"),
                                     ^~~~~~~~~~~~~~~~~~~~~~~
tests\performance\test_infrastructure_performance.py:332:30: error: Argument
"quantity" to "Order" has incompatible type "Decimal"; expected "VolumeValue" 
[arg-type]
                        quantity=Decimal("1.0"),
                                 ^~~~~~~~~~~~~~
tests\performance\test_infrastructure_performance.py:333:27: error: Argument
"price" to "Order" has incompatible type "Money"; expected "Price | None" 
[arg-type]
                        price=Money(Decimal("50000"), Currency.USD),
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\performance\test_infrastructure_performance.py:335:32: error: Argument
"created_at" to "Order" has incompatible type "datetime"; expected "Timestamp" 
[arg-type]
                        created_at=datetime.now(),
                                   ^~~~~~~~~~~~~~
tests\performance\test_infrastructure_performance.py:336:32: error: Argument
"updated_at" to "Order" has incompatible type "datetime"; expected "Timestamp" 
[arg-type]
                        updated_at=datetime.now()
                                   ^~~~~~~~~~~~~~
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionRepository" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionCache"  [attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionValidator" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionMetricsCalculator" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionPatternRecognizer" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionTransitionManager" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionPredictor" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionOptimizer" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionMonitor" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionAnalytics" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:15:1: error:
Module "infrastructure.sessions" has no attribute "SessionRiskAnalyzer" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_infrastructure_integration.py:84:35: error:
Name "pd" is not defined  [name-defined]
        def mock_market_data(self) -> pd.DataFrame:
                                      ^
tests\integration\test_sessions_infrastructure_integration.py:86:16: error:
Name "pd" is not defined  [name-defined]
            return pd.DataFrame({
                   ^~
tests\integration\test_sessions_infrastructure_integration.py:87:26: error:
Name "pd" is not defined  [name-defined]
                'timestamp': pd.date_range(start='2024-01-01', periods=100...
                             ^~
tests\integration\test_sessions_infrastructure_integration.py:99:27: error:
"type[SessionPhase]" has no attribute "ACTIVE"  [attr-defined]
                session_phase=SessionPhase.ACTIVE,
                              ^~~~~~~~~~~~~~~~~~~
tests\integration\test_sessions_infrastructure_integration.py:101:24: error:
Argument "confidence" to "SessionAnalysisResult" has incompatible type "float";
expected "ConfidenceScore"  [arg-type]
                confidence=0.85,
                           ^~~~
tests\integration\test_sessions_infrastructure_integration.py:102:21: error:
Missing keys ("volume_change_percent", "volatility_change_percent",
"price_direction_bias", "momentum_strength", "false_breakout_probability",
"reversal_probability", "trend_continuation_probability",
"influence_duration_minutes", "peak_influence_time_minutes", "spread_impact",
"liquidity_impact", "correlation_with_other_sessions") for TypedDict
"SessionMetrics"  [typeddict-item]
                metrics=SessionMetrics(
                        ^
tests\integration\test_sessions_infrastructure_integration.py:102:21: error:
Extra keys ("volatility", "volume_change", "price_change", "momentum",
"trend_strength") for TypedDict "SessionMetrics"  [typeddict-unknown-key]
                metrics=SessionMetrics(
                        ^
tests\integration\test_sessions_infrastructure_integration.py:109:31: error:
Missing keys ("volatility", "volume", "spread", "liquidity", "momentum",
"trend_strength", "session_intensity") for TypedDict "MarketConditions" 
[typeddict-item]
                market_conditions=MarketConditions(
                                  ^
tests\integration\test_sessions_infrastructure_integration.py:109:31: error:
Extra keys ("liquidity_level", "spread_width", "volatility_regime") for
TypedDict "MarketConditions"  [typeddict-unknown-key]
                market_conditions=MarketConditions(
                                  ^
tests\integration\test_sessions_infrastructure_integration.py:110:31: error:
Incompatible types (expression has type "str", TypedDict item "market_regime"
has type "MarketRegime")  [typeddict-item]
                    market_regime="trending",
                                  ^~~~~~~~~~
tests\integration\test_sessions_infrastructure_integration.py:116:17: error:
Dict entry 0 has incompatible type "str": "str"; expected "str": "float" 
[dict-item]
                    "price_direction": "up",
                    ^~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_sessions_infrastructure_integration.py:120:26: error:
Argument "risk_factors" to "SessionAnalysisResult" has incompatible type
"dict[str, str]"; expected "list[str]"  [arg-type]
                risk_factors={
                             ^
application\di_container_refactored.py:44:1: error: Module "domain.evolution"
has no attribute "StrategyOptimizer"  [attr-defined]
    from domain.evolution import (
    ^
application\di_container_refactored.py:129:1: error: Module
"infrastructure.market_profiles" has no attribute "AnalysisConfig" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
application\di_container_refactored.py:129:1: error: Module
"infrastructure.market_profiles" has no attribute "BehaviorHistoryRepository" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
application\di_container_refactored.py:129:1: error: Module
"infrastructure.market_profiles" has no attribute "MarketMakerStorage" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
application\di_container_refactored.py:129:1: error: Module
"infrastructure.market_profiles" has no attribute "PatternAnalyzer"; maybe
"IPatternAnalyzer"?  [attr-defined]
    from infrastructure.market_profiles import (
    ^
application\di_container_refactored.py:129:1: error: Module
"infrastructure.market_profiles" has no attribute "PatternMemoryRepository" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
application\di_container_refactored.py:129:1: error: Module
"infrastructure.market_profiles" has no attribute "SimilarityCalculator" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
application\di_container_refactored.py:129:1: error: Module
"infrastructure.market_profiles" has no attribute "StorageConfig" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
application\di_container_refactored.py:129:1: error: Module
"infrastructure.market_profiles" has no attribute "SuccessRateAnalyzer" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionAnalytics"  [attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionCache"  [attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionMetricsCalculator" 
[attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionMonitor"  [attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionOptimizer"  [attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionPatternRecognizer" 
[attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionPredictor"  [attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionRepository"  [attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionRiskAnalyzer"  [attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionTransitionManager" 
[attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:152:1: error: Module
"infrastructure.sessions" has no attribute "SessionValidator"  [attr-defined]
    from infrastructure.sessions import (
    ^
application\di_container_refactored.py:214:9: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
application\di_container_refactored.py:263:23: error: Need type annotation for
"spread_analyzer"  [var-annotated]
        spread_analyzer = providers.Singleton(SpreadAnalyzer, config=confi...
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\di_container_refactored.py:263:43: error: Name "SpreadAnalyzer" is
not defined  [name-defined]
        spread_analyzer = providers.Singleton(SpreadAnalyzer, config=confi...
                                              ^~~~~~~~~~~~~~
application\di_container_refactored.py:264:26: error: Need type annotation for
"liquidity_analyzer"  [var-annotated]
        liquidity_analyzer = providers.Singleton(
                             ^
application\di_container_refactored.py:265:9: error: Name "LiquidityAnalyzer"
is not defined  [name-defined]
            LiquidityAnalyzer, config=config.liquidity_analyzer
            ^~~~~~~~~~~~~~~~~
application\di_container_refactored.py:267:20: error: Need type annotation for
"ml_predictor"  [var-annotated]
        ml_predictor = providers.Singleton(MLPredictor, config=config.ml_p...
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\di_container_refactored.py:267:40: error: Name "MLPredictor" is not
defined  [name-defined]
        ml_predictor = providers.Singleton(MLPredictor, config=config.ml_p...
                                           ^~~~~~~~~~~
application\di_container_refactored.py:315:26: error: Need type annotation for
"session_repository"  [var-annotated]
        session_repository = providers.Singleton(
                             ^
application\di_container_refactored.py:318:21: error: Need type annotation for
"session_cache"  [var-annotated]
        session_cache = providers.Singleton(SessionCache, max_size=1000, t...
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\di_container_refactored.py:319:25: error: Need type annotation for
"session_validator"  [var-annotated]
        session_validator = providers.Singleton(SessionValidator)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:320:34: error: Need type annotation for
"session_metrics_calculator"  [var-annotated]
        session_metrics_calculator = providers.Singleton(SessionMetricsCal...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\di_container_refactored.py:321:34: error: Need type annotation for
"session_pattern_recognizer"  [var-annotated]
        session_pattern_recognizer = providers.Singleton(SessionPatternRec...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\di_container_refactored.py:322:34: error: Need type annotation for
"session_transition_manager"  [var-annotated]
        session_transition_manager = providers.Singleton(SessionTransition...
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\di_container_refactored.py:323:25: error: Need type annotation for
"session_predictor"  [var-annotated]
        session_predictor = providers.Singleton(SessionPredictor)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:324:25: error: Need type annotation for
"session_optimizer"  [var-annotated]
        session_optimizer = providers.Singleton(SessionOptimizer)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:325:23: error: Need type annotation for
"session_monitor"  [var-annotated]
        session_monitor = providers.Singleton(SessionMonitor)
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:326:25: error: Need type annotation for
"session_analytics"  [var-annotated]
        session_analytics = providers.Singleton(SessionAnalytics)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:327:29: error: Need type annotation for
"session_risk_analyzer"  [var-annotated]
        session_risk_analyzer = providers.Singleton(SessionRiskAnalyzer)
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:428:28: error: Need type annotation for
"market_maker_storage"  [var-annotated]
        market_maker_storage = providers.Singleton(
                               ^
application\di_container_refactored.py:431:33: error: Need type annotation for
"pattern_memory_repository"  [var-annotated]
        pattern_memory_repository = providers.Singleton(PatternMemoryRepos...
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\di_container_refactored.py:432:35: error: Need type annotation for
"behavior_history_repository"  [var-annotated]
        behavior_history_repository = providers.Singleton(BehaviorHistoryR...
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\di_container_refactored.py:433:24: error: Need type annotation for
"pattern_analyzer"  [var-annotated]
        pattern_analyzer = providers.Singleton(
                           ^
application\di_container_refactored.py:436:29: error: Need type annotation for
"similarity_calculator"  [var-annotated]
        similarity_calculator = providers.Singleton(SimilarityCalculator)
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:437:29: error: Need type annotation for
"success_rate_analyzer"  [var-annotated]
        success_rate_analyzer = providers.Singleton(SuccessRateAnalyzer)
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:445:26: error: Need type annotation for
"strategy_optimizer"  [var-annotated]
        strategy_optimizer = providers.Singleton(StrategyOptimizer)
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:457:38: error: Need type annotation for
"risk_analysis_service_external"  [var-annotated]
        risk_analysis_service_external = providers.Singleton(RiskAnalysisS...
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
application\di_container_refactored.py:457:58: error: Name
"RiskAnalysisServiceAdapter" is not defined  [name-defined]
    ..._analysis_service_external = providers.Singleton(RiskAnalysisServiceAd...
                                                        ^~~~~~~~~~~~~~~~~~~~~...
application\di_container_refactored.py:458:43: error: Need type annotation for
"technical_analysis_service_external"  [var-annotated]
        technical_analysis_service_external = providers.Singleton(
                                              ^
application\di_container_refactored.py:459:9: error: Name
"TechnicalAnalysisServiceAdapter" is not defined  [name-defined]
            TechnicalAnalysisServiceAdapter
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:530:13: error: Name
"RiskAnalysisServiceAdapter" is not defined  [name-defined]
                RiskAnalysisServiceAdapter: "risk_analysis_service_externa...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
application\di_container_refactored.py:531:13: error: Name
"TechnicalAnalysisServiceAdapter" is not defined  [name-defined]
                TechnicalAnalysisServiceAdapter: "technical_analysis_servi...
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main.py:59:1: error: Module "infrastructure.simulation.backtester" has no
attribute "Backtester"  [attr-defined]
    from infrastructure.simulation.backtester import Backtester
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main.py:118:5: error: Incompatible import of "MonitoringDashboard" (imported
name has type "type[shared.monitoring_dashboard.MonitoringDashboard]", local
name has type
"type[infrastructure.monitoring.monitoring_dashboard.MonitoringDashboard]") 
[assignment]
        from shared.monitoring_dashboard import MonitoringDashboard
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main.py:119:5: error: Module "shared.exception_handler" has no attribute
"ExceptionHandler"; maybe "SafeExceptionHandler"?  [attr-defined]
        from shared.exception_handler import ExceptionHandler
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\unit\test_module_integrations.py:8:1: error: Module
"domain.entities.trading" has no attribute "Order"; maybe "OrderId"? 
[attr-defined]
    from domain.entities.trading import Signal, SignalType, Order, OrderSi...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\unit\test_module_integrations.py:13:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\test_symbols_integration.py:7:1: error: Module
"domain.symbols" has no attribute "SymbolCache"; maybe "MemorySymbolCache" or
"SymbolCacheManager"?  [attr-defined]
    from domain.symbols import (
    ^
tests\integration\test_symbols_integration.py:13:1: error: Module
"application.use_cases.trading_orchestrator" has no attribute
"DefaultTradingOrchestratorUseCase"  [attr-defined]
    from application.use_cases.trading_orchestrator import DefaultTradingO...
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\test_symbols_integration.py:34:16: error: Unexpected keyword
argument "volume" for "SymbolProfile"  [call-arg]
            return SymbolProfile(
                   ^
tests\integration\test_symbols_integration.py:34:16: error: Unexpected keyword
argument "spread" for "SymbolProfile"  [call-arg]
            return SymbolProfile(
                   ^
tests\integration\test_symbols_integration.py:34:16: error: Unexpected keyword
argument "volatility" for "SymbolProfile"  [call-arg]
            return SymbolProfile(
                   ^
tests\integration\test_symbols_integration.py:34:16: error: Unexpected keyword
argument "orderbook_metrics" for "SymbolProfile"; did you mean
"order_book_metrics"?  [call-arg]
            return SymbolProfile(
                   ^
tests\integration\test_symbols_integration.py:37:26: error: "type[MarketPhase]"
has no attribute "BULLISH"  [attr-defined]
                market_phase=MarketPhase.BULLISH,
                             ^~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:124:85: error:
"type[MarketPhase]" has no attribute "BULLISH"  [attr-defined]
    ...er.classify_market_phase = AsyncMock(return_value=MarketPhase.BULLISH)
                                                         ^~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:148:25: error:
"type[MarketPhase]" has no attribute "BULLISH"  [attr-defined]
            assert phase == MarketPhase.BULLISH
                            ^~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:170:17: error: Incompatible types
in "await" (actual type "MarketPhaseResult", expected type "Awaitable[Any]") 
[misc]
            phase = await classifier.classify_market_phase(symbol)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:170:56: error: Argument 1 to
"classify_market_phase" of "MarketPhaseClassifier" has incompatible type "str";
expected "MarketDataFrame"  [arg-type]
            phase = await classifier.classify_market_phase(symbol)
                                                           ^~~~~~
tests\integration\test_symbols_integration.py:173:17: error: Incompatible types
in "await" (actual type "OpportunityScoreResult", expected type
"Awaitable[Any]")  [misc]
            score = await calculator.calculate_opportunity_score(symbol)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:173:23: error: Missing positional
arguments "market_data", "order_book" in call to "calculate_opportunity_score"
of "OpportunityScoreCalculator"  [call-arg]
            score = await calculator.calculate_opportunity_score(symbol)
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:186:9: error: Cannot assign to a
method  [method-assign]
            selector.get_detailed_analysis = AsyncMock(return_value=mock_d...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:201:52: error:
"type[MarketPhase]" has no attribute "BULLISH"  [attr-defined]
            assert mock_symbol_profile.market_phase == MarketPhase.BULLISH
                                                       ^~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:203:16: error: "SymbolProfile"
has no attribute "volume"  [attr-defined]
            assert mock_symbol_profile.volume == 1000.0
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:204:16: error: "SymbolProfile"
has no attribute "spread"  [attr-defined]
            assert mock_symbol_profile.spread == 0.001
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:205:16: error: "SymbolProfile"
has no attribute "volatility"  [attr-defined]
            assert mock_symbol_profile.volatility == 0.15
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_symbols_integration.py:209:16: error: "SymbolProfile"
has no attribute "orderbook_metrics"; maybe "order_book_metrics"? 
[attr-defined]
            assert mock_symbol_profile.orderbook_metrics is not None
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionRepository"  [attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionCache"  [attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionValidator"  [attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionMetricsCalculator" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionPatternRecognizer" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionTransitionManager" 
[attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionPredictor"  [attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionOptimizer"  [attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionMonitor"  [attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionAnalytics"  [attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:15:1: error: Module
"infrastructure.sessions" has no attribute "SessionRiskAnalyzer"  [attr-defined]
    from infrastructure.sessions import (
    ^
tests\integration\test_sessions_di_integration.py:61:35: error: Name "pd" is
not defined  [name-defined]
        def mock_market_data(self) -> pd.DataFrame:
                                      ^
tests\integration\test_sessions_di_integration.py:63:16: error: Name "pd" is
not defined  [name-defined]
            return pd.DataFrame({
                   ^~
tests\integration\test_sessions_di_integration.py:64:26: error: Name "pd" is
not defined  [name-defined]
                'timestamp': pd.date_range(start='2024-01-01', periods=100...
                             ^~
tests\integration\test_sessions_di_integration.py:76:27: error:
"type[SessionPhase]" has no attribute "ACTIVE"  [attr-defined]
                session_phase=SessionPhase.ACTIVE,
                              ^~~~~~~~~~~~~~~~~~~
tests\integration\test_sessions_di_integration.py:78:24: error: Argument
"confidence" to "SessionAnalysisResult" has incompatible type "float"; expected
"ConfidenceScore"  [arg-type]
                confidence=0.85,
                           ^~~~
tests\integration\test_sessions_di_integration.py:79:21: error: Missing keys
("volume_change_percent", "volatility_change_percent", "price_direction_bias",
"momentum_strength", "false_breakout_probability", "reversal_probability",
"trend_continuation_probability", "influence_duration_minutes",
"peak_influence_time_minutes", "spread_impact", "liquidity_impact",
"correlation_with_other_sessions") for TypedDict "SessionMetrics" 
[typeddict-item]
                metrics=SessionMetrics(
                        ^
tests\integration\test_sessions_di_integration.py:79:21: error: Extra keys
("volatility", "volume_change", "price_change", "momentum", "trend_strength")
for TypedDict "SessionMetrics"  [typeddict-unknown-key]
                metrics=SessionMetrics(
                        ^
tests\integration\test_sessions_di_integration.py:86:31: error: Missing keys
("volatility", "volume", "spread", "liquidity", "momentum", "trend_strength",
"session_intensity") for TypedDict "MarketConditions"  [typeddict-item]
                market_conditions=MarketConditions(
                                  ^
tests\integration\test_sessions_di_integration.py:86:31: error: Extra keys
("liquidity_level", "spread_width", "volatility_regime") for TypedDict
"MarketConditions"  [typeddict-unknown-key]
                market_conditions=MarketConditions(
                                  ^
tests\integration\test_sessions_di_integration.py:87:31: error: Incompatible
types (expression has type "str", TypedDict item "market_regime" has type
"MarketRegime")  [typeddict-item]
                    market_regime="trending",
                                  ^~~~~~~~~~
tests\integration\test_sessions_di_integration.py:93:17: error: Dict entry 0
has incompatible type "str": "str"; expected "str": "float"  [dict-item]
                    "price_direction": "up",
                    ^~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_sessions_di_integration.py:97:26: error: Argument
"risk_factors" to "SessionAnalysisResult" has incompatible type
"dict[str, str]"; expected "list[str]"  [arg-type]
                risk_factors={
                             ^
tests\integration\test_market_profiles_integration.py:7:1: error: Module
"infrastructure.market_profiles" has no attribute "MarketMakerStorage" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
tests\integration\test_market_profiles_integration.py:7:1: error: Module
"infrastructure.market_profiles" has no attribute "PatternMemoryRepository" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
tests\integration\test_market_profiles_integration.py:7:1: error: Module
"infrastructure.market_profiles" has no attribute "BehaviorHistoryRepository" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
tests\integration\test_market_profiles_integration.py:7:1: error: Module
"infrastructure.market_profiles" has no attribute "PatternAnalyzer"; maybe
"IPatternAnalyzer"?  [attr-defined]
    from infrastructure.market_profiles import (
    ^
tests\integration\test_market_profiles_integration.py:7:1: error: Module
"infrastructure.market_profiles" has no attribute "SimilarityCalculator" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
tests\integration\test_market_profiles_integration.py:7:1: error: Module
"infrastructure.market_profiles" has no attribute "SuccessRateAnalyzer" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
tests\integration\test_market_profiles_integration.py:7:1: error: Module
"infrastructure.market_profiles" has no attribute "StorageConfig" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
tests\integration\test_market_profiles_integration.py:7:1: error: Module
"infrastructure.market_profiles" has no attribute "AnalysisConfig" 
[attr-defined]
    from infrastructure.market_profiles import (
    ^
tests\integration\test_market_profiles_integration.py:31:16: error: Unexpected
keyword argument "market_profiles_enabled" for "ContainerConfig"  [call-arg]
            return ContainerConfig(
                   ^
tests\integration\test_market_profiles_integration.py:31:16: error: Unexpected
keyword argument "pattern_analysis_enabled" for "ContainerConfig"; did you mean
"technical_analysis_enabled"?  [call-arg]
            return ContainerConfig(
                   ^
tests\integration\test_market_profiles_integration.py:31:16: error: Unexpected
keyword argument "storage_enabled" for "ContainerConfig"  [call-arg]
            return ContainerConfig(
                   ^
tests\integration\test_market_profiles_integration.py:68:35: error: Extra keys
("depth_imbalance", "flow_imbalance") for TypedDict "MarketMicrostructure" 
[typeddict-unknown-key]
                market_microstructure=MarketMicrostructure({
                                      ^
tests\integration\test_market_profiles_integration.py:75:20: error: Argument
"symbol" to "MarketMakerPattern" has incompatible type "str"; expected "Symbol" 
[arg-type]
                symbol="BTCUSDT",
                       ^~~~~~~~~
tests\integration\test_market_profiles_integration.py:79:21: error: Extra keys
("market_regime", "session") for TypedDict "PatternContext" 
[typeddict-unknown-key]
                context={"market_regime": "trending", "session": "asian"}
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_market_profiles_integration.py:141:20: error: Argument
"symbol" to "MarketMakerPattern" has incompatible type "str"; expected "Symbol" 
[arg-type]
                symbol="BTCUSDT",
                       ^~~~~~~~~
tests\integration\test_market_profiles_integration.py:145:21: error: Extra keys
("market_regime", "session") for TypedDict "PatternContext" 
[typeddict-unknown-key]
                context={"market_regime": "trending", "session": "asian"}
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_market_profiles_integration.py:163:18: error: Unexpected
keyword argument "price_change_1h" for "PatternResult"; did you mean
"price_change_15min", "price_change_5min", or "price_change_30min"?  [call-arg]
            result = PatternResult(
                     ^
tests\integration\test_market_profiles_integration.py:163:18: error: Unexpected
keyword argument "execution_time" for "PatternResult"  [call-arg]
            result = PatternResult(
                     ^
tests\integration\test_market_profiles_integration.py:163:18: error: Unexpected
keyword argument "confidence" for "PatternResult"  [call-arg]
            result = PatternResult(
                     ^
tests\integration\test_market_profiles_integration.py:184:9: error: Module
"infrastructure.market_profiles.models" has no attribute
"MarketMakerPatternType"  [attr-defined]
            from infrastructure.market_profiles.models import BehaviorReco...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\test_market_profiles_integration.py:223:9: error: Module
"infrastructure.market_profiles.models" has no attribute
"MarketMakerPatternType"  [attr-defined]
            from infrastructure.market_profiles.models import BehaviorReco...
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
tests\integration\test_market_profiles_integration.py:270:24: error: Argument
"symbol" to "MarketMakerPattern" has incompatible type "str"; expected "Symbol" 
[arg-type]
                    symbol=f"BTCUSDT_{i}",
                           ^~~~~~~~~~~~~~
tests\integration\test_market_profiles_integration.py:274:25: error: Extra key
"test" for TypedDict "PatternContext"  [typeddict-unknown-key]
                    context={"test": True}
                            ^~~~~~~~~~~~~~
tests\integration\test_market_profiles_integration.py:300:16: error:
"ContainerConfig" has no attribute "market_profiles_enabled"  [attr-defined]
            assert container_config.market_profiles_enabled is True
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_market_profiles_integration.py:301:16: error:
"ContainerConfig" has no attribute "pattern_analysis_enabled"; maybe
"technical_analysis_enabled"?  [attr-defined]
            assert container_config.pattern_analysis_enabled is True
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_market_profiles_integration.py:302:16: error:
"ContainerConfig" has no attribute "storage_enabled"  [attr-defined]
            assert container_config.storage_enabled is True
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_market_profiles_integration.py:323:24: error: Argument
"symbol" to "MarketMakerPattern" has incompatible type "str"; expected "Symbol" 
[arg-type]
                    symbol=f"BTCUSDT_{i}",
                           ^~~~~~~~~~~~~~
tests\integration\test_market_profiles_integration.py:327:25: error: Extra key
"concurrent_test" for TypedDict "PatternContext"  [typeddict-unknown-key]
                    context={"concurrent_test": True}
                            ^~~~~~~~~~~~~~~~~~~~~~~~~
tests\integration\test_domain_services_integration.py:8:1: error: Module
"domain.services.correlation_chain" has no attribute "CorrelationChainService";
maybe "CorrelationChain" or "ICorrelationChain"?  [attr-defined]
    from domain.services.correlation_chain import CorrelationChainService
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests\e2e\test_orchestrator_session_integration.py:13:5: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\e2e\test_orchestrator_session_integration.py:14:5: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked]
tests\integration\test_evolution_integration.py:12:1: error: Module "main" has
no attribute "Syntra"  [attr-defined]
    from main import Syntra
    ^~~~~~~~~~~~~~~~~~~~~~~
scripts\start_atb.py:17:1: error: Module "main" has no attribute "Syntra" 
[attr-defined]
    from main import Syntra
    ^~~~~~~~~~~~~~~~~~~~~~~
Found 5234 errors in 393 files (checked 1092 source files)
