

infrastructure\external_services\exchanges\base_exchange_service.py:128: error: Statement is unreachable  [unreachable]
infrastructure\external_services\exchange.py:88: error: Statement is unreachable  [unreachable]
infrastructure\external_services\exchange.py:293: error: Statement is unreachable  [unreachable]
infrastructure\external_services\exchange.py:355: error: Statement is unreachable  [unreachable]
infrastructure\external_services\exchange.py:561: error: Returning Any from function declared to return "dict[str, Any] | None"  [no-any-return]
infrastructure\external_services\exchanges\bybit_exchange_service.py:33: error: Statement is unreachable  [unreachable]
infrastructure\external_services\exchanges\binance_exchange_service.py:33: error: Statement is unreachable  [unreachable]
domain\symbols\market_phase_classifier.py:45: error: Missing positional arguments "config_key", "config_value" in call to "ConfigurationError"  [call-arg]
domain\symbols\market_phase_classifier.py:47: error: Missing positional arguments "config_key", "config_value" in call to "ConfigurationError"  [call-arg]
domain\symbols\market_phase_classifier.py:49: error: Missing positional arguments "config_key", "config_value" in call to "ConfigurationError"  [call-arg]
domain\symbols\market_phase_classifier.py:51: error: Missing positional arguments "config_key", "config_value" in call to "ConfigurationError"  [call-arg]
domain\symbols\market_phase_classifier.py:53: error: Missing positional arguments "config_key", "config_value" in call to "ConfigurationError"  [call-arg]
domain\symbols\market_phase_classifier.py:55: error: Missing positional arguments "config_key", "config_value" in call to "ConfigurationError"  [call-arg]
domain\symbols\market_phase_classifier.py:57: error: Missing positional arguments "config_key", "config_value" in call to "ConfigurationError"  [call-arg]
domain\symbols\market_phase_classifier.py:59: error: Missing positional arguments "config_key", "config_value" in call to "ConfigurationError"  [call-arg]
domain\symbols\market_phase_classifier.py:104: error: Missing key "metadata" for TypedDict "MarketPhaseResult"  [typeddict-item]
domain\symbols\market_phase_classifier.py:104: error: Extra keys ("price_structure", "volume_analysis", "volatility_analysis", "timestamp") for TypedDict "MarketPhaseResult"  [typeddict-unknown-key]
domain\symbols\market_phase_classifier.py:106: error: Incompatible types (expression has type "float", TypedDict item "confidence" has type "ConfidenceValue")  [typeddict-item]
domain\symbols\market_phase_classifier.py:119: error: Missing key "metadata" for TypedDict "MarketPhaseResult"  [typeddict-item]
domain\symbols\market_phase_classifier.py:119: error: Extra keys ("price_structure", "volume_analysis", "volatility_analysis", "timestamp") for TypedDict "MarketPhaseResult"  [typeddict-unknown-key]
domain\symbols\market_phase_classifier.py:121: error: Incompatible types (expression has type "float", TypedDict item "confidence" has type "ConfidenceValue")  [typeddict-item]
domain\symbols\market_phase_classifier.py:162: error: No overload variant of "concat" matches argument types "list[object]", "int"  [call-overload]
domain\symbols\market_phase_classifier.py:162: note: Possible overload variants:
domain\symbols\market_phase_classifier.py:162: note:     def [HashableT1: Hashable, HashableT2: Hashable, HashableT3: Hashable, HashableT4: Hashable] concat(objs: Iterable[DataFrame] | Mapping[HashableT1, DataFrame], *, axis: Literal['index', 0] | Literal['columns', 1] = ..., join: Literal['inner', 'outer'] = ..., ignore_index: bool = ..., keys: Iterable[HashableT2] = ..., levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] = ..., names: list[HashableT4] | None = ..., verify_integrity: bool = ..., sort: bool = ..., copy: bool = ...) -> DataFrame
domain\symbols\market_phase_classifier.py:162: note:     def [HashableT1: Hashable, HashableT2: Hashable, HashableT3: Hashable, HashableT4: Hashable] concat(objs: Iterable[Series[Any]] | Mapping[HashableT1, Series[Any]], *, axis: Literal['index', 0] = ..., join: Literal['inner', 'outer'] = ..., ignore_index: bool = ..., keys: Iterable[HashableT2] = ..., levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] = ..., names: list[HashableT4] | None = ..., verify_integrity: bool = ..., sort: bool = ..., copy: bool = ...) -> Series[Any]
domain\symbols\market_phase_classifier.py:162: note:     def [HashableT1: Hashable, HashableT2: Hashable, HashableT3: Hashable, HashableT4: Hashable] concat(objs: Iterable[Series[Any] | DataFrame] | Mapping[HashableT1, Series[Any] | DataFrame], *, axis: Literal['index', 0] | Literal['columns', 1] = ..., join: Literal['inner', 'outer'] = ..., ignore_index: bool = ..., keys: Iterable[HashableT2] = ..., levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] = ..., names: list[HashableT4] | None = ..., verify_integrity: bool = ..., sort: bool = ..., copy: bool = ...) -> DataFrame
domain\symbols\market_phase_classifier.py:162: note:     def [HashableT1: Hashable, HashableT2: Hashable, HashableT3: Hashable, HashableT4: Hashable] concat(objs: Iterable[None] | Mapping[HashableT1, None], *, axis: Literal['index', 0] | Literal['columns', 1] = ..., join: Literal['inner', 'outer'] = ..., ignore_index: bool = ..., keys: Iterable[HashableT2] = ..., levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] = ..., names: list[HashableT4] | None = ..., verify_integrity: bool = ..., sort: bool = ..., copy: bool = ...) -> Never
domain\symbols\market_phase_classifier.py:162: note:     def [HashableT1: Hashable, HashableT2: Hashable, HashableT3: Hashable, HashableT4: Hashable] concat(objs: Iterable[DataFrame | None] | Mapping[HashableT1, DataFrame | None], *, axis: Literal['index', 0] | Literal['columns', 1] = ..., join: Literal['inner', 'outer'] = ..., ignore_index: bool = ..., keys: Iterable[HashableT2] = ..., levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] = ..., names: list[HashableT4] | None = ..., verify_integrity: bool = ..., sort: bool = ..., copy: bool = ...) -> DataFrame
domain\symbols\market_phase_classifier.py:162: note:     def [HashableT1: Hashable, HashableT2: Hashable, HashableT3: Hashable, HashableT4: Hashable] concat(objs: Iterable[Series[Any] | None] | Mapping[HashableT1, Series[Any] | None], *, axis: Literal['index', 0] = ..., join: Literal['inner', 'outer'] = ..., ignore_index: bool = ..., keys: Iterable[HashableT2] = ..., levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] = ..., names: list[HashableT4] | None = ..., verify_integrity: bool = ..., sort: bool = ..., copy: bool = ...) -> Series[Any]
domain\symbols\market_phase_classifier.py:162: note:     def [HashableT1: Hashable, HashableT2: Hashable, HashableT3: Hashable, HashableT4: Hashable] concat(objs: Iterable[Series[Any] | DataFrame | None] | Mapping[HashableT1, Series[Any] | DataFrame | None], *, axis: Literal['index', 0] | Literal['columns', 1] = ..., join: Literal['inner', 'outer'] = ..., ignore_index: bool = ..., keys: Iterable[HashableT2] = ..., levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] = ..., names: list[HashableT4] | None = ..., verify_integrity: bool = ..., sort: bool = ..., copy: bool = ...) -> DataFrame
domain\symbols\market_phase_classifier.py:199: error: Incompatible types in assignment (expression has type "float | None", target has type "float")  [assignment]
domain\symbols\market_phase_classifier.py:200: error: Incompatible types in assignment (expression has type "float | None", target has type "float")  [assignment]
domain\symbols\market_phase_classifier.py:285: error: Argument "key" to "max" has incompatible type overloaded function; expected "Callable[[MarketPhase], SupportsDunderLT[Any] | SupportsDunderGT[Any]]"  [arg-type]
domain\symbols\market_phase_classifier.py:535: error: Statement is unreachable  [unreachable]
domain\symbols\market_phase_classifier.py:582: error: Statement is unreachable  [unreachable]
infrastructure\market_data\base_connector.py:161: error: Statement is unreachable  [unreachable]
infrastructure\market_data\base_connector.py:174: error: Statement is unreachable  [unreachable]
domain\strategies\utils.py:26: error: Statement is unreachable  [unreachable]
domain\strategies\utils.py:50: error: Statement is unreachable  [unreachable]
domain\strategies\utils.py:243: error: Returning Any from function declared to return "Decimal"  [no-any-return]
domain\strategies\utils.py:263: error: Returning Any from function declared to return "Decimal"  [no-any-return]
domain\strategies\utils.py:280: error: Statement is unreachable  [unreachable]
domain\strategies\utils.py:350: error: Incompatible types in assignment (expression has type "str", target has type "Decimal")  [assignment]
domain\strategies\utils.py:354: error: Name "InvalidOperation" is not defined  [name-defined]
domain\strategies\utils.py:355: error: Incompatible types in assignment (expression has type "str", target has type "Decimal")  [assignment]
domain\services\risk_analysis.py:343: error: Incompatible types in assignment (expression has type "DataFrame", variable has type "Series[Any]")  [assignment]
domain\services\risk_analysis.py:382: error: No overload variant of "minimize" matches argument types "Callable[[ndarray[Any, Any]], float]", "ndarray[Any, dtype[Any]]", "str", "list[tuple[float, float]]", "list[dict[str, Any]]", "dict[str, bool]"  [call-overload]
domain\services\risk_analysis.py:382: note: Possible overload variants:
domain\services\risk_analysis.py:382: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], float | floating[Any] | integer[Any] | bool_], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...] = ..., method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None = ..., jac: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | Literal['2-point', '3-point', 'cs'] | Literal[False, 0] | None = ..., hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
domain\services\risk_analysis.py:382: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], tuple[float | floating[Any] | integer[Any] | bool_, CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...], method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None, jac: Literal[True, 1], hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
domain\services\risk_analysis.py:382: note:     def minimize(fun: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], tuple[float | floating[Any] | integer[Any] | bool_, CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]], x0: float | floating[Any] | integer[Any] | bool_ | CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]], args: tuple[object, ...] = ..., method: Literal['Nelder-Mead', 'nelder-mead', 'Powell', 'powell', 'CG', 'cg', 'BFGS', 'bfgs', 'Newton-CG', 'newton-cg', 'L-BFGS-B', 'l-bfgs-b', 'TNC', 'tnc', 'COBYLA', 'cobyla', 'COBYQA', 'cobyqa', 'SLSQP', 'slsqp', 'Trust-Constr', 'trust-constr', 'Dogleg', 'dogleg', 'Trust-NCG', 'trust-ncg', 'Trust-Exact', 'trust-exact', 'Trust-Krylov', 'trust-krylov'] | _MinimizeMethodFun | None = ..., *, jac: Literal[True, 1], hess: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]]] | Literal['2-point', '3-point', 'cs'] | HessianUpdateStrategy | None = ..., hessp: Callable[[ndarray[tuple[int], dtype[floating[_64Bit]]], ndarray[tuple[int], dtype[floating[_64Bit]]], VarArg(Any), KwArg(Any)], CanArrayND[floating[Any] | integer[Any] | bool_, tuple[int, ...]] | Sequence[float | floating[Any] | integer[Any] | bool_ | CanArray0D[floating[Any] | integer[Any] | bool_]]] | None = ..., bounds: Sequence[tuple[float | floating[Any] | integer[Any] | bool_ | None, float | floating[Any] | integer[Any] | bool_ | None]] | Bounds | None = ..., constraints: LinearConstraint | NonlinearConstraint | _ConstraintDict | Sequence[LinearConstraint | NonlinearConstraint | _ConstraintDict] = ..., tol: float | floating[Any] | integer[Any] | bool_ | None = ..., callback: _CallbackResult | _CallbackVector | None = ..., options: _MinimizeOptions | None = ...) -> OptimizeResult
domain\entities\strategy_execution.py:254: error: Subclass of "str" and "dict[Any, Any]" cannot exist: would have incompatible method signatures  [unreachable]
domain\entities\strategy_execution.py:255: error: Statement is unreachable  [unreachable]
domain\entities\strategy_execution.py:265: error: Subclass of "str" and "dict[Any, Any]" cannot exist: would have incompatible method signatures  [unreachable]
domain\entities\strategy_execution.py:266: error: Statement is unreachable  [unreachable]
infrastructure\external_services\ml_services.py:91: error: Unsupported operand types for > ("Series[type[object]]" and "float")  [operator]
infrastructure\external_services\ml_services.py:92: error: Unsupported operand types for < ("Series[type[object]]" and "float")  [operator]
infrastructure\external_services\ml_services.py:148: error: Incompatible types in assignment (expression has type "Series[Timestamp]", variable has type "TimestampSeries")  [assignment]
infrastructure\external_services\ml_services.py:165: error: Returning Any from function declared to return "Series[Any]"  [no-any-return]
infrastructure\external_services\ml_services.py:433: error: Unsupported operand types for < ("int" and "None")  [operator]
infrastructure\external_services\ml_services.py:433: note: Left operand is of type "float | None"
infrastructure\external_services\ml_services.py:434: error: Unsupported operand types for / ("float" and "None")  [operator]
infrastructure\external_services\ml_services.py:434: note: Right operand is of type "float | None"
infrastructure\external_services\ml_services.py:435: error: Unsupported operand types for - ("None" and "int")  [operator]
infrastructure\external_services\ml_services.py:435: note: Left operand is of type "float | None"
infrastructure\external_services\ml_services.py:486: error: Name "param_grid" already defined on line 480  [no-redef]
infrastructure\external_services\ml_services.py:570: error: Returning Any from function declared to return "dict[str, Any]"  [no-any-return]
infrastructure\external_services\ml_services.py:601: error: Unsupported operand types for < ("int" and "None")  [operator]
infrastructure\external_services\ml_services.py:601: note: Left operand is of type "float | None"
infrastructure\external_services\ml_services.py:602: error: Unsupported operand types for / ("float" and "None")  [operator]
infrastructure\external_services\ml_services.py:602: note: Right operand is of type "float | None"
infrastructure\external_services\ml_services.py:603: error: Unsupported operand types for - ("None" and "int")  [operator]
infrastructure\external_services\ml_services.py:603: note: Left operand is of type "float | None"
infrastructure\external_services\ml_services.py:727: error: Incompatible types in "await" (actual type "Any | None", expected type "Awaitable[Any]")  [misc]
infrastructure\data\price_pattern_extractor.py:755: error: Incompatible types in assignment (expression has type "ndarray[Any, dtype[Any]]", variable has type "Series[Any]")  [assignment]
infrastructure\data\price_pattern_extractor.py:760: error: Incompatible types in assignment (expression has type "ndarray[Any, dtype[Any]]", variable has type "Series[Any]")  [assignment]
domain\strategies\validators_fixed.py:116: error: "Signal" has no attribute "symbol"  [attr-defined]
domain\strategies\validators_fixed.py:121: error: Statement is unreachable  [unreachable]
domain\strategies\validators_fixed.py:123: error: Item "None" of "Money | None" has no attribute "value"  [union-attr]
domain\strategies\validators_fixed.py:126: error: "Signal" has no attribute "volume"  [attr-defined]
domain\strategies\validators_fixed.py:144: error: Statement is unreachable  [unreachable]
domain\strategies\validators_fixed.py:176: error: Statement is unreachable  [unreachable]
domain\strategies\validators_fixed.py:195: error: Argument 1 to "RiskLevel" has incompatible type "str"; expected "Decimal"  [arg-type]
domain\strategies\validators_fixed.py:196: error: No overload variant of "list" matches argument type "type[RiskLevel]"  [call-overload]
domain\strategies\validators_fixed.py:196: note: Possible overload variants:
domain\strategies\validators_fixed.py:196: note:     def [_T] list(self) -> list[_T]
domain\strategies\validators_fixed.py:196: note:     def [_T] list(self, Iterable[_T], /) -> list[_T]
domain\strategies\validators_fixed.py:200: error: Cannot use isinstance() with NewType type  [misc]
domain\strategies\validators_fixed.py:202: error: Statement is unreachable  [unreachable]
domain\strategies\validators_fixed.py:222: error: Statement is unreachable  [unreachable]
domain\strategies\validators_fixed.py:238: error: Statement is unreachable  [unreachable]
domain\strategies\validators_fixed.py:271: error: Statement is unreachable  [unreachable]
domain\strategies\validators_fixed.py:290: error: Statement is unreachable  [unreachable]
domain\strategies\validators_fixed.py:296: error: Statement is unreachable  [unreachable]
domain\strategies\validators.py:239: error: Argument 1 to "RiskLevel" has incompatible type "str"; expected "Decimal"  [arg-type]
domain\strategies\validators.py:240: error: No overload variant of "list" matches argument type "type[RiskLevel]"  [call-overload]
domain\strategies\validators.py:240: note: Possible overload variants:
domain\strategies\validators.py:240: note:     def [_T] list(self) -> list[_T]
domain\strategies\validators.py:240: note:     def [_T] list(self, Iterable[_T], /) -> list[_T]
domain\strategies\validators.py:244: error: Cannot use isinstance() with NewType type  [misc]
domain\strategies\validators.py:246: error: Statement is unreachable  [unreachable]
domain\strategies\validators.py:266: error: Statement is unreachable  [unreachable]
domain\strategies\validators.py:282: error: Statement is unreachable  [unreachable]
domain\strategies\validators.py:315: error: Statement is unreachable  [unreachable]
domain\strategies\validators.py:328: error: Statement is unreachable  [unreachable]
domain\strategies\validators.py:335: error: Statement is unreachable  [unreachable]
domain\strategies\validators.py:341: error: Statement is unreachable  [unreachable]
domain\strategies\base_strategy.py:134: error: Statement is unreachable  [unreachable]
domain\protocols\strategy_protocol.py:1197: error: Statement is unreachable  [unreachable]
domain\protocols\repository_protocol.py:993: error: Return type "AbstractAsyncContextManager[TransactionProtocol, bool | None]" of "transaction" incompatible with return type "_AsyncGeneratorContextManager[TransactionProtocol, None]" in supertype "RepositoryProtocol"  [override]
domain\prediction\reversal_predictor.py:357: error: Statement is unreachable  [unreachable]
domain\prediction\reversal_predictor.py:548: error: Unsupported operand types for > ("Series[type[object]]" and "float")  [operator]
domain\prediction\reversal_predictor.py:549: error: Unsupported operand types for < ("Series[type[object]]" and "float")  [operator]
domain\entities\strategy_interface.py:465: error: Incompatible types in assignment (expression has type "float | int", variable has type "int")  [assignment]
infrastructure\repositories\strategy_repository.py:661: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\strategy_repository.py:681: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\strategy_repository.py:697: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\strategy_repository.py:953: error: Unsupported operand types for - ("float" and "datetime")  [operator]
infrastructure\repositories\risk_repository.py:606: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\risk_repository.py:662: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\risk_repository.py:719: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\risk_repository.py:731: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\portfolio_repository.py:736: error: Redundant cast to "Position"  [redundant-cast]
infrastructure\repositories\portfolio_repository.py:777: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\portfolio_repository.py:857: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\portfolio_repository.py:881: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\portfolio_repository.py:941: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\portfolio_repository.py:1001: error: Incompatible types in "yield" (actual type "PostgresPortfolioRepository", expected type "TransactionProtocol")  [misc]
infrastructure\repositories\portfolio_repository.py:1198: error: Returning Any from function declared to return "RepositoryResponse"  [no-any-return]
infrastructure\repositories\portfolio_repository.py:1232: error: Returning Any from function declared to return "PerformanceMetricsDict"  [no-any-return]
infrastructure\repositories\ml_repository.py:276: error: "_AsyncGeneratorContextManager[TransactionProtocol, None]" has no attribute "__aiter__"; maybe "__aexit__"? (not async iterable)  [attr-defined]
infrastructure\repositories\ml_repository.py:492: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\ml_repository.py:494: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\ml_repository.py:496: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\ml_repository.py:655: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\ml_repository.py:752: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\ml_repository.py:770: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\ml_repository.py:785: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\ml_repository.py:809: error: Returning Any from function declared to return "list[Model]"  [no-any-return]
infrastructure\repositories\ml_repository.py:825: error: Returning Any from function declared to return "bool"  [no-any-return]
infrastructure\repositories\market_repository.py:319: error: "_AsyncGeneratorContextManager[TransactionProtocol, None]" has no attribute "__aiter__"; maybe "__aexit__"? (not async iterable)  [attr-defined]
domain\sessions\session_predictor.py:417: error: Statement is unreachable  [unreachable]
domain\sessions\session_predictor.py:418: error: Statement is unreachable  [unreachable]
domain\sessions\session_optimizer.py:348: error: Statement is unreachable  [unreachable]
domain\sessions\session_optimizer.py:350: error: Statement is unreachable  [unreachable]
domain\sessions\session_optimizer.py:402: error: Statement is unreachable  [unreachable]
domain\sessions\session_influence_analyzer.py:518: error: Statement is unreachable  [unreachable]
domain\sessions\session_influence_analyzer.py:519: error: Statement is unreachable  [unreachable]
domain\sessions\session_analyzer.py:289: error: Statement is unreachable  [unreachable]
domain\sessions\session_analyzer.py:290: error: Statement is unreachable  [unreachable]
domain\sessions\implementations.py:246: error: Statement is unreachable  [unreachable]
domain\services\pattern_discovery.py:241: error: Statement is unreachable  [unreachable]
domain\protocols\integration.py:738: error: Argument 1 of "find_by" is incompatible with supertype "RepositoryProtocol"; supertype defines the argument type as "list[QueryFilter]"  [override]
domain\protocols\integration.py:738: note: This violates the Liskov substitution principle
domain\protocols\integration.py:738: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
domain\protocols\integration.py:738: error: Argument 2 of "find_by" is incompatible with supertype "RepositoryProtocol"; supertype defines the argument type as "QueryOptions | None"  [override]
domain\protocols\integration.py:741: error: Argument 1 of "count" is incompatible with supertype "RepositoryProtocol"; supertype defines the argument type as "list[QueryFilter] | None"  [override]
domain\protocols\integration.py:741: note: This violates the Liskov substitution principle
domain\protocols\integration.py:741: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
domain\protocols\integration.py:744: error: Argument 1 of "find_one_by" is incompatible with supertype "RepositoryProtocol"; supertype defines the argument type as "list[QueryFilter]"  [override]
domain\protocols\integration.py:744: note: This violates the Liskov substitution principle
domain\protocols\integration.py:744: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
domain\protocols\integration.py:747: error: Argument 1 of "get_all" is incompatible with supertype "RepositoryProtocol"; supertype defines the argument type as "QueryOptions | None"  [override]
domain\protocols\integration.py:747: note: This violates the Liskov substitution principle
domain\protocols\integration.py:747: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
domain\protocols\integration.py:750: error: Argument 1 of "stream" is incompatible with supertype "RepositoryProtocol"; supertype defines the argument type as "QueryOptions | None"  [override]
domain\protocols\integration.py:750: note: This violates the Liskov substitution principle
domain\protocols\integration.py:750: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
domain\protocols\integration.py:752: error: Statement is unreachable  [unreachable]
infrastructure\repositories\order_repository.py:1225: error: Statement is unreachable  [unreachable]
domain\sessions\session_analyzer_factory.py:40: error: Statement is unreachable  [unreachable]
domain\sessions\session_analyzer_factory.py:148: error: Incompatible types in assignment (expression has type "list[str]", variable has type "MappingProxyType[str, Parameter]")  [assignment]
domain\sessions\session_analyzer_factory.py:151: error: Unexpected keyword argument "session_marker" for "BaseSessionAnalyzer"  [call-arg]
domain\sessions\interfaces.py:200: note: "BaseSessionAnalyzer" defined here
domain\sessions\session_analyzer_factory.py:153: error: Unexpected keyword argument "session_marker" for "BaseSessionAnalyzer"  [call-arg]
domain\sessions\interfaces.py:200: note: "BaseSessionAnalyzer" defined here
domain\sessions\session_analyzer_factory.py:156: error: Missing positional argument "registry" in call to "BaseSessionAnalyzer"  [call-arg]
domain\sessions\factories.py:312: error: Argument "analyzer_factory" to "SessionService" has incompatible type "domain.sessions.interfaces.SessionAnalyzerFactory"; expected "domain.sessions.session_analyzer_factory.SessionAnalyzerFactory"  [arg-type]
Found 158 errors in 38 files (checked 202 source files)
