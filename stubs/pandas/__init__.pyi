"""
Type stubs for pandas library.
"""

from datetime import datetime
from typing import Any, Callable, Dict, List, Optional, Tuple, Union, overload
import numpy as np

# Type aliases
Hashable = Union[str, int, float, bool, datetime]
AnyArray = Any  # np.ndarray simplified

class Timestamp:
    def to_pydatetime(self) -> datetime: ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class Series:
    def __init__(self, data: Any = None, index: Any = None, dtype: Any = None, name: Any = None, copy: bool = False, fastpath: bool = False) -> None: ...
    
    @property
    def iloc(self) -> Any: ...
    @property
    def loc(self) -> Any: ...
    @property
    def index(self) -> Any: ...
    @property
    def dtype(self) -> Any: ...
    @property
    def values(self) -> np.ndarray: ...
    
    def abs(self) -> 'Series': ...
    def sum(self) -> float: ...
    def mean(self) -> float: ...
    def std(self) -> float: ...
    def min(self) -> float: ...
    def max(self) -> float: ...
    def rolling(self, window: int, min_periods: Optional[int] = None, center: bool = False, win_type: Optional[str] = None, on: Optional[str] = None, axis: int = 0, closed: Optional[str] = None, method: str = 'single') -> Any: ...
    def shift(self, periods: int = 1, freq: Optional[Any] = None, axis: int = 0, fill_value: Any = None) -> 'Series': ...
    def pct_change(self, periods: int = 1, fill_method: Optional[str] = None, limit: Optional[int] = None, freq: Optional[Any] = None) -> 'Series': ...
    def dropna(self, axis: int = 0, inplace: bool = False, how: Optional[str] = None) -> 'Series': ...
    def fillna(self, value: Any = None, method: Optional[str] = None, axis: Optional[int] = None, inplace: bool = False, limit: Optional[int] = None, downcast: Optional[Dict[str, Any]] = None) -> 'Series': ...
    def corr(self, other: 'Series', method: str = 'pearson', min_periods: Optional[int] = None) -> float: ...
    def apply(self, func: Callable, convert_dtype: bool = True, args: Tuple[Any, ...] = ..., **kwds: Any) -> 'Series': ...
    def diff(self, periods: int = 1) -> 'Series': ...
    def cumsum(self, axis: Optional[int] = None, skipna: bool = True) -> 'Series': ...
    def groupby(self, by: Any = None, axis: int = 0, level: Optional[Any] = None, as_index: bool = True, sort: bool = True, group_keys: bool = True, squeeze: bool = False, observed: bool = False, dropna: bool = True) -> Any: ...
    
    def __len__(self) -> int: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __add__(self, other: Any) -> 'Series': ...
    def __sub__(self, other: Any) -> 'Series': ...
    def __mul__(self, other: Any) -> 'Series': ...
    def __truediv__(self, other: Any) -> 'Series': ...
    def __lt__(self, other: Any) -> 'Series': ...
    def __le__(self, other: Any) -> 'Series': ...
    def __gt__(self, other: Any) -> 'Series': ...
    def __ge__(self, other: Any) -> 'Series': ...
    def __eq__(self, other: Any) -> 'Series': ...
    def __ne__(self, other: Any) -> 'Series': ...

class DataFrame:
    def __init__(self, data: Any = None, index: Any = None, columns: Any = None, dtype: Any = None, copy: bool = False) -> None: ...
    
    @property
    def iloc(self) -> Any: ...
    @property
    def loc(self) -> Any: ...
    @property
    def index(self) -> Any: ...
    @property
    def columns(self) -> Any: ...
    @property
    def empty(self) -> bool: ...
    @property
    def dtypes(self) -> Any: ...
    
    def sum(self, axis: Optional[int] = None, skipna: bool = True, level: Optional[Any] = None, numeric_only: Optional[bool] = None, min_count: int = 0) -> Union['Series', float]: ...
    def mean(self, axis: Optional[int] = None, skipna: bool = True, level: Optional[Any] = None, numeric_only: Optional[bool] = None) -> Union['Series', float]: ...
    def std(self, axis: Optional[int] = None, skipna: bool = True, level: Optional[Any] = None, ddof: int = 1, numeric_only: Optional[bool] = None) -> Union['Series', float]: ...
    def min(self, axis: Optional[int] = None, skipna: bool = True, level: Optional[Any] = None, numeric_only: Optional[bool] = None) -> Union['Series', float]: ...
    def max(self, axis: Optional[int] = None, skipna: bool = True, level: Optional[Any] = None, numeric_only: Optional[bool] = None) -> Union['Series', float]: ...
    def rolling(self, window: int, min_periods: Optional[int] = None, center: bool = False, win_type: Optional[str] = None, on: Optional[str] = None, axis: int = 0, closed: Optional[str] = None, method: str = 'single') -> Any: ...
    def resample(self, rule: str, axis: int = 0, closed: Optional[str] = None, label: Optional[str] = None, convention: str = 'start', kind: Optional[str] = None, loffset: Optional[Any] = None, limit: Optional[int] = None, on: Optional[str] = None, level: Optional[str] = None, origin: Optional[str] = None, offset: Optional[Any] = None, group_keys: bool = False) -> Any: ...
    def dropna(self, axis: int = 0, how: str = 'any', thresh: Optional[int] = None, subset: Optional[List[str]] = None, inplace: bool = False) -> Optional['DataFrame']: ...
    def fillna(self, value: Any = None, method: Optional[str] = None, axis: Optional[int] = None, inplace: bool = False, limit: Optional[int] = None, downcast: Optional[Dict[str, Any]] = None) -> Optional['DataFrame']: ...
    def isnull(self) -> 'DataFrame': ...
    def isnull(self) -> 'DataFrame': ...
    def agg(self, func: Union[str, Callable, List[Union[str, Callable]]], axis: int = 0, *args: Any, **kwargs: Any) -> Union['Series', 'DataFrame']: ...
    
    def __len__(self) -> int: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...

class DatetimeIndex:
    def __init__(self, data: Any = None, **kwargs: Any) -> None: ...
    def to_pydatetime(self) -> datetime: ...
    def __getitem__(self, key: Any) -> Any: ...

def to_datetime(
    arg: Union[float, str, datetime, Any],  # np.datetime64 removed
    errors: str = "raise",
    dayfirst: bool = False,
    yearfirst: bool = False,
    utc: bool = False,
    format: Optional[str] = None,
    exact: bool = True,
    unit: Optional[str] = None,
    origin: Union[Timestamp, datetime, Any] = "unix",
    cache: bool = True,
) -> Union[Timestamp, DatetimeIndex, Any]: ...

# Модульные функции

def concat(objs: Any, axis: int = 0, join: str = "outer", ignore_index: bool = False, keys: Any = None, levels: Any = None, names: Any = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) -> Any: ...
def read_csv(filepath_or_buffer: Any, sep: str = ",", delimiter: Any = None, header: Any = "infer", names: Any = None, index_col: Any = None, usecols: Any = None, engine: Any = None, converters: Any = None, true_values: Any = None, false_values: Any = None, skipinitialspace: bool = False, skiprows: Any = None, nrows: Optional[int] = None, na_values: Any = None, keep_default_na: bool = True, na_filter: bool = True, verbose: bool = False, skip_blank_lines: bool = True, parse_dates: Any = False, infer_datetime_format: bool = False, keep_date_col: bool = False, date_parser: Any = None, dayfirst: bool = False, cache_dates: bool = True, iterator: bool = False, chunksize: Optional[int] = None, compression: Any = 'infer', thousands: Any = None, decimal: str = '.', lineterminator: Any = None, quotechar: str = '"', quoting: int = 0, doublequote: bool = True, escapechar: Any = None, comment: Any = None, encoding: Any = None, encoding_errors: Any = 'strict', dialect: Any = None, error_bad_lines: bool = True, warn_bad_lines: bool = True, delim_whitespace: bool = False, low_memory: bool = True, memory_map: bool = False, float_precision: Any = None, storage_options: Any = None) -> DataFrame: ...
def read_parquet(path: Any, engine: Any = 'auto', columns: Any = None, **kwargs: Any) -> DataFrame: ...
def date_range(start: Any = None, end: Any = None, periods: Optional[int] = None, freq: Any = None, tz: Any = None, normalize: bool = False, name: Any = None, inclusive: str = "both", **kwargs: Any) -> Any: ...
def cut(x: Series, bins: Union[int, List[float]], right: bool = True, labels: Optional[List[str]] = None, retbins: bool = False, precision: int = 3, include_lowest: bool = False, duplicates: str = 'raise', ordered: bool = True) -> Any: ...
def isna(obj: Any) -> Any: ...
def array(data: Any, dtype: Any = None, copy: bool = True, order: str = 'K', subok: bool = False, ndmin: int = 0, like: Any = None) -> Any: ...

# Additional types that might be needed
class Index:
    def __init__(self, data: Any = None, **kwargs: Any) -> None: ...

class ExtensionArray:
    def __init__(self, data: Any = None, **kwargs: Any) -> None: ...

class Interval:
    left: Any
    right: Any
    closed: str
    def __contains__(self, key: Any) -> bool: ...
    def __init__(self, left: Any, right: Any, closed: str = ...) -> None: ...

# Type aliases for numpy arrays
NDArray = np.ndarray
